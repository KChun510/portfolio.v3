(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getUserAgent": (()=>getUserAgent)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
    }
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === "object" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version !== undefined) {
        return `Node.js/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version.substr(1)} (${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform}; ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].arch})`;
    }
    return "<environment undetectable>";
}
}}),
"[project]/node_modules/before-after-hook/lib/register.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @ts-check
__turbopack_context__.s({
    "register": (()=>register)
});
function register(state, name, method, options) {
    if (typeof method !== "function") {
        throw new Error("method for before hook must be a function");
    }
    if (!options) {
        options = {};
    }
    if (Array.isArray(name)) {
        return name.reverse().reduce((callback, name)=>{
            return register.bind(null, state, name, callback, options);
        }, method)();
    }
    return Promise.resolve().then(()=>{
        if (!state.registry[name]) {
            return method(options);
        }
        return state.registry[name].reduce((method, registered)=>{
            return registered.hook.bind(null, method, options);
        }, method)();
    });
}
}}),
"[project]/node_modules/before-after-hook/lib/add.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @ts-check
__turbopack_context__.s({
    "addHook": (()=>addHook)
});
function addHook(state, kind, name, hook) {
    const orig = hook;
    if (!state.registry[name]) {
        state.registry[name] = [];
    }
    if (kind === "before") {
        hook = (method, options)=>{
            return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
        };
    }
    if (kind === "after") {
        hook = (method, options)=>{
            let result;
            return Promise.resolve().then(method.bind(null, options)).then((result_)=>{
                result = result_;
                return orig(result, options);
            }).then(()=>{
                return result;
            });
        };
    }
    if (kind === "error") {
        hook = (method, options)=>{
            return Promise.resolve().then(method.bind(null, options)).catch((error)=>{
                return orig(error, options);
            });
        };
    }
    state.registry[name].push({
        hook: hook,
        orig: orig
    });
}
}}),
"[project]/node_modules/before-after-hook/lib/remove.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @ts-check
__turbopack_context__.s({
    "removeHook": (()=>removeHook)
});
function removeHook(state, name, method) {
    if (!state.registry[name]) {
        return;
    }
    const index = state.registry[name].map((registered)=>{
        return registered.orig;
    }).indexOf(method);
    if (index === -1) {
        return;
    }
    state.registry[name].splice(index, 1);
}
}}),
"[project]/node_modules/before-after-hook/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @ts-check
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/before-after-hook/lib/register.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$add$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/before-after-hook/lib/add.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$remove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/before-after-hook/lib/remove.js [app-client] (ecmascript)");
;
;
;
// bind with array of arguments: https://stackoverflow.com/a/21792913
const bind = Function.bind;
const bindable = bind.bind(bind);
function bindApi(hook, state, name) {
    const removeHookRef = bindable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$remove$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["removeHook"], null).apply(null, name ? [
        state,
        name
    ] : [
        state
    ]);
    hook.api = {
        remove: removeHookRef
    };
    hook.remove = removeHookRef;
    [
        "before",
        "error",
        "after",
        "wrap"
    ].forEach((kind)=>{
        const args = name ? [
            state,
            kind,
            name
        ] : [
            state,
            kind
        ];
        hook[kind] = hook.api[kind] = bindable(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$add$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["addHook"], null).apply(null, args);
    });
}
function Singular() {
    const singularHookName = Symbol("Singular");
    const singularHookState = {
        registry: {}
    };
    const singularHook = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["register"].bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
}
function Collection() {
    const state = {
        registry: {}
    };
    const hook = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$lib$2f$register$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["register"].bind(null, state);
    bindApi(hook, state);
    return hook;
}
const __TURBOPACK__default__export__ = {
    Singular,
    Collection
};
}}),
"[project]/node_modules/@octokit/endpoint/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/defaults.js
__turbopack_context__.s({
    "endpoint": (()=>endpoint)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/defaults.js
var userAgent = `octokit-endpoint.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`;
var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
        accept: "application/vnd.github.v3+json",
        "user-agent": userAgent
    },
    mediaType: {
        format: ""
    }
};
// pkg/dist-src/util/lowercase-keys.js
function lowercaseKeys(object) {
    if (!object) {
        return {};
    }
    return Object.keys(object).reduce((newObj, key)=>{
        newObj[key.toLowerCase()] = object[key];
        return newObj;
    }, {});
}
// pkg/dist-src/util/is-plain-object.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) return false;
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null) return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
// pkg/dist-src/util/merge-deep.js
function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key)=>{
        if (isPlainObject(options[key])) {
            if (!(key in defaults)) Object.assign(result, {
                [key]: options[key]
            });
            else result[key] = mergeDeep(defaults[key], options[key]);
        } else {
            Object.assign(result, {
                [key]: options[key]
            });
        }
    });
    return result;
}
// pkg/dist-src/util/remove-undefined-properties.js
function removeUndefinedProperties(obj) {
    for(const key in obj){
        if (obj[key] === void 0) {
            delete obj[key];
        }
    }
    return obj;
}
// pkg/dist-src/merge.js
function merge(defaults, route, options) {
    if (typeof route === "string") {
        let [method, url] = route.split(" ");
        options = Object.assign(url ? {
            method,
            url
        } : {
            url: method
        }, options);
    } else {
        options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (options.url === "/graphql") {
        if (defaults && defaults.mediaType.previews?.length) {
            mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview)=>!mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
        }
        mergedOptions.mediaType.previews = (mergedOptions.mediaType.previews || []).map((preview)=>preview.replace(/-preview/, ""));
    }
    return mergedOptions;
}
// pkg/dist-src/util/add-query-parameters.js
function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
        return url;
    }
    return url + separator + names.map((name)=>{
        if (name === "q") {
            return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
        }
        return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
}
// pkg/dist-src/util/extract-url-variable-names.js
var urlVariableRegex = /\{[^{}}]+\}/g;
function removeNonChars(variableName) {
    return variableName.replace(/(?:^\W+)|(?:(?<!\W)\W+$)/g, "").split(/,/);
}
function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
        return [];
    }
    return matches.map(removeNonChars).reduce((a, b)=>a.concat(b), []);
}
// pkg/dist-src/util/omit.js
function omit(object, keysToOmit) {
    const result = {
        __proto__: null
    };
    for (const key of Object.keys(object)){
        if (keysToOmit.indexOf(key) === -1) {
            result[key] = object[key];
        }
    }
    return result;
}
// pkg/dist-src/util/url-template.js
function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
        if (!/%[0-9A-Fa-f]/.test(part)) {
            part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
        }
        return part;
    }).join("");
}
function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
        return encodeUnreserved(key) + "=" + value;
    } else {
        return value;
    }
}
function isDefined(value) {
    return value !== void 0 && value !== null;
}
function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
}
function getValues(context, operator, key, modifier) {
    var value = context[key], result = [];
    if (isDefined(value) && value !== "") {
        if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
            value = value.toString();
            if (modifier && modifier !== "*") {
                value = value.substring(0, parseInt(modifier, 10));
            }
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
        } else {
            if (modifier === "*") {
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function(value2) {
                        result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
                    });
                } else {
                    Object.keys(value).forEach(function(k) {
                        if (isDefined(value[k])) {
                            result.push(encodeValue(operator, value[k], k));
                        }
                    });
                }
            } else {
                const tmp = [];
                if (Array.isArray(value)) {
                    value.filter(isDefined).forEach(function(value2) {
                        tmp.push(encodeValue(operator, value2));
                    });
                } else {
                    Object.keys(value).forEach(function(k) {
                        if (isDefined(value[k])) {
                            tmp.push(encodeUnreserved(k));
                            tmp.push(encodeValue(operator, value[k].toString()));
                        }
                    });
                }
                if (isKeyOperator(operator)) {
                    result.push(encodeUnreserved(key) + "=" + tmp.join(","));
                } else if (tmp.length !== 0) {
                    result.push(tmp.join(","));
                }
            }
        }
    } else {
        if (operator === ";") {
            if (isDefined(value)) {
                result.push(encodeUnreserved(key));
            }
        } else if (value === "" && (operator === "&" || operator === "?")) {
            result.push(encodeUnreserved(key) + "=");
        } else if (value === "") {
            result.push("");
        }
    }
    return result;
}
function parseUrl(template) {
    return {
        expand: expand.bind(null, template)
    };
}
function expand(template, context) {
    var operators = [
        "+",
        "#",
        ".",
        "/",
        ";",
        "?",
        "&"
    ];
    template = template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
        if (expression) {
            let operator = "";
            const values = [];
            if (operators.indexOf(expression.charAt(0)) !== -1) {
                operator = expression.charAt(0);
                expression = expression.substr(1);
            }
            expression.split(/,/g).forEach(function(variable) {
                var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
                values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
            });
            if (operator && operator !== "+") {
                var separator = ",";
                if (operator === "?") {
                    separator = "&";
                } else if (operator !== "#") {
                    separator = operator;
                }
                return (values.length !== 0 ? operator : "") + values.join(separator);
            } else {
                return values.join(",");
            }
        } else {
            return encodeReserved(literal);
        }
    });
    if (template === "/") {
        return template;
    } else {
        return template.replace(/\/$/, "");
    }
}
// pkg/dist-src/parse.js
function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, [
        "method",
        "baseUrl",
        "url",
        "headers",
        "request",
        "mediaType"
    ]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
        url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option)=>urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
        if (options.mediaType.format) {
            headers.accept = headers.accept.split(/,/).map((format)=>format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
        }
        if (url.endsWith("/graphql")) {
            if (options.mediaType.previews?.length) {
                const previewsFromAcceptHeader = headers.accept.match(/(?<![\w-])[\w-]+(?=-preview)/g) || [];
                headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview)=>{
                    const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
                    return `application/vnd.github.${preview}-preview${format}`;
                }).join(",");
            }
        }
    }
    if ([
        "GET",
        "HEAD"
    ].includes(method)) {
        url = addQueryParameters(url, remainingParameters);
    } else {
        if ("data" in remainingParameters) {
            body = remainingParameters.data;
        } else {
            if (Object.keys(remainingParameters).length) {
                body = remainingParameters;
            }
        }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
        headers["content-type"] = "application/json; charset=utf-8";
    }
    if ([
        "PATCH",
        "PUT"
    ].includes(method) && typeof body === "undefined") {
        body = "";
    }
    return Object.assign({
        method,
        url,
        headers
    }, typeof body !== "undefined" ? {
        body
    } : null, options.request ? {
        request: options.request
    } : null);
}
// pkg/dist-src/endpoint-with-defaults.js
function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
}
// pkg/dist-src/with-defaults.js
function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
        DEFAULTS: DEFAULTS2,
        defaults: withDefaults.bind(null, DEFAULTS2),
        merge: merge.bind(null, DEFAULTS2),
        parse
    });
}
// pkg/dist-src/index.js
var endpoint = withDefaults(null, DEFAULTS);
;
}}),
"[project]/node_modules/fast-content-type-parse/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const NullObject = function NullObject() {};
NullObject.prototype = Object.create(null);
/**
 * RegExp to match *( ";" parameter ) in RFC 7231 sec 3.1.1.1
 *
 * parameter     = token "=" ( token / quoted-string )
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE
 * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text
 * obs-text      = %x80-FF
 * quoted-pair   = "\" ( HTAB / SP / VCHAR / obs-text )
 */ const paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
/**
 * RegExp to match quoted-pair in RFC 7230 sec 3.2.6
 *
 * quoted-pair = "\" ( HTAB / SP / VCHAR / obs-text )
 * obs-text    = %x80-FF
 */ const quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
/**
 * RegExp to match type in RFC 7231 sec 3.1.1.1
 *
 * media-type = type "/" subtype
 * type       = token
 * subtype    = token
 */ const mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
// default ContentType to prevent repeated object creation
const defaultContentType = {
    type: '',
    parameters: new NullObject()
};
Object.freeze(defaultContentType.parameters);
Object.freeze(defaultContentType);
/**
 * Parse media type to object.
 *
 * @param {string|object} header
 * @return {Object}
 * @public
 */ function parse(header) {
    if (typeof header !== 'string') {
        throw new TypeError('argument header is required and must be a string');
    }
    let index = header.indexOf(';');
    const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
        throw new TypeError('invalid media type');
    }
    const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
    };
    // parse parameters
    if (index === -1) {
        return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index;
    while(match = paramRE.exec(header)){
        if (match.index !== index) {
            throw new TypeError('invalid parameter format');
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);
            quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
    }
    if (index !== header.length) {
        throw new TypeError('invalid parameter format');
    }
    return result;
}
function safeParse(header) {
    if (typeof header !== 'string') {
        return defaultContentType;
    }
    let index = header.indexOf(';');
    const type = index !== -1 ? header.slice(0, index).trim() : header.trim();
    if (mediaTypeRE.test(type) === false) {
        return defaultContentType;
    }
    const result = {
        type: type.toLowerCase(),
        parameters: new NullObject()
    };
    // parse parameters
    if (index === -1) {
        return result;
    }
    let key;
    let match;
    let value;
    paramRE.lastIndex = index;
    while(match = paramRE.exec(header)){
        if (match.index !== index) {
            return defaultContentType;
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (value[0] === '"') {
            // remove quotes and escapes
            value = value.slice(1, value.length - 1);
            quotedPairRE.test(value) && (value = value.replace(quotedPairRE, '$1'));
        }
        result.parameters[key] = value;
    }
    if (index !== header.length) {
        return defaultContentType;
    }
    return result;
}
module.exports.default = {
    parse,
    safeParse
};
module.exports.parse = parse;
module.exports.safeParse = safeParse;
module.exports.defaultContentType = defaultContentType;
}}),
"[project]/node_modules/@octokit/request-error/dist-src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RequestError": (()=>RequestError)
});
class RequestError extends Error {
    name;
    /**
   * http status code
   */ status;
    /**
   * Request options that lead to the error.
   */ request;
    /**
   * Response object if a response was received
   */ response;
    constructor(message, statusCode, options){
        super(message);
        this.name = "HttpError";
        this.status = Number.parseInt(statusCode);
        if (Number.isNaN(this.status)) {
            this.status = 0;
        }
        if ("response" in options) {
            this.response = options.response;
        }
        const requestCopy = Object.assign({}, options.request);
        if (options.request.headers.authorization) {
            requestCopy.headers = Object.assign({}, options.request.headers, {
                authorization: options.request.headers.authorization.replace(/(?<! ) .*$/, " [REDACTED]")
            });
        }
        requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = requestCopy;
    }
}
;
}}),
"[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "request": (()=>request)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$endpoint$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/endpoint/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/defaults.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
// pkg/dist-src/fetch-wrapper.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$content$2d$type$2d$parse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/fast-content-type-parse/index.js [app-client] (ecmascript)");
// pkg/dist-src/fetch-wrapper.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request-error/dist-src/index.js [app-client] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/defaults.js
var defaults_default = {
    headers: {
        "user-agent": `octokit-request.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    }
};
;
// pkg/dist-src/is-plain-object.js
function isPlainObject(value) {
    if (typeof value !== "object" || value === null) return false;
    if (Object.prototype.toString.call(value) !== "[object Object]") return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null) return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && Ctor instanceof Ctor && Function.prototype.call(Ctor) === Function.prototype.call(value);
}
;
async function fetchWrapper(requestOptions) {
    const fetch = requestOptions.request?.fetch || globalThis.fetch;
    if (!fetch) {
        throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");
    }
    const log = requestOptions.request?.log || console;
    const parseSuccessResponseBody = requestOptions.request?.parseSuccessResponseBody !== false;
    const body = isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body) ? JSON.stringify(requestOptions.body) : requestOptions.body;
    const requestHeaders = Object.fromEntries(Object.entries(requestOptions.headers).map(([name, value])=>[
            name,
            String(value)
        ]));
    let fetchResponse;
    try {
        fetchResponse = await fetch(requestOptions.url, {
            method: requestOptions.method,
            body,
            redirect: requestOptions.request?.redirect,
            headers: requestHeaders,
            signal: requestOptions.request?.signal,
            // duplex must be set if request.body is ReadableStream or Async Iterables.
            // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
            ...requestOptions.body && {
                duplex: "half"
            }
        });
    } catch (error) {
        let message = "Unknown Error";
        if (error instanceof Error) {
            if (error.name === "AbortError") {
                error.status = 500;
                throw error;
            }
            message = error.message;
            if (error.name === "TypeError" && "cause" in error) {
                if (error.cause instanceof Error) {
                    message = error.cause.message;
                } else if (typeof error.cause === "string") {
                    message = error.cause;
                }
            }
        }
        const requestError = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"](message, 500, {
            request: requestOptions
        });
        requestError.cause = error;
        throw requestError;
    }
    const status = fetchResponse.status;
    const url = fetchResponse.url;
    const responseHeaders = {};
    for (const [key, value] of fetchResponse.headers){
        responseHeaders[key] = value;
    }
    const octokitResponse = {
        url,
        status,
        headers: responseHeaders,
        data: ""
    };
    if ("deprecation" in responseHeaders) {
        const matches = responseHeaders.link && responseHeaders.link.match(/<([^<>]+)>; rel="deprecation"/);
        const deprecationLink = matches && matches.pop();
        log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${responseHeaders.sunset}${deprecationLink ? `. See ${deprecationLink}` : ""}`);
    }
    if (status === 204 || status === 205) {
        return octokitResponse;
    }
    if (requestOptions.method === "HEAD") {
        if (status < 400) {
            return octokitResponse;
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"](fetchResponse.statusText, status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    if (status === 304) {
        octokitResponse.data = await getResponseData(fetchResponse);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"]("Not modified", status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    if (status >= 400) {
        octokitResponse.data = await getResponseData(fetchResponse);
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"](toErrorMessage(octokitResponse.data), status, {
            response: octokitResponse,
            request: requestOptions
        });
    }
    octokitResponse.data = parseSuccessResponseBody ? await getResponseData(fetchResponse) : fetchResponse.body;
    return octokitResponse;
}
async function getResponseData(response) {
    const contentType = response.headers.get("content-type");
    if (!contentType) {
        return response.text().catch(()=>"");
    }
    const mimetype = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$fast$2d$content$2d$type$2d$parse$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["safeParse"])(contentType);
    if (isJSONResponse(mimetype)) {
        let text = "";
        try {
            text = await response.text();
            return JSON.parse(text);
        } catch (err) {
            return text;
        }
    } else if (mimetype.type.startsWith("text/") || mimetype.parameters.charset?.toLowerCase() === "utf-8") {
        return response.text().catch(()=>"");
    } else {
        return response.arrayBuffer().catch(()=>new ArrayBuffer(0));
    }
}
function isJSONResponse(mimetype) {
    return mimetype.type === "application/json" || mimetype.type === "application/scim+json";
}
function toErrorMessage(data) {
    if (typeof data === "string") {
        return data;
    }
    if (data instanceof ArrayBuffer) {
        return "Unknown error";
    }
    if ("message" in data) {
        const suffix = "documentation_url" in data ? ` - ${data.documentation_url}` : "";
        return Array.isArray(data.errors) ? `${data.message}: ${data.errors.map((v)=>JSON.stringify(v)).join(", ")}${suffix}` : `${data.message}${suffix}`;
    }
    return `Unknown error: ${JSON.stringify(data)}`;
}
// pkg/dist-src/with-defaults.js
function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
        const endpointOptions = endpoint2.merge(route, parameters);
        if (!endpointOptions.request || !endpointOptions.request.hook) {
            return fetchWrapper(endpoint2.parse(endpointOptions));
        }
        const request2 = (route2, parameters2)=>{
            return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
        };
        Object.assign(request2, {
            endpoint: endpoint2,
            defaults: withDefaults.bind(null, endpoint2)
        });
        return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
    });
}
// pkg/dist-src/index.js
var request = withDefaults(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$endpoint$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endpoint"], defaults_default);
;
}}),
"[project]/node_modules/@octokit/graphql/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "GraphqlResponseError": (()=>GraphqlResponseError),
    "graphql": (()=>graphql2),
    "withCustomRequest": (()=>withCustomRequest)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
;
// pkg/dist-src/error.js
function _buildMessageForResponseErrors(data) {
    return `Request failed due to following response errors:
` + data.errors.map((e)=>` - ${e.message}`).join("\n");
}
var GraphqlResponseError = class extends Error {
    constructor(request2, headers, response){
        super(_buildMessageForResponseErrors(response));
        this.request = request2;
        this.headers = headers;
        this.response = response;
        this.errors = response.errors;
        this.data = response.data;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "GraphqlResponseError";
    errors;
    data;
};
// pkg/dist-src/graphql.js
var NON_VARIABLE_OPTIONS = [
    "method",
    "baseUrl",
    "url",
    "headers",
    "request",
    "query",
    "mediaType",
    "operationName"
];
var FORBIDDEN_VARIABLE_OPTIONS = [
    "query",
    "method",
    "url"
];
var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request2, query, options) {
    if (options) {
        if (typeof query === "string" && "query" in options) {
            return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for(const key in options){
            if (!FORBIDDEN_VARIABLE_OPTIONS.includes(key)) continue;
            return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`));
        }
    }
    const parsedOptions = typeof query === "string" ? Object.assign({
        query
    }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key)=>{
        if (NON_VARIABLE_OPTIONS.includes(key)) {
            result[key] = parsedOptions[key];
            return result;
        }
        if (!result.variables) {
            result.variables = {};
        }
        result.variables[key] = parsedOptions[key];
        return result;
    }, {});
    const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
        requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request2(requestOptions).then((response)=>{
        if (response.data.errors) {
            const headers = {};
            for (const key of Object.keys(response.headers)){
                headers[key] = response.headers[key];
            }
            throw new GraphqlResponseError(requestOptions, headers, response.data);
        }
        return response.data.data;
    });
}
// pkg/dist-src/with-defaults.js
function withDefaults(request2, newDefaults) {
    const newRequest = request2.defaults(newDefaults);
    const newApi = (query, options)=>{
        return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
        defaults: withDefaults.bind(null, newRequest),
        endpoint: newRequest.endpoint
    });
}
// pkg/dist-src/index.js
var graphql2 = withDefaults(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"], {
    headers: {
        "user-agent": `octokit-graphql.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    },
    method: "POST",
    url: "/graphql"
});
function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
        method: "POST",
        url: "/graphql"
    });
}
;
}}),
"[project]/node_modules/@octokit/auth-token/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/is-jwt.js
__turbopack_context__.s({
    "createTokenAuth": (()=>createTokenAuth)
});
var b64url = "(?:[a-zA-Z0-9_-]+)";
var sep = "\\.";
var jwtRE = new RegExp(`^${b64url}${sep}${b64url}${sep}${b64url}$`);
var isJWT = jwtRE.test.bind(jwtRE);
// pkg/dist-src/auth.js
async function auth(token) {
    const isApp = isJWT(token);
    const isInstallation = token.startsWith("v1.") || token.startsWith("ghs_");
    const isUserToServer = token.startsWith("ghu_");
    const tokenType = isApp ? "app" : isInstallation ? "installation" : isUserToServer ? "user-to-server" : "oauth";
    return {
        type: "token",
        token,
        tokenType
    };
}
// pkg/dist-src/with-authorization-prefix.js
function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
        return `bearer ${token}`;
    }
    return `token ${token}`;
}
// pkg/dist-src/hook.js
async function hook(token, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    endpoint.headers.authorization = withAuthorizationPrefix(token);
    return request(endpoint);
}
// pkg/dist-src/index.js
var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
        hook: hook.bind(null, token)
    });
};
;
}}),
"[project]/node_modules/@octokit/core/dist-src/version.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = "6.1.5";
;
}}),
"[project]/node_modules/@octokit/core/dist-src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Octokit": (()=>Octokit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/before-after-hook/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/graphql/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$token$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-token/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/core/dist-src/version.js [app-client] (ecmascript)");
;
;
;
;
;
;
const noop = ()=>{};
const consoleWarn = console.warn.bind(console);
const consoleError = console.error.bind(console);
const userAgentTrail = `octokit-core.js/${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"]} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`;
class Octokit {
    static VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"];
    static defaults(defaults) {
        const OctokitWithDefaults = class extends this {
            constructor(...args){
                const options = args[0] || {};
                if (typeof defaults === "function") {
                    super(defaults(options));
                    return;
                }
                super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
                    userAgent: `${options.userAgent} ${defaults.userAgent}`
                } : null));
            }
        };
        return OctokitWithDefaults;
    }
    static plugins = [];
    /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */ static plugin(...newPlugins) {
        const currentPlugins = this.plugins;
        const NewOctokit = class extends this {
            static plugins = currentPlugins.concat(newPlugins.filter((plugin)=>!currentPlugins.includes(plugin)));
        };
        return NewOctokit;
    }
    constructor(options = {}){
        const hook = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$before$2d$after$2d$hook$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Collection();
        const requestDefaults = {
            baseUrl: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].endpoint.DEFAULTS.baseUrl,
            headers: {},
            request: Object.assign({}, options.request, {
                // @ts-ignore internal usage only, no need to type
                hook: hook.bind(null, "request")
            }),
            mediaType: {
                previews: [],
                format: ""
            }
        };
        requestDefaults.headers["user-agent"] = options.userAgent ? `${options.userAgent} ${userAgentTrail}` : userAgentTrail;
        if (options.baseUrl) {
            requestDefaults.baseUrl = options.baseUrl;
        }
        if (options.previews) {
            requestDefaults.mediaType.previews = options.previews;
        }
        if (options.timeZone) {
            requestDefaults.headers["time-zone"] = options.timeZone;
        }
        this.request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].defaults(requestDefaults);
        this.graphql = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withCustomRequest"])(this.request).defaults(requestDefaults);
        this.log = Object.assign({
            debug: noop,
            info: noop,
            warn: consoleWarn,
            error: consoleError
        }, options.log);
        this.hook = hook;
        if (!options.authStrategy) {
            if (!options.auth) {
                this.auth = async ()=>({
                        type: "unauthenticated"
                    });
            } else {
                const auth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$token$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createTokenAuth"])(options.auth);
                hook.wrap("request", auth.hook);
                this.auth = auth;
            }
        } else {
            const { authStrategy, ...otherOptions } = options;
            const auth = authStrategy(Object.assign({
                request: this.request,
                log: this.log,
                // we pass the current octokit instance as well as its constructor options
                // to allow for authentication strategies that return a new octokit instance
                // that shares the same internal state as the current one. The original
                // requirement for this was the "event-octokit" authentication strategy
                // of https://github.com/probot/octokit-auth-probot.
                octokit: this,
                octokitOptions: otherOptions
            }, options.auth));
            hook.wrap("request", auth.hook);
            this.auth = auth;
        }
        const classConstructor = this.constructor;
        for(let i = 0; i < classConstructor.plugins.length; ++i){
            Object.assign(this, classConstructor.plugins[i](this, options));
        }
    }
    // assigned during constructor
    request;
    graphql;
    log;
    hook;
    // TODO: type `octokit.auth` based on passed options.authStrategy
    auth;
}
;
}}),
"[project]/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/version.js
__turbopack_context__.s({
    "composePaginateRest": (()=>composePaginateRest),
    "isPaginatingEndpoint": (()=>isPaginatingEndpoint),
    "paginateRest": (()=>paginateRest),
    "paginatingEndpoints": (()=>paginatingEndpoints)
});
var VERSION = "0.0.0-development";
// pkg/dist-src/normalize-paginated-list-response.js
function normalizePaginatedListResponse(response) {
    if (!response.data) {
        return {
            ...response,
            data: []
        };
    }
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization) return response;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
        response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
        response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
}
// pkg/dist-src/iterator.js
function iterator(octokit, route, parameters) {
    const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
        [Symbol.asyncIterator]: ()=>({
                async next () {
                    if (!url) return {
                        done: true
                    };
                    try {
                        const response = await requestMethod({
                            method,
                            url,
                            headers
                        });
                        const normalizedResponse = normalizePaginatedListResponse(response);
                        url = ((normalizedResponse.headers.link || "").match(/<([^<>]+)>;\s*rel="next"/) || [])[1];
                        return {
                            value: normalizedResponse
                        };
                    } catch (error) {
                        if (error.status !== 409) throw error;
                        url = "";
                        return {
                            value: {
                                status: 200,
                                headers: {},
                                data: []
                            }
                        };
                    }
                }
            })
    };
}
// pkg/dist-src/paginate.js
function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
        mapFn = parameters;
        parameters = void 0;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}
function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result)=>{
        if (result.done) {
            return results;
        }
        let earlyExit = false;
        function done() {
            earlyExit = true;
        }
        results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
        if (earlyExit) {
            return results;
        }
        return gather(octokit, results, iterator2, mapFn);
    });
}
// pkg/dist-src/compose-paginate.js
var composePaginateRest = Object.assign(paginate, {
    iterator
});
// pkg/dist-src/generated/paginating-endpoints.js
var paginatingEndpoints = [
    "GET /advisories",
    "GET /app/hook/deliveries",
    "GET /app/installation-requests",
    "GET /app/installations",
    "GET /assignments/{assignment_id}/accepted_assignments",
    "GET /classrooms",
    "GET /classrooms/{classroom_id}/assignments",
    "GET /enterprises/{enterprise}/code-security/configurations",
    "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories",
    "GET /enterprises/{enterprise}/dependabot/alerts",
    "GET /enterprises/{enterprise}/secret-scanning/alerts",
    "GET /events",
    "GET /gists",
    "GET /gists/public",
    "GET /gists/starred",
    "GET /gists/{gist_id}/comments",
    "GET /gists/{gist_id}/commits",
    "GET /gists/{gist_id}/forks",
    "GET /installation/repositories",
    "GET /issues",
    "GET /licenses",
    "GET /marketplace_listing/plans",
    "GET /marketplace_listing/plans/{plan_id}/accounts",
    "GET /marketplace_listing/stubbed/plans",
    "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "GET /networks/{owner}/{repo}/events",
    "GET /notifications",
    "GET /organizations",
    "GET /orgs/{org}/actions/cache/usage-by-repository",
    "GET /orgs/{org}/actions/hosted-runners",
    "GET /orgs/{org}/actions/permissions/repositories",
    "GET /orgs/{org}/actions/runner-groups",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories",
    "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/runners",
    "GET /orgs/{org}/actions/runners",
    "GET /orgs/{org}/actions/secrets",
    "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/actions/variables",
    "GET /orgs/{org}/actions/variables/{name}/repositories",
    "GET /orgs/{org}/attestations/{subject_digest}",
    "GET /orgs/{org}/blocks",
    "GET /orgs/{org}/campaigns",
    "GET /orgs/{org}/code-scanning/alerts",
    "GET /orgs/{org}/code-security/configurations",
    "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories",
    "GET /orgs/{org}/codespaces",
    "GET /orgs/{org}/codespaces/secrets",
    "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/copilot/billing/seats",
    "GET /orgs/{org}/copilot/metrics",
    "GET /orgs/{org}/dependabot/alerts",
    "GET /orgs/{org}/dependabot/secrets",
    "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
    "GET /orgs/{org}/events",
    "GET /orgs/{org}/failed_invitations",
    "GET /orgs/{org}/hooks",
    "GET /orgs/{org}/hooks/{hook_id}/deliveries",
    "GET /orgs/{org}/insights/api/route-stats/{actor_type}/{actor_id}",
    "GET /orgs/{org}/insights/api/subject-stats",
    "GET /orgs/{org}/insights/api/user-stats/{user_id}",
    "GET /orgs/{org}/installations",
    "GET /orgs/{org}/invitations",
    "GET /orgs/{org}/invitations/{invitation_id}/teams",
    "GET /orgs/{org}/issues",
    "GET /orgs/{org}/members",
    "GET /orgs/{org}/members/{username}/codespaces",
    "GET /orgs/{org}/migrations",
    "GET /orgs/{org}/migrations/{migration_id}/repositories",
    "GET /orgs/{org}/organization-roles/{role_id}/teams",
    "GET /orgs/{org}/organization-roles/{role_id}/users",
    "GET /orgs/{org}/outside_collaborators",
    "GET /orgs/{org}/packages",
    "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
    "GET /orgs/{org}/personal-access-token-requests",
    "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
    "GET /orgs/{org}/personal-access-tokens",
    "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
    "GET /orgs/{org}/private-registries",
    "GET /orgs/{org}/projects",
    "GET /orgs/{org}/properties/values",
    "GET /orgs/{org}/public_members",
    "GET /orgs/{org}/repos",
    "GET /orgs/{org}/rulesets",
    "GET /orgs/{org}/rulesets/rule-suites",
    "GET /orgs/{org}/rulesets/{ruleset_id}/history",
    "GET /orgs/{org}/secret-scanning/alerts",
    "GET /orgs/{org}/security-advisories",
    "GET /orgs/{org}/settings/network-configurations",
    "GET /orgs/{org}/team/{team_slug}/copilot/metrics",
    "GET /orgs/{org}/teams",
    "GET /orgs/{org}/teams/{team_slug}/discussions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
    "GET /orgs/{org}/teams/{team_slug}/invitations",
    "GET /orgs/{org}/teams/{team_slug}/members",
    "GET /orgs/{org}/teams/{team_slug}/projects",
    "GET /orgs/{org}/teams/{team_slug}/repos",
    "GET /orgs/{org}/teams/{team_slug}/teams",
    "GET /projects/columns/{column_id}/cards",
    "GET /projects/{project_id}/collaborators",
    "GET /projects/{project_id}/columns",
    "GET /repos/{owner}/{repo}/actions/artifacts",
    "GET /repos/{owner}/{repo}/actions/caches",
    "GET /repos/{owner}/{repo}/actions/organization-secrets",
    "GET /repos/{owner}/{repo}/actions/organization-variables",
    "GET /repos/{owner}/{repo}/actions/runners",
    "GET /repos/{owner}/{repo}/actions/runs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
    "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
    "GET /repos/{owner}/{repo}/actions/secrets",
    "GET /repos/{owner}/{repo}/actions/variables",
    "GET /repos/{owner}/{repo}/actions/workflows",
    "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
    "GET /repos/{owner}/{repo}/activity",
    "GET /repos/{owner}/{repo}/assignees",
    "GET /repos/{owner}/{repo}/attestations/{subject_digest}",
    "GET /repos/{owner}/{repo}/branches",
    "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
    "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
    "GET /repos/{owner}/{repo}/code-scanning/alerts",
    "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
    "GET /repos/{owner}/{repo}/code-scanning/analyses",
    "GET /repos/{owner}/{repo}/codespaces",
    "GET /repos/{owner}/{repo}/codespaces/devcontainers",
    "GET /repos/{owner}/{repo}/codespaces/secrets",
    "GET /repos/{owner}/{repo}/collaborators",
    "GET /repos/{owner}/{repo}/comments",
    "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/commits",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
    "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
    "GET /repos/{owner}/{repo}/commits/{ref}/status",
    "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
    "GET /repos/{owner}/{repo}/contributors",
    "GET /repos/{owner}/{repo}/dependabot/alerts",
    "GET /repos/{owner}/{repo}/dependabot/secrets",
    "GET /repos/{owner}/{repo}/deployments",
    "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
    "GET /repos/{owner}/{repo}/environments",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
    "GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
    "GET /repos/{owner}/{repo}/events",
    "GET /repos/{owner}/{repo}/forks",
    "GET /repos/{owner}/{repo}/hooks",
    "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
    "GET /repos/{owner}/{repo}/invitations",
    "GET /repos/{owner}/{repo}/issues",
    "GET /repos/{owner}/{repo}/issues/comments",
    "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/issues/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues",
    "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
    "GET /repos/{owner}/{repo}/keys",
    "GET /repos/{owner}/{repo}/labels",
    "GET /repos/{owner}/{repo}/milestones",
    "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
    "GET /repos/{owner}/{repo}/notifications",
    "GET /repos/{owner}/{repo}/pages/builds",
    "GET /repos/{owner}/{repo}/projects",
    "GET /repos/{owner}/{repo}/pulls",
    "GET /repos/{owner}/{repo}/pulls/comments",
    "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
    "GET /repos/{owner}/{repo}/releases",
    "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
    "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
    "GET /repos/{owner}/{repo}/rules/branches/{branch}",
    "GET /repos/{owner}/{repo}/rulesets",
    "GET /repos/{owner}/{repo}/rulesets/rule-suites",
    "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts",
    "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
    "GET /repos/{owner}/{repo}/security-advisories",
    "GET /repos/{owner}/{repo}/stargazers",
    "GET /repos/{owner}/{repo}/subscribers",
    "GET /repos/{owner}/{repo}/tags",
    "GET /repos/{owner}/{repo}/teams",
    "GET /repos/{owner}/{repo}/topics",
    "GET /repositories",
    "GET /search/code",
    "GET /search/commits",
    "GET /search/issues",
    "GET /search/labels",
    "GET /search/repositories",
    "GET /search/topics",
    "GET /search/users",
    "GET /teams/{team_id}/discussions",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments",
    "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
    "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
    "GET /teams/{team_id}/invitations",
    "GET /teams/{team_id}/members",
    "GET /teams/{team_id}/projects",
    "GET /teams/{team_id}/repos",
    "GET /teams/{team_id}/teams",
    "GET /user/blocks",
    "GET /user/codespaces",
    "GET /user/codespaces/secrets",
    "GET /user/emails",
    "GET /user/followers",
    "GET /user/following",
    "GET /user/gpg_keys",
    "GET /user/installations",
    "GET /user/installations/{installation_id}/repositories",
    "GET /user/issues",
    "GET /user/keys",
    "GET /user/marketplace_purchases",
    "GET /user/marketplace_purchases/stubbed",
    "GET /user/memberships/orgs",
    "GET /user/migrations",
    "GET /user/migrations/{migration_id}/repositories",
    "GET /user/orgs",
    "GET /user/packages",
    "GET /user/packages/{package_type}/{package_name}/versions",
    "GET /user/public_emails",
    "GET /user/repos",
    "GET /user/repository_invitations",
    "GET /user/social_accounts",
    "GET /user/ssh_signing_keys",
    "GET /user/starred",
    "GET /user/subscriptions",
    "GET /user/teams",
    "GET /users",
    "GET /users/{username}/attestations/{subject_digest}",
    "GET /users/{username}/events",
    "GET /users/{username}/events/orgs/{org}",
    "GET /users/{username}/events/public",
    "GET /users/{username}/followers",
    "GET /users/{username}/following",
    "GET /users/{username}/gists",
    "GET /users/{username}/gpg_keys",
    "GET /users/{username}/keys",
    "GET /users/{username}/orgs",
    "GET /users/{username}/packages",
    "GET /users/{username}/projects",
    "GET /users/{username}/received_events",
    "GET /users/{username}/received_events/public",
    "GET /users/{username}/repos",
    "GET /users/{username}/social_accounts",
    "GET /users/{username}/ssh_signing_keys",
    "GET /users/{username}/starred",
    "GET /users/{username}/subscriptions"
];
// pkg/dist-src/paginating-endpoints.js
function isPaginatingEndpoint(arg) {
    if (typeof arg === "string") {
        return paginatingEndpoints.includes(arg);
    } else {
        return false;
    }
}
// pkg/dist-src/index.js
function paginateRest(octokit) {
    return {
        paginate: Object.assign(paginate.bind(null, octokit), {
            iterator: iterator.bind(null, octokit)
        })
    };
}
paginateRest.VERSION = VERSION;
;
}}),
"[project]/node_modules/@octokit/plugin-paginate-graphql/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/errors.js
__turbopack_context__.s({
    "VERSION": (()=>VERSION),
    "paginateGraphQL": (()=>paginateGraphQL)
});
var generateMessage = (path, cursorValue)=>`The cursor at "${path.join(",")}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`;
var MissingCursorChange = class extends Error {
    constructor(pageInfo, cursorValue){
        super(generateMessage(pageInfo.pathInQuery, cursorValue));
        this.pageInfo = pageInfo;
        this.cursorValue = cursorValue;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "MissingCursorChangeError";
};
var MissingPageInfo = class extends Error {
    constructor(response){
        super(`No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(response, null, 2)}`);
        this.response = response;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    name = "MissingPageInfo";
};
// pkg/dist-src/object-helpers.js
var isObject = (value)=>Object.prototype.toString.call(value) === "[object Object]";
function findPaginatedResourcePath(responseData) {
    const paginatedResourcePath = deepFindPathToProperty(responseData, "pageInfo");
    if (paginatedResourcePath.length === 0) {
        throw new MissingPageInfo(responseData);
    }
    return paginatedResourcePath;
}
var deepFindPathToProperty = (object, searchProp, path = [])=>{
    for (const key of Object.keys(object)){
        const currentPath = [
            ...path,
            key
        ];
        const currentValue = object[key];
        if (isObject(currentValue)) {
            if (currentValue.hasOwnProperty(searchProp)) {
                return currentPath;
            }
            const result = deepFindPathToProperty(currentValue, searchProp, currentPath);
            if (result.length > 0) {
                return result;
            }
        }
    }
    return [];
};
var get = (object, path)=>{
    return path.reduce((current, nextProperty)=>current[nextProperty], object);
};
var set = (object, path, mutator)=>{
    const lastProperty = path[path.length - 1];
    const parentPath = [
        ...path
    ].slice(0, -1);
    const parent = get(object, parentPath);
    if (typeof mutator === "function") {
        parent[lastProperty] = mutator(parent[lastProperty]);
    } else {
        parent[lastProperty] = mutator;
    }
};
// pkg/dist-src/extract-page-info.js
var extractPageInfos = (responseData)=>{
    const pageInfoPath = findPaginatedResourcePath(responseData);
    return {
        pathInQuery: pageInfoPath,
        pageInfo: get(responseData, [
            ...pageInfoPath,
            "pageInfo"
        ])
    };
};
// pkg/dist-src/page-info.js
var isForwardSearch = (givenPageInfo)=>{
    return givenPageInfo.hasOwnProperty("hasNextPage");
};
var getCursorFrom = (pageInfo)=>isForwardSearch(pageInfo) ? pageInfo.endCursor : pageInfo.startCursor;
var hasAnotherPage = (pageInfo)=>isForwardSearch(pageInfo) ? pageInfo.hasNextPage : pageInfo.hasPreviousPage;
// pkg/dist-src/iterator.js
var createIterator = (octokit)=>{
    return (query, initialParameters = {})=>{
        let nextPageExists = true;
        let parameters = {
            ...initialParameters
        };
        return {
            [Symbol.asyncIterator]: ()=>({
                    async next () {
                        if (!nextPageExists) return {
                            done: true,
                            value: {}
                        };
                        const response = await octokit.graphql(query, parameters);
                        const pageInfoContext = extractPageInfos(response);
                        const nextCursorValue = getCursorFrom(pageInfoContext.pageInfo);
                        nextPageExists = hasAnotherPage(pageInfoContext.pageInfo);
                        if (nextPageExists && nextCursorValue === parameters.cursor) {
                            throw new MissingCursorChange(pageInfoContext, nextCursorValue);
                        }
                        parameters = {
                            ...parameters,
                            cursor: nextCursorValue
                        };
                        return {
                            done: false,
                            value: response
                        };
                    }
                })
        };
    };
};
// pkg/dist-src/merge-responses.js
var mergeResponses = (response1, response2)=>{
    if (Object.keys(response1).length === 0) {
        return Object.assign(response1, response2);
    }
    const path = findPaginatedResourcePath(response1);
    const nodesPath = [
        ...path,
        "nodes"
    ];
    const newNodes = get(response2, nodesPath);
    if (newNodes) {
        set(response1, nodesPath, (values)=>{
            return [
                ...values,
                ...newNodes
            ];
        });
    }
    const edgesPath = [
        ...path,
        "edges"
    ];
    const newEdges = get(response2, edgesPath);
    if (newEdges) {
        set(response1, edgesPath, (values)=>{
            return [
                ...values,
                ...newEdges
            ];
        });
    }
    const pageInfoPath = [
        ...path,
        "pageInfo"
    ];
    set(response1, pageInfoPath, get(response2, pageInfoPath));
    return response1;
};
// pkg/dist-src/paginate.js
var createPaginate = (octokit)=>{
    const iterator = createIterator(octokit);
    return async (query, initialParameters = {})=>{
        let mergedResponse = {};
        for await (const response of iterator(query, initialParameters)){
            mergedResponse = mergeResponses(mergedResponse, response);
        }
        return mergedResponse;
    };
};
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/index.js
function paginateGraphQL(octokit) {
    return {
        graphql: Object.assign(octokit.graphql, {
            paginate: Object.assign(createPaginate(octokit), {
                iterator: createIterator(octokit)
            })
        })
    };
}
;
}}),
"[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "VERSION": (()=>VERSION)
});
const VERSION = "14.0.0";
;
 //# sourceMappingURL=version.js.map
}}),
"[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>endpoints_default)
});
const Endpoints = {
    actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        addCustomLabelsToSelfHostedRunnerForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        addRepoAccessToSelfHostedRunnerGroupInOrg: [
            "PUT /orgs/{org}/actions/runner-groups/{runner_group_id}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        approveWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"
        ],
        cancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"
        ],
        createEnvironmentVariable: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/variables"
        ],
        createHostedRunnerForOrg: [
            "POST /orgs/{org}/actions/hosted-runners"
        ],
        createOrUpdateEnvironmentSecret: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        createOrgVariable: [
            "POST /orgs/{org}/actions/variables"
        ],
        createRegistrationTokenForOrg: [
            "POST /orgs/{org}/actions/runners/registration-token"
        ],
        createRegistrationTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/registration-token"
        ],
        createRemoveTokenForOrg: [
            "POST /orgs/{org}/actions/runners/remove-token"
        ],
        createRemoveTokenForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/remove-token"
        ],
        createRepoVariable: [
            "POST /repos/{owner}/{repo}/actions/variables"
        ],
        createWorkflowDispatch: [
            "POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"
        ],
        deleteActionsCacheById: [
            "DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"
        ],
        deleteActionsCacheByKey: [
            "DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"
        ],
        deleteArtifact: [
            "DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        deleteEnvironmentSecret: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        deleteEnvironmentVariable: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        deleteHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        deleteOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}"
        ],
        deleteOrgVariable: [
            "DELETE /orgs/{org}/actions/variables/{name}"
        ],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        deleteRepoVariable: [
            "DELETE /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        deleteSelfHostedRunnerFromOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}"
        ],
        deleteSelfHostedRunnerFromRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        deleteWorkflowRun: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"
        ],
        deleteWorkflowRunLogs: [
            "DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        disableSelectedRepositoryGithubActionsOrganization: [
            "DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        disableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"
        ],
        downloadArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"
        ],
        downloadJobLogsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"
        ],
        downloadWorkflowRunAttemptLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"
        ],
        downloadWorkflowRunLogs: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"
        ],
        enableSelectedRepositoryGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"
        ],
        enableWorkflow: [
            "PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"
        ],
        forceCancelWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"
        ],
        generateRunnerJitconfigForOrg: [
            "POST /orgs/{org}/actions/runners/generate-jitconfig"
        ],
        generateRunnerJitconfigForRepo: [
            "POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"
        ],
        getActionsCacheList: [
            "GET /repos/{owner}/{repo}/actions/caches"
        ],
        getActionsCacheUsage: [
            "GET /repos/{owner}/{repo}/actions/cache/usage"
        ],
        getActionsCacheUsageByRepoForOrg: [
            "GET /orgs/{org}/actions/cache/usage-by-repository"
        ],
        getActionsCacheUsageForOrg: [
            "GET /orgs/{org}/actions/cache/usage"
        ],
        getAllowedActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/selected-actions"
        ],
        getAllowedActionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        getArtifact: [
            "GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"
        ],
        getCustomOidcSubClaimForRepo: [
            "GET /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        getEnvironmentPublicKey: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"
        ],
        getEnvironmentSecret: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"
        ],
        getEnvironmentVariable: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        getGithubActionsDefaultWorkflowPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions/workflow"
        ],
        getGithubActionsDefaultWorkflowPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        getGithubActionsPermissionsOrganization: [
            "GET /orgs/{org}/actions/permissions"
        ],
        getGithubActionsPermissionsRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions"
        ],
        getHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        getHostedRunnersGithubOwnedImagesForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/images/github-owned"
        ],
        getHostedRunnersLimitsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/limits"
        ],
        getHostedRunnersMachineSpecsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/machine-sizes"
        ],
        getHostedRunnersPartnerImagesForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/images/partner"
        ],
        getHostedRunnersPlatformsForOrg: [
            "GET /orgs/{org}/actions/hosted-runners/platforms"
        ],
        getJobForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/jobs/{job_id}"
        ],
        getOrgPublicKey: [
            "GET /orgs/{org}/actions/secrets/public-key"
        ],
        getOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}"
        ],
        getOrgVariable: [
            "GET /orgs/{org}/actions/variables/{name}"
        ],
        getPendingDeploymentsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        getRepoPermissions: [
            "GET /repos/{owner}/{repo}/actions/permissions",
            {},
            {
                renamed: [
                    "actions",
                    "getGithubActionsPermissionsRepository"
                ]
            }
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/actions/secrets/public-key"
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"
        ],
        getRepoVariable: [
            "GET /repos/{owner}/{repo}/actions/variables/{name}"
        ],
        getReviewsForRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"
        ],
        getSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}"
        ],
        getSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}"
        ],
        getWorkflow: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"
        ],
        getWorkflowAccessToRepository: [
            "GET /repos/{owner}/{repo}/actions/permissions/access"
        ],
        getWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}"
        ],
        getWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"
        ],
        getWorkflowRunUsage: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"
        ],
        getWorkflowUsage: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"
        ],
        listArtifactsForRepo: [
            "GET /repos/{owner}/{repo}/actions/artifacts"
        ],
        listEnvironmentSecrets: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"
        ],
        listEnvironmentVariables: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/variables"
        ],
        listGithubHostedRunnersInGroupForOrg: [
            "GET /orgs/{org}/actions/runner-groups/{runner_group_id}/hosted-runners"
        ],
        listHostedRunnersForOrg: [
            "GET /orgs/{org}/actions/hosted-runners"
        ],
        listJobsForWorkflowRun: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"
        ],
        listJobsForWorkflowRunAttempt: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"
        ],
        listLabelsForSelfHostedRunnerForOrg: [
            "GET /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        listLabelsForSelfHostedRunnerForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        listOrgSecrets: [
            "GET /orgs/{org}/actions/secrets"
        ],
        listOrgVariables: [
            "GET /orgs/{org}/actions/variables"
        ],
        listRepoOrganizationSecrets: [
            "GET /repos/{owner}/{repo}/actions/organization-secrets"
        ],
        listRepoOrganizationVariables: [
            "GET /repos/{owner}/{repo}/actions/organization-variables"
        ],
        listRepoSecrets: [
            "GET /repos/{owner}/{repo}/actions/secrets"
        ],
        listRepoVariables: [
            "GET /repos/{owner}/{repo}/actions/variables"
        ],
        listRepoWorkflows: [
            "GET /repos/{owner}/{repo}/actions/workflows"
        ],
        listRunnerApplicationsForOrg: [
            "GET /orgs/{org}/actions/runners/downloads"
        ],
        listRunnerApplicationsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners/downloads"
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        listSelectedReposForOrgVariable: [
            "GET /orgs/{org}/actions/variables/{name}/repositories"
        ],
        listSelectedRepositoriesEnabledGithubActionsOrganization: [
            "GET /orgs/{org}/actions/permissions/repositories"
        ],
        listSelfHostedRunnersForOrg: [
            "GET /orgs/{org}/actions/runners"
        ],
        listSelfHostedRunnersForRepo: [
            "GET /repos/{owner}/{repo}/actions/runners"
        ],
        listWorkflowRunArtifacts: [
            "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"
        ],
        listWorkflowRuns: [
            "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"
        ],
        listWorkflowRunsForRepo: [
            "GET /repos/{owner}/{repo}/actions/runs"
        ],
        reRunJobForWorkflowRun: [
            "POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"
        ],
        reRunWorkflow: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"
        ],
        reRunWorkflowFailedJobs: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        removeCustomLabelFromSelfHostedRunnerForOrg: [
            "DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeCustomLabelFromSelfHostedRunnerForRepo: [
            "DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgVariable: [
            "DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"
        ],
        reviewCustomGatesForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"
        ],
        reviewPendingDeploymentsForRun: [
            "POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"
        ],
        setAllowedActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/selected-actions"
        ],
        setAllowedActionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"
        ],
        setCustomLabelsForSelfHostedRunnerForOrg: [
            "PUT /orgs/{org}/actions/runners/{runner_id}/labels"
        ],
        setCustomLabelsForSelfHostedRunnerForRepo: [
            "PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"
        ],
        setCustomOidcSubClaimForRepo: [
            "PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"
        ],
        setGithubActionsDefaultWorkflowPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/workflow"
        ],
        setGithubActionsDefaultWorkflowPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/workflow"
        ],
        setGithubActionsPermissionsOrganization: [
            "PUT /orgs/{org}/actions/permissions"
        ],
        setGithubActionsPermissionsRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions"
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgVariable: [
            "PUT /orgs/{org}/actions/variables/{name}/repositories"
        ],
        setSelectedRepositoriesEnabledGithubActionsOrganization: [
            "PUT /orgs/{org}/actions/permissions/repositories"
        ],
        setWorkflowAccessToRepository: [
            "PUT /repos/{owner}/{repo}/actions/permissions/access"
        ],
        updateEnvironmentVariable: [
            "PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"
        ],
        updateHostedRunnerForOrg: [
            "PATCH /orgs/{org}/actions/hosted-runners/{hosted_runner_id}"
        ],
        updateOrgVariable: [
            "PATCH /orgs/{org}/actions/variables/{name}"
        ],
        updateRepoVariable: [
            "PATCH /repos/{owner}/{repo}/actions/variables/{name}"
        ]
    },
    activity: {
        checkRepoIsStarredByAuthenticatedUser: [
            "GET /user/starred/{owner}/{repo}"
        ],
        deleteRepoSubscription: [
            "DELETE /repos/{owner}/{repo}/subscription"
        ],
        deleteThreadSubscription: [
            "DELETE /notifications/threads/{thread_id}/subscription"
        ],
        getFeeds: [
            "GET /feeds"
        ],
        getRepoSubscription: [
            "GET /repos/{owner}/{repo}/subscription"
        ],
        getThread: [
            "GET /notifications/threads/{thread_id}"
        ],
        getThreadSubscriptionForAuthenticatedUser: [
            "GET /notifications/threads/{thread_id}/subscription"
        ],
        listEventsForAuthenticatedUser: [
            "GET /users/{username}/events"
        ],
        listNotificationsForAuthenticatedUser: [
            "GET /notifications"
        ],
        listOrgEventsForAuthenticatedUser: [
            "GET /users/{username}/events/orgs/{org}"
        ],
        listPublicEvents: [
            "GET /events"
        ],
        listPublicEventsForRepoNetwork: [
            "GET /networks/{owner}/{repo}/events"
        ],
        listPublicEventsForUser: [
            "GET /users/{username}/events/public"
        ],
        listPublicOrgEvents: [
            "GET /orgs/{org}/events"
        ],
        listReceivedEventsForUser: [
            "GET /users/{username}/received_events"
        ],
        listReceivedPublicEventsForUser: [
            "GET /users/{username}/received_events/public"
        ],
        listRepoEvents: [
            "GET /repos/{owner}/{repo}/events"
        ],
        listRepoNotificationsForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/notifications"
        ],
        listReposStarredByAuthenticatedUser: [
            "GET /user/starred"
        ],
        listReposStarredByUser: [
            "GET /users/{username}/starred"
        ],
        listReposWatchedByUser: [
            "GET /users/{username}/subscriptions"
        ],
        listStargazersForRepo: [
            "GET /repos/{owner}/{repo}/stargazers"
        ],
        listWatchedReposForAuthenticatedUser: [
            "GET /user/subscriptions"
        ],
        listWatchersForRepo: [
            "GET /repos/{owner}/{repo}/subscribers"
        ],
        markNotificationsAsRead: [
            "PUT /notifications"
        ],
        markRepoNotificationsAsRead: [
            "PUT /repos/{owner}/{repo}/notifications"
        ],
        markThreadAsDone: [
            "DELETE /notifications/threads/{thread_id}"
        ],
        markThreadAsRead: [
            "PATCH /notifications/threads/{thread_id}"
        ],
        setRepoSubscription: [
            "PUT /repos/{owner}/{repo}/subscription"
        ],
        setThreadSubscription: [
            "PUT /notifications/threads/{thread_id}/subscription"
        ],
        starRepoForAuthenticatedUser: [
            "PUT /user/starred/{owner}/{repo}"
        ],
        unstarRepoForAuthenticatedUser: [
            "DELETE /user/starred/{owner}/{repo}"
        ]
    },
    apps: {
        addRepoToInstallation: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            {
                renamed: [
                    "apps",
                    "addRepoToInstallationForAuthenticatedUser"
                ]
            }
        ],
        addRepoToInstallationForAuthenticatedUser: [
            "PUT /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        checkToken: [
            "POST /applications/{client_id}/token"
        ],
        createFromManifest: [
            "POST /app-manifests/{code}/conversions"
        ],
        createInstallationAccessToken: [
            "POST /app/installations/{installation_id}/access_tokens"
        ],
        deleteAuthorization: [
            "DELETE /applications/{client_id}/grant"
        ],
        deleteInstallation: [
            "DELETE /app/installations/{installation_id}"
        ],
        deleteToken: [
            "DELETE /applications/{client_id}/token"
        ],
        getAuthenticated: [
            "GET /app"
        ],
        getBySlug: [
            "GET /apps/{app_slug}"
        ],
        getInstallation: [
            "GET /app/installations/{installation_id}"
        ],
        getOrgInstallation: [
            "GET /orgs/{org}/installation"
        ],
        getRepoInstallation: [
            "GET /repos/{owner}/{repo}/installation"
        ],
        getSubscriptionPlanForAccount: [
            "GET /marketplace_listing/accounts/{account_id}"
        ],
        getSubscriptionPlanForAccountStubbed: [
            "GET /marketplace_listing/stubbed/accounts/{account_id}"
        ],
        getUserInstallation: [
            "GET /users/{username}/installation"
        ],
        getWebhookConfigForApp: [
            "GET /app/hook/config"
        ],
        getWebhookDelivery: [
            "GET /app/hook/deliveries/{delivery_id}"
        ],
        listAccountsForPlan: [
            "GET /marketplace_listing/plans/{plan_id}/accounts"
        ],
        listAccountsForPlanStubbed: [
            "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"
        ],
        listInstallationReposForAuthenticatedUser: [
            "GET /user/installations/{installation_id}/repositories"
        ],
        listInstallationRequestsForAuthenticatedApp: [
            "GET /app/installation-requests"
        ],
        listInstallations: [
            "GET /app/installations"
        ],
        listInstallationsForAuthenticatedUser: [
            "GET /user/installations"
        ],
        listPlans: [
            "GET /marketplace_listing/plans"
        ],
        listPlansStubbed: [
            "GET /marketplace_listing/stubbed/plans"
        ],
        listReposAccessibleToInstallation: [
            "GET /installation/repositories"
        ],
        listSubscriptionsForAuthenticatedUser: [
            "GET /user/marketplace_purchases"
        ],
        listSubscriptionsForAuthenticatedUserStubbed: [
            "GET /user/marketplace_purchases/stubbed"
        ],
        listWebhookDeliveries: [
            "GET /app/hook/deliveries"
        ],
        redeliverWebhookDelivery: [
            "POST /app/hook/deliveries/{delivery_id}/attempts"
        ],
        removeRepoFromInstallation: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
            {},
            {
                renamed: [
                    "apps",
                    "removeRepoFromInstallationForAuthenticatedUser"
                ]
            }
        ],
        removeRepoFromInstallationForAuthenticatedUser: [
            "DELETE /user/installations/{installation_id}/repositories/{repository_id}"
        ],
        resetToken: [
            "PATCH /applications/{client_id}/token"
        ],
        revokeInstallationAccessToken: [
            "DELETE /installation/token"
        ],
        scopeToken: [
            "POST /applications/{client_id}/token/scoped"
        ],
        suspendInstallation: [
            "PUT /app/installations/{installation_id}/suspended"
        ],
        unsuspendInstallation: [
            "DELETE /app/installations/{installation_id}/suspended"
        ],
        updateWebhookConfigForApp: [
            "PATCH /app/hook/config"
        ]
    },
    billing: {
        getGithubActionsBillingOrg: [
            "GET /orgs/{org}/settings/billing/actions"
        ],
        getGithubActionsBillingUser: [
            "GET /users/{username}/settings/billing/actions"
        ],
        getGithubBillingUsageReportOrg: [
            "GET /organizations/{org}/settings/billing/usage"
        ],
        getGithubPackagesBillingOrg: [
            "GET /orgs/{org}/settings/billing/packages"
        ],
        getGithubPackagesBillingUser: [
            "GET /users/{username}/settings/billing/packages"
        ],
        getSharedStorageBillingOrg: [
            "GET /orgs/{org}/settings/billing/shared-storage"
        ],
        getSharedStorageBillingUser: [
            "GET /users/{username}/settings/billing/shared-storage"
        ]
    },
    campaigns: {
        createCampaign: [
            "POST /orgs/{org}/campaigns"
        ],
        deleteCampaign: [
            "DELETE /orgs/{org}/campaigns/{campaign_number}"
        ],
        getCampaignSummary: [
            "GET /orgs/{org}/campaigns/{campaign_number}"
        ],
        listOrgCampaigns: [
            "GET /orgs/{org}/campaigns"
        ],
        updateCampaign: [
            "PATCH /orgs/{org}/campaigns/{campaign_number}"
        ]
    },
    checks: {
        create: [
            "POST /repos/{owner}/{repo}/check-runs"
        ],
        createSuite: [
            "POST /repos/{owner}/{repo}/check-suites"
        ],
        get: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}"
        ],
        getSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"
        ],
        listAnnotations: [
            "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"
        ],
        listForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/check-runs"
        ],
        listForSuite: [
            "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"
        ],
        listSuitesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/check-suites"
        ],
        rerequestRun: [
            "POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"
        ],
        rerequestSuite: [
            "POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"
        ],
        setSuitesPreferences: [
            "PATCH /repos/{owner}/{repo}/check-suites/preferences"
        ],
        update: [
            "PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"
        ]
    },
    codeScanning: {
        commitAutofix: [
            "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix/commits"
        ],
        createAutofix: [
            "POST /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        ],
        createVariantAnalysis: [
            "POST /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses"
        ],
        deleteAnalysis: [
            "DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"
        ],
        deleteCodeqlDatabase: [
            "DELETE /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",
            {},
            {
                renamedParameters: {
                    alert_id: "alert_number"
                }
            }
        ],
        getAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"
        ],
        getAutofix: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/autofix"
        ],
        getCodeqlDatabase: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"
        ],
        getDefaultSetup: [
            "GET /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        getSarif: [
            "GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"
        ],
        getVariantAnalysis: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}"
        ],
        getVariantAnalysisRepoTask: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/variant-analyses/{codeql_variant_analysis_id}/repos/{repo_owner}/{repo_name}"
        ],
        listAlertInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"
        ],
        listAlertsForOrg: [
            "GET /orgs/{org}/code-scanning/alerts"
        ],
        listAlertsForRepo: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts"
        ],
        listAlertsInstances: [
            "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
            {},
            {
                renamed: [
                    "codeScanning",
                    "listAlertInstances"
                ]
            }
        ],
        listCodeqlDatabases: [
            "GET /repos/{owner}/{repo}/code-scanning/codeql/databases"
        ],
        listRecentAnalyses: [
            "GET /repos/{owner}/{repo}/code-scanning/analyses"
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"
        ],
        updateDefaultSetup: [
            "PATCH /repos/{owner}/{repo}/code-scanning/default-setup"
        ],
        uploadSarif: [
            "POST /repos/{owner}/{repo}/code-scanning/sarifs"
        ]
    },
    codeSecurity: {
        attachConfiguration: [
            "POST /orgs/{org}/code-security/configurations/{configuration_id}/attach"
        ],
        attachEnterpriseConfiguration: [
            "POST /enterprises/{enterprise}/code-security/configurations/{configuration_id}/attach"
        ],
        createConfiguration: [
            "POST /orgs/{org}/code-security/configurations"
        ],
        createConfigurationForEnterprise: [
            "POST /enterprises/{enterprise}/code-security/configurations"
        ],
        deleteConfiguration: [
            "DELETE /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        deleteConfigurationForEnterprise: [
            "DELETE /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ],
        detachConfiguration: [
            "DELETE /orgs/{org}/code-security/configurations/detach"
        ],
        getConfiguration: [
            "GET /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        getConfigurationForRepository: [
            "GET /repos/{owner}/{repo}/code-security-configuration"
        ],
        getConfigurationsForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations"
        ],
        getConfigurationsForOrg: [
            "GET /orgs/{org}/code-security/configurations"
        ],
        getDefaultConfigurations: [
            "GET /orgs/{org}/code-security/configurations/defaults"
        ],
        getDefaultConfigurationsForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations/defaults"
        ],
        getRepositoriesForConfiguration: [
            "GET /orgs/{org}/code-security/configurations/{configuration_id}/repositories"
        ],
        getRepositoriesForEnterpriseConfiguration: [
            "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}/repositories"
        ],
        getSingleConfigurationForEnterprise: [
            "GET /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ],
        setConfigurationAsDefault: [
            "PUT /orgs/{org}/code-security/configurations/{configuration_id}/defaults"
        ],
        setConfigurationAsDefaultForEnterprise: [
            "PUT /enterprises/{enterprise}/code-security/configurations/{configuration_id}/defaults"
        ],
        updateConfiguration: [
            "PATCH /orgs/{org}/code-security/configurations/{configuration_id}"
        ],
        updateEnterpriseConfiguration: [
            "PATCH /enterprises/{enterprise}/code-security/configurations/{configuration_id}"
        ]
    },
    codesOfConduct: {
        getAllCodesOfConduct: [
            "GET /codes_of_conduct"
        ],
        getConductCode: [
            "GET /codes_of_conduct/{key}"
        ]
    },
    codespaces: {
        addRepositoryForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        checkPermissionsForDevcontainer: [
            "GET /repos/{owner}/{repo}/codespaces/permissions_check"
        ],
        codespaceMachinesForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/machines"
        ],
        createForAuthenticatedUser: [
            "POST /user/codespaces"
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        createOrUpdateSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}"
        ],
        createWithPrForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"
        ],
        createWithRepoForAuthenticatedUser: [
            "POST /repos/{owner}/{repo}/codespaces"
        ],
        deleteForAuthenticatedUser: [
            "DELETE /user/codespaces/{codespace_name}"
        ],
        deleteFromOrganization: [
            "DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"
        ],
        deleteOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        deleteSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}"
        ],
        exportForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/exports"
        ],
        getCodespacesForUserInOrg: [
            "GET /orgs/{org}/members/{username}/codespaces"
        ],
        getExportDetailsForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}/exports/{export_id}"
        ],
        getForAuthenticatedUser: [
            "GET /user/codespaces/{codespace_name}"
        ],
        getOrgPublicKey: [
            "GET /orgs/{org}/codespaces/secrets/public-key"
        ],
        getOrgSecret: [
            "GET /orgs/{org}/codespaces/secrets/{secret_name}"
        ],
        getPublicKeyForAuthenticatedUser: [
            "GET /user/codespaces/secrets/public-key"
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/public-key"
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"
        ],
        getSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}"
        ],
        listDevcontainersInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/devcontainers"
        ],
        listForAuthenticatedUser: [
            "GET /user/codespaces"
        ],
        listInOrganization: [
            "GET /orgs/{org}/codespaces",
            {},
            {
                renamedParameters: {
                    org_id: "org"
                }
            }
        ],
        listInRepositoryForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces"
        ],
        listOrgSecrets: [
            "GET /orgs/{org}/codespaces/secrets"
        ],
        listRepoSecrets: [
            "GET /repos/{owner}/{repo}/codespaces/secrets"
        ],
        listRepositoriesForSecretForAuthenticatedUser: [
            "GET /user/codespaces/secrets/{secret_name}/repositories"
        ],
        listSecretsForAuthenticatedUser: [
            "GET /user/codespaces/secrets"
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        preFlightWithRepoForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/new"
        ],
        publishForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/publish"
        ],
        removeRepositoryForSecretForAuthenticatedUser: [
            "DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"
        ],
        repoMachinesForAuthenticatedUser: [
            "GET /repos/{owner}/{repo}/codespaces/machines"
        ],
        setRepositoriesForSecretForAuthenticatedUser: [
            "PUT /user/codespaces/secrets/{secret_name}/repositories"
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"
        ],
        startForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/start"
        ],
        stopForAuthenticatedUser: [
            "POST /user/codespaces/{codespace_name}/stop"
        ],
        stopInOrganization: [
            "POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"
        ],
        updateForAuthenticatedUser: [
            "PATCH /user/codespaces/{codespace_name}"
        ]
    },
    copilot: {
        addCopilotSeatsForTeams: [
            "POST /orgs/{org}/copilot/billing/selected_teams"
        ],
        addCopilotSeatsForUsers: [
            "POST /orgs/{org}/copilot/billing/selected_users"
        ],
        cancelCopilotSeatAssignmentForTeams: [
            "DELETE /orgs/{org}/copilot/billing/selected_teams"
        ],
        cancelCopilotSeatAssignmentForUsers: [
            "DELETE /orgs/{org}/copilot/billing/selected_users"
        ],
        copilotMetricsForOrganization: [
            "GET /orgs/{org}/copilot/metrics"
        ],
        copilotMetricsForTeam: [
            "GET /orgs/{org}/team/{team_slug}/copilot/metrics"
        ],
        getCopilotOrganizationDetails: [
            "GET /orgs/{org}/copilot/billing"
        ],
        getCopilotSeatDetailsForUser: [
            "GET /orgs/{org}/members/{username}/copilot"
        ],
        listCopilotSeats: [
            "GET /orgs/{org}/copilot/billing/seats"
        ]
    },
    dependabot: {
        addSelectedRepoToOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        createOrUpdateOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        createOrUpdateRepoSecret: [
            "PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        deleteOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        deleteRepoSecret: [
            "DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ],
        getOrgPublicKey: [
            "GET /orgs/{org}/dependabot/secrets/public-key"
        ],
        getOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}"
        ],
        getRepoPublicKey: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/public-key"
        ],
        getRepoSecret: [
            "GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/dependabot/alerts"
        ],
        listAlertsForOrg: [
            "GET /orgs/{org}/dependabot/alerts"
        ],
        listAlertsForRepo: [
            "GET /repos/{owner}/{repo}/dependabot/alerts"
        ],
        listOrgSecrets: [
            "GET /orgs/{org}/dependabot/secrets"
        ],
        listRepoSecrets: [
            "GET /repos/{owner}/{repo}/dependabot/secrets"
        ],
        listSelectedReposForOrgSecret: [
            "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        removeSelectedRepoFromOrgSecret: [
            "DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"
        ],
        setSelectedReposForOrgSecret: [
            "PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"
        ]
    },
    dependencyGraph: {
        createRepositorySnapshot: [
            "POST /repos/{owner}/{repo}/dependency-graph/snapshots"
        ],
        diffRange: [
            "GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"
        ],
        exportSbom: [
            "GET /repos/{owner}/{repo}/dependency-graph/sbom"
        ]
    },
    emojis: {
        get: [
            "GET /emojis"
        ]
    },
    gists: {
        checkIsStarred: [
            "GET /gists/{gist_id}/star"
        ],
        create: [
            "POST /gists"
        ],
        createComment: [
            "POST /gists/{gist_id}/comments"
        ],
        delete: [
            "DELETE /gists/{gist_id}"
        ],
        deleteComment: [
            "DELETE /gists/{gist_id}/comments/{comment_id}"
        ],
        fork: [
            "POST /gists/{gist_id}/forks"
        ],
        get: [
            "GET /gists/{gist_id}"
        ],
        getComment: [
            "GET /gists/{gist_id}/comments/{comment_id}"
        ],
        getRevision: [
            "GET /gists/{gist_id}/{sha}"
        ],
        list: [
            "GET /gists"
        ],
        listComments: [
            "GET /gists/{gist_id}/comments"
        ],
        listCommits: [
            "GET /gists/{gist_id}/commits"
        ],
        listForUser: [
            "GET /users/{username}/gists"
        ],
        listForks: [
            "GET /gists/{gist_id}/forks"
        ],
        listPublic: [
            "GET /gists/public"
        ],
        listStarred: [
            "GET /gists/starred"
        ],
        star: [
            "PUT /gists/{gist_id}/star"
        ],
        unstar: [
            "DELETE /gists/{gist_id}/star"
        ],
        update: [
            "PATCH /gists/{gist_id}"
        ],
        updateComment: [
            "PATCH /gists/{gist_id}/comments/{comment_id}"
        ]
    },
    git: {
        createBlob: [
            "POST /repos/{owner}/{repo}/git/blobs"
        ],
        createCommit: [
            "POST /repos/{owner}/{repo}/git/commits"
        ],
        createRef: [
            "POST /repos/{owner}/{repo}/git/refs"
        ],
        createTag: [
            "POST /repos/{owner}/{repo}/git/tags"
        ],
        createTree: [
            "POST /repos/{owner}/{repo}/git/trees"
        ],
        deleteRef: [
            "DELETE /repos/{owner}/{repo}/git/refs/{ref}"
        ],
        getBlob: [
            "GET /repos/{owner}/{repo}/git/blobs/{file_sha}"
        ],
        getCommit: [
            "GET /repos/{owner}/{repo}/git/commits/{commit_sha}"
        ],
        getRef: [
            "GET /repos/{owner}/{repo}/git/ref/{ref}"
        ],
        getTag: [
            "GET /repos/{owner}/{repo}/git/tags/{tag_sha}"
        ],
        getTree: [
            "GET /repos/{owner}/{repo}/git/trees/{tree_sha}"
        ],
        listMatchingRefs: [
            "GET /repos/{owner}/{repo}/git/matching-refs/{ref}"
        ],
        updateRef: [
            "PATCH /repos/{owner}/{repo}/git/refs/{ref}"
        ]
    },
    gitignore: {
        getAllTemplates: [
            "GET /gitignore/templates"
        ],
        getTemplate: [
            "GET /gitignore/templates/{name}"
        ]
    },
    hostedCompute: {
        createNetworkConfigurationForOrg: [
            "POST /orgs/{org}/settings/network-configurations"
        ],
        deleteNetworkConfigurationFromOrg: [
            "DELETE /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ],
        getNetworkConfigurationForOrg: [
            "GET /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ],
        getNetworkSettingsForOrg: [
            "GET /orgs/{org}/settings/network-settings/{network_settings_id}"
        ],
        listNetworkConfigurationsForOrg: [
            "GET /orgs/{org}/settings/network-configurations"
        ],
        updateNetworkConfigurationForOrg: [
            "PATCH /orgs/{org}/settings/network-configurations/{network_configuration_id}"
        ]
    },
    interactions: {
        getRestrictionsForAuthenticatedUser: [
            "GET /user/interaction-limits"
        ],
        getRestrictionsForOrg: [
            "GET /orgs/{org}/interaction-limits"
        ],
        getRestrictionsForRepo: [
            "GET /repos/{owner}/{repo}/interaction-limits"
        ],
        getRestrictionsForYourPublicRepos: [
            "GET /user/interaction-limits",
            {},
            {
                renamed: [
                    "interactions",
                    "getRestrictionsForAuthenticatedUser"
                ]
            }
        ],
        removeRestrictionsForAuthenticatedUser: [
            "DELETE /user/interaction-limits"
        ],
        removeRestrictionsForOrg: [
            "DELETE /orgs/{org}/interaction-limits"
        ],
        removeRestrictionsForRepo: [
            "DELETE /repos/{owner}/{repo}/interaction-limits"
        ],
        removeRestrictionsForYourPublicRepos: [
            "DELETE /user/interaction-limits",
            {},
            {
                renamed: [
                    "interactions",
                    "removeRestrictionsForAuthenticatedUser"
                ]
            }
        ],
        setRestrictionsForAuthenticatedUser: [
            "PUT /user/interaction-limits"
        ],
        setRestrictionsForOrg: [
            "PUT /orgs/{org}/interaction-limits"
        ],
        setRestrictionsForRepo: [
            "PUT /repos/{owner}/{repo}/interaction-limits"
        ],
        setRestrictionsForYourPublicRepos: [
            "PUT /user/interaction-limits",
            {},
            {
                renamed: [
                    "interactions",
                    "setRestrictionsForAuthenticatedUser"
                ]
            }
        ]
    },
    issues: {
        addAssignees: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        addLabels: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        addSubIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        ],
        checkUserCanBeAssigned: [
            "GET /repos/{owner}/{repo}/assignees/{assignee}"
        ],
        checkUserCanBeAssignedToIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"
        ],
        create: [
            "POST /repos/{owner}/{repo}/issues"
        ],
        createComment: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        createLabel: [
            "POST /repos/{owner}/{repo}/labels"
        ],
        createMilestone: [
            "POST /repos/{owner}/{repo}/milestones"
        ],
        deleteComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        deleteLabel: [
            "DELETE /repos/{owner}/{repo}/labels/{name}"
        ],
        deleteMilestone: [
            "DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        get: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}"
        ],
        getComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        getEvent: [
            "GET /repos/{owner}/{repo}/issues/events/{event_id}"
        ],
        getLabel: [
            "GET /repos/{owner}/{repo}/labels/{name}"
        ],
        getMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}"
        ],
        list: [
            "GET /issues"
        ],
        listAssignees: [
            "GET /repos/{owner}/{repo}/assignees"
        ],
        listComments: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/comments"
        ],
        listCommentsForRepo: [
            "GET /repos/{owner}/{repo}/issues/comments"
        ],
        listEvents: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/events"
        ],
        listEventsForRepo: [
            "GET /repos/{owner}/{repo}/issues/events"
        ],
        listEventsForTimeline: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"
        ],
        listForAuthenticatedUser: [
            "GET /user/issues"
        ],
        listForOrg: [
            "GET /orgs/{org}/issues"
        ],
        listForRepo: [
            "GET /repos/{owner}/{repo}/issues"
        ],
        listLabelsForMilestone: [
            "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"
        ],
        listLabelsForRepo: [
            "GET /repos/{owner}/{repo}/labels"
        ],
        listLabelsOnIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        listMilestones: [
            "GET /repos/{owner}/{repo}/milestones"
        ],
        listSubIssues: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/sub_issues"
        ],
        lock: [
            "PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"
        ],
        removeAllLabels: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        removeAssignees: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"
        ],
        removeLabel: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"
        ],
        removeSubIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/sub_issue"
        ],
        reprioritizeSubIssue: [
            "PATCH /repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority"
        ],
        setLabels: [
            "PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"
        ],
        unlock: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"
        ],
        update: [
            "PATCH /repos/{owner}/{repo}/issues/{issue_number}"
        ],
        updateComment: [
            "PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"
        ],
        updateLabel: [
            "PATCH /repos/{owner}/{repo}/labels/{name}"
        ],
        updateMilestone: [
            "PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"
        ]
    },
    licenses: {
        get: [
            "GET /licenses/{license}"
        ],
        getAllCommonlyUsed: [
            "GET /licenses"
        ],
        getForRepo: [
            "GET /repos/{owner}/{repo}/license"
        ]
    },
    markdown: {
        render: [
            "POST /markdown"
        ],
        renderRaw: [
            "POST /markdown/raw",
            {
                headers: {
                    "content-type": "text/plain; charset=utf-8"
                }
            }
        ]
    },
    meta: {
        get: [
            "GET /meta"
        ],
        getAllVersions: [
            "GET /versions"
        ],
        getOctocat: [
            "GET /octocat"
        ],
        getZen: [
            "GET /zen"
        ],
        root: [
            "GET /"
        ]
    },
    migrations: {
        deleteArchiveForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/archive"
        ],
        deleteArchiveForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/archive"
        ],
        downloadArchiveForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/archive"
        ],
        getArchiveForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/archive"
        ],
        getStatusForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}"
        ],
        getStatusForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}"
        ],
        listForAuthenticatedUser: [
            "GET /user/migrations"
        ],
        listForOrg: [
            "GET /orgs/{org}/migrations"
        ],
        listReposForAuthenticatedUser: [
            "GET /user/migrations/{migration_id}/repositories"
        ],
        listReposForOrg: [
            "GET /orgs/{org}/migrations/{migration_id}/repositories"
        ],
        listReposForUser: [
            "GET /user/migrations/{migration_id}/repositories",
            {},
            {
                renamed: [
                    "migrations",
                    "listReposForAuthenticatedUser"
                ]
            }
        ],
        startForAuthenticatedUser: [
            "POST /user/migrations"
        ],
        startForOrg: [
            "POST /orgs/{org}/migrations"
        ],
        unlockRepoForAuthenticatedUser: [
            "DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"
        ],
        unlockRepoForOrg: [
            "DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"
        ]
    },
    oidc: {
        getOidcCustomSubTemplateForOrg: [
            "GET /orgs/{org}/actions/oidc/customization/sub"
        ],
        updateOidcCustomSubTemplateForOrg: [
            "PUT /orgs/{org}/actions/oidc/customization/sub"
        ]
    },
    orgs: {
        addSecurityManagerTeam: [
            "PUT /orgs/{org}/security-managers/teams/{team_slug}",
            {},
            {
                deprecated: "octokit.rest.orgs.addSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#add-a-security-manager-team"
            }
        ],
        assignTeamToOrgRole: [
            "PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        assignUserToOrgRole: [
            "PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        blockUser: [
            "PUT /orgs/{org}/blocks/{username}"
        ],
        cancelInvitation: [
            "DELETE /orgs/{org}/invitations/{invitation_id}"
        ],
        checkBlockedUser: [
            "GET /orgs/{org}/blocks/{username}"
        ],
        checkMembershipForUser: [
            "GET /orgs/{org}/members/{username}"
        ],
        checkPublicMembershipForUser: [
            "GET /orgs/{org}/public_members/{username}"
        ],
        convertMemberToOutsideCollaborator: [
            "PUT /orgs/{org}/outside_collaborators/{username}"
        ],
        createInvitation: [
            "POST /orgs/{org}/invitations"
        ],
        createIssueType: [
            "POST /orgs/{org}/issue-types"
        ],
        createOrUpdateCustomProperties: [
            "PATCH /orgs/{org}/properties/schema"
        ],
        createOrUpdateCustomPropertiesValuesForRepos: [
            "PATCH /orgs/{org}/properties/values"
        ],
        createOrUpdateCustomProperty: [
            "PUT /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        createWebhook: [
            "POST /orgs/{org}/hooks"
        ],
        delete: [
            "DELETE /orgs/{org}"
        ],
        deleteIssueType: [
            "DELETE /orgs/{org}/issue-types/{issue_type_id}"
        ],
        deleteWebhook: [
            "DELETE /orgs/{org}/hooks/{hook_id}"
        ],
        enableOrDisableSecurityProductOnAllOrgRepos: [
            "POST /orgs/{org}/{security_product}/{enablement}",
            {},
            {
                deprecated: "octokit.rest.orgs.enableOrDisableSecurityProductOnAllOrgRepos() is deprecated, see https://docs.github.com/rest/orgs/orgs#enable-or-disable-a-security-feature-for-an-organization"
            }
        ],
        get: [
            "GET /orgs/{org}"
        ],
        getAllCustomProperties: [
            "GET /orgs/{org}/properties/schema"
        ],
        getCustomProperty: [
            "GET /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        getMembershipForAuthenticatedUser: [
            "GET /user/memberships/orgs/{org}"
        ],
        getMembershipForUser: [
            "GET /orgs/{org}/memberships/{username}"
        ],
        getOrgRole: [
            "GET /orgs/{org}/organization-roles/{role_id}"
        ],
        getOrgRulesetHistory: [
            "GET /orgs/{org}/rulesets/{ruleset_id}/history"
        ],
        getOrgRulesetVersion: [
            "GET /orgs/{org}/rulesets/{ruleset_id}/history/{version_id}"
        ],
        getWebhook: [
            "GET /orgs/{org}/hooks/{hook_id}"
        ],
        getWebhookConfigForOrg: [
            "GET /orgs/{org}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        list: [
            "GET /organizations"
        ],
        listAppInstallations: [
            "GET /orgs/{org}/installations"
        ],
        listAttestations: [
            "GET /orgs/{org}/attestations/{subject_digest}"
        ],
        listBlockedUsers: [
            "GET /orgs/{org}/blocks"
        ],
        listCustomPropertiesValuesForRepos: [
            "GET /orgs/{org}/properties/values"
        ],
        listFailedInvitations: [
            "GET /orgs/{org}/failed_invitations"
        ],
        listForAuthenticatedUser: [
            "GET /user/orgs"
        ],
        listForUser: [
            "GET /users/{username}/orgs"
        ],
        listInvitationTeams: [
            "GET /orgs/{org}/invitations/{invitation_id}/teams"
        ],
        listIssueTypes: [
            "GET /orgs/{org}/issue-types"
        ],
        listMembers: [
            "GET /orgs/{org}/members"
        ],
        listMembershipsForAuthenticatedUser: [
            "GET /user/memberships/orgs"
        ],
        listOrgRoleTeams: [
            "GET /orgs/{org}/organization-roles/{role_id}/teams"
        ],
        listOrgRoleUsers: [
            "GET /orgs/{org}/organization-roles/{role_id}/users"
        ],
        listOrgRoles: [
            "GET /orgs/{org}/organization-roles"
        ],
        listOrganizationFineGrainedPermissions: [
            "GET /orgs/{org}/organization-fine-grained-permissions"
        ],
        listOutsideCollaborators: [
            "GET /orgs/{org}/outside_collaborators"
        ],
        listPatGrantRepositories: [
            "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"
        ],
        listPatGrantRequestRepositories: [
            "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"
        ],
        listPatGrantRequests: [
            "GET /orgs/{org}/personal-access-token-requests"
        ],
        listPatGrants: [
            "GET /orgs/{org}/personal-access-tokens"
        ],
        listPendingInvitations: [
            "GET /orgs/{org}/invitations"
        ],
        listPublicMembers: [
            "GET /orgs/{org}/public_members"
        ],
        listSecurityManagerTeams: [
            "GET /orgs/{org}/security-managers",
            {},
            {
                deprecated: "octokit.rest.orgs.listSecurityManagerTeams() is deprecated, see https://docs.github.com/rest/orgs/security-managers#list-security-manager-teams"
            }
        ],
        listWebhookDeliveries: [
            "GET /orgs/{org}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: [
            "GET /orgs/{org}/hooks"
        ],
        pingWebhook: [
            "POST /orgs/{org}/hooks/{hook_id}/pings"
        ],
        redeliverWebhookDelivery: [
            "POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeCustomProperty: [
            "DELETE /orgs/{org}/properties/schema/{custom_property_name}"
        ],
        removeMember: [
            "DELETE /orgs/{org}/members/{username}"
        ],
        removeMembershipForUser: [
            "DELETE /orgs/{org}/memberships/{username}"
        ],
        removeOutsideCollaborator: [
            "DELETE /orgs/{org}/outside_collaborators/{username}"
        ],
        removePublicMembershipForAuthenticatedUser: [
            "DELETE /orgs/{org}/public_members/{username}"
        ],
        removeSecurityManagerTeam: [
            "DELETE /orgs/{org}/security-managers/teams/{team_slug}",
            {},
            {
                deprecated: "octokit.rest.orgs.removeSecurityManagerTeam() is deprecated, see https://docs.github.com/rest/orgs/security-managers#remove-a-security-manager-team"
            }
        ],
        reviewPatGrantRequest: [
            "POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"
        ],
        reviewPatGrantRequestsInBulk: [
            "POST /orgs/{org}/personal-access-token-requests"
        ],
        revokeAllOrgRolesTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}"
        ],
        revokeAllOrgRolesUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}"
        ],
        revokeOrgRoleTeam: [
            "DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"
        ],
        revokeOrgRoleUser: [
            "DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"
        ],
        setMembershipForUser: [
            "PUT /orgs/{org}/memberships/{username}"
        ],
        setPublicMembershipForAuthenticatedUser: [
            "PUT /orgs/{org}/public_members/{username}"
        ],
        unblockUser: [
            "DELETE /orgs/{org}/blocks/{username}"
        ],
        update: [
            "PATCH /orgs/{org}"
        ],
        updateIssueType: [
            "PUT /orgs/{org}/issue-types/{issue_type_id}"
        ],
        updateMembershipForAuthenticatedUser: [
            "PATCH /user/memberships/orgs/{org}"
        ],
        updatePatAccess: [
            "POST /orgs/{org}/personal-access-tokens/{pat_id}"
        ],
        updatePatAccesses: [
            "POST /orgs/{org}/personal-access-tokens"
        ],
        updateWebhook: [
            "PATCH /orgs/{org}/hooks/{hook_id}"
        ],
        updateWebhookConfigForOrg: [
            "PATCH /orgs/{org}/hooks/{hook_id}/config"
        ]
    },
    packages: {
        deletePackageForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}"
        ],
        deletePackageForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        deletePackageForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}"
        ],
        deletePackageVersionForAuthenticatedUser: [
            "DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForOrg: [
            "DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        deletePackageVersionForUser: [
            "DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
            {},
            {
                renamed: [
                    "packages",
                    "getAllPackageVersionsForPackageOwnedByOrg"
                ]
            }
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions",
            {},
            {
                renamed: [
                    "packages",
                    "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"
                ]
            }
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByOrg: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions"
        ],
        getAllPackageVersionsForPackageOwnedByUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions"
        ],
        getPackageForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}"
        ],
        getPackageForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}"
        ],
        getPackageForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}"
        ],
        getPackageVersionForAuthenticatedUser: [
            "GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForOrganization: [
            "GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        getPackageVersionForUser: [
            "GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"
        ],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: [
            "GET /user/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForOrganization: [
            "GET /orgs/{org}/docker/conflicts"
        ],
        listDockerMigrationConflictingPackagesForUser: [
            "GET /users/{username}/docker/conflicts"
        ],
        listPackagesForAuthenticatedUser: [
            "GET /user/packages"
        ],
        listPackagesForOrganization: [
            "GET /orgs/{org}/packages"
        ],
        listPackagesForUser: [
            "GET /users/{username}/packages"
        ],
        restorePackageForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"
        ],
        restorePackageVersionForAuthenticatedUser: [
            "POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForOrg: [
            "POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ],
        restorePackageVersionForUser: [
            "POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"
        ]
    },
    privateRegistries: {
        createOrgPrivateRegistry: [
            "POST /orgs/{org}/private-registries"
        ],
        deleteOrgPrivateRegistry: [
            "DELETE /orgs/{org}/private-registries/{secret_name}"
        ],
        getOrgPrivateRegistry: [
            "GET /orgs/{org}/private-registries/{secret_name}"
        ],
        getOrgPublicKey: [
            "GET /orgs/{org}/private-registries/public-key"
        ],
        listOrgPrivateRegistries: [
            "GET /orgs/{org}/private-registries"
        ],
        updateOrgPrivateRegistry: [
            "PATCH /orgs/{org}/private-registries/{secret_name}"
        ]
    },
    pulls: {
        checkIfMerged: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"
        ],
        create: [
            "POST /repos/{owner}/{repo}/pulls"
        ],
        createReplyForReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"
        ],
        createReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        ],
        createReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        deletePendingReview: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        deleteReviewComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        dismissReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"
        ],
        get: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}"
        ],
        getReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        getReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ],
        list: [
            "GET /repos/{owner}/{repo}/pulls"
        ],
        listCommentsForReview: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"
        ],
        listCommits: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"
        ],
        listFiles: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/files"
        ],
        listRequestedReviewers: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        listReviewComments: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"
        ],
        listReviewCommentsForRepo: [
            "GET /repos/{owner}/{repo}/pulls/comments"
        ],
        listReviews: [
            "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"
        ],
        merge: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"
        ],
        removeRequestedReviewers: [
            "DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        requestReviewers: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"
        ],
        submitReview: [
            "POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"
        ],
        update: [
            "PATCH /repos/{owner}/{repo}/pulls/{pull_number}"
        ],
        updateBranch: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"
        ],
        updateReview: [
            "PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"
        ],
        updateReviewComment: [
            "PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"
        ]
    },
    rateLimit: {
        get: [
            "GET /rate_limit"
        ]
    },
    reactions: {
        createForCommitComment: [
            "POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        createForIssue: [
            "POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        createForIssueComment: [
            "POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        createForPullRequestReviewComment: [
            "POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        createForRelease: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        createForTeamDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        createForTeamDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ],
        deleteForCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForIssue: [
            "DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"
        ],
        deleteForIssueComment: [
            "DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForPullRequestComment: [
            "DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"
        ],
        deleteForRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussion: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"
        ],
        deleteForTeamDiscussionComment: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"
        ],
        listForCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"
        ],
        listForIssue: [
            "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"
        ],
        listForIssueComment: [
            "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"
        ],
        listForPullRequestReviewComment: [
            "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"
        ],
        listForRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/reactions"
        ],
        listForTeamDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"
        ],
        listForTeamDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"
        ]
    },
    repos: {
        acceptInvitation: [
            "PATCH /user/repository_invitations/{invitation_id}",
            {},
            {
                renamed: [
                    "repos",
                    "acceptInvitationForAuthenticatedUser"
                ]
            }
        ],
        acceptInvitationForAuthenticatedUser: [
            "PATCH /user/repository_invitations/{invitation_id}"
        ],
        addAppAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            {
                mapToData: "apps"
            }
        ],
        addCollaborator: [
            "PUT /repos/{owner}/{repo}/collaborators/{username}"
        ],
        addStatusCheckContexts: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            {
                mapToData: "contexts"
            }
        ],
        addTeamAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            {
                mapToData: "teams"
            }
        ],
        addUserAccessRestrictions: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            {
                mapToData: "users"
            }
        ],
        cancelPagesDeployment: [
            "POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"
        ],
        checkAutomatedSecurityFixes: [
            "GET /repos/{owner}/{repo}/automated-security-fixes"
        ],
        checkCollaborator: [
            "GET /repos/{owner}/{repo}/collaborators/{username}"
        ],
        checkPrivateVulnerabilityReporting: [
            "GET /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        checkVulnerabilityAlerts: [
            "GET /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        codeownersErrors: [
            "GET /repos/{owner}/{repo}/codeowners/errors"
        ],
        compareCommits: [
            "GET /repos/{owner}/{repo}/compare/{base}...{head}"
        ],
        compareCommitsWithBasehead: [
            "GET /repos/{owner}/{repo}/compare/{basehead}"
        ],
        createAttestation: [
            "POST /repos/{owner}/{repo}/attestations"
        ],
        createAutolink: [
            "POST /repos/{owner}/{repo}/autolinks"
        ],
        createCommitComment: [
            "POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        createCommitSignatureProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        createCommitStatus: [
            "POST /repos/{owner}/{repo}/statuses/{sha}"
        ],
        createDeployKey: [
            "POST /repos/{owner}/{repo}/keys"
        ],
        createDeployment: [
            "POST /repos/{owner}/{repo}/deployments"
        ],
        createDeploymentBranchPolicy: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        createDeploymentProtectionRule: [
            "POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        createDeploymentStatus: [
            "POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        createDispatchEvent: [
            "POST /repos/{owner}/{repo}/dispatches"
        ],
        createForAuthenticatedUser: [
            "POST /user/repos"
        ],
        createFork: [
            "POST /repos/{owner}/{repo}/forks"
        ],
        createInOrg: [
            "POST /orgs/{org}/repos"
        ],
        createOrUpdateCustomPropertiesValues: [
            "PATCH /repos/{owner}/{repo}/properties/values"
        ],
        createOrUpdateEnvironment: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        createOrUpdateFileContents: [
            "PUT /repos/{owner}/{repo}/contents/{path}"
        ],
        createOrgRuleset: [
            "POST /orgs/{org}/rulesets"
        ],
        createPagesDeployment: [
            "POST /repos/{owner}/{repo}/pages/deployments"
        ],
        createPagesSite: [
            "POST /repos/{owner}/{repo}/pages"
        ],
        createRelease: [
            "POST /repos/{owner}/{repo}/releases"
        ],
        createRepoRuleset: [
            "POST /repos/{owner}/{repo}/rulesets"
        ],
        createUsingTemplate: [
            "POST /repos/{template_owner}/{template_repo}/generate"
        ],
        createWebhook: [
            "POST /repos/{owner}/{repo}/hooks"
        ],
        declineInvitation: [
            "DELETE /user/repository_invitations/{invitation_id}",
            {},
            {
                renamed: [
                    "repos",
                    "declineInvitationForAuthenticatedUser"
                ]
            }
        ],
        declineInvitationForAuthenticatedUser: [
            "DELETE /user/repository_invitations/{invitation_id}"
        ],
        delete: [
            "DELETE /repos/{owner}/{repo}"
        ],
        deleteAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        deleteAdminBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        deleteAnEnvironment: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        deleteAutolink: [
            "DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"
        ],
        deleteBranchProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        deleteCommitComment: [
            "DELETE /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        deleteCommitSignatureProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        deleteDeployKey: [
            "DELETE /repos/{owner}/{repo}/keys/{key_id}"
        ],
        deleteDeployment: [
            "DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        deleteDeploymentBranchPolicy: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        deleteFile: [
            "DELETE /repos/{owner}/{repo}/contents/{path}"
        ],
        deleteInvitation: [
            "DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        deleteOrgRuleset: [
            "DELETE /orgs/{org}/rulesets/{ruleset_id}"
        ],
        deletePagesSite: [
            "DELETE /repos/{owner}/{repo}/pages"
        ],
        deletePullRequestReviewProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        deleteRelease: [
            "DELETE /repos/{owner}/{repo}/releases/{release_id}"
        ],
        deleteReleaseAsset: [
            "DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        deleteRepoRuleset: [
            "DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        deleteWebhook: [
            "DELETE /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        disableAutomatedSecurityFixes: [
            "DELETE /repos/{owner}/{repo}/automated-security-fixes"
        ],
        disableDeploymentProtectionRule: [
            "DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        disablePrivateVulnerabilityReporting: [
            "DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        disableVulnerabilityAlerts: [
            "DELETE /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        downloadArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}",
            {},
            {
                renamed: [
                    "repos",
                    "downloadZipballArchive"
                ]
            }
        ],
        downloadTarballArchive: [
            "GET /repos/{owner}/{repo}/tarball/{ref}"
        ],
        downloadZipballArchive: [
            "GET /repos/{owner}/{repo}/zipball/{ref}"
        ],
        enableAutomatedSecurityFixes: [
            "PUT /repos/{owner}/{repo}/automated-security-fixes"
        ],
        enablePrivateVulnerabilityReporting: [
            "PUT /repos/{owner}/{repo}/private-vulnerability-reporting"
        ],
        enableVulnerabilityAlerts: [
            "PUT /repos/{owner}/{repo}/vulnerability-alerts"
        ],
        generateReleaseNotes: [
            "POST /repos/{owner}/{repo}/releases/generate-notes"
        ],
        get: [
            "GET /repos/{owner}/{repo}"
        ],
        getAccessRestrictions: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"
        ],
        getAdminBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        getAllDeploymentProtectionRules: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"
        ],
        getAllEnvironments: [
            "GET /repos/{owner}/{repo}/environments"
        ],
        getAllStatusCheckContexts: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"
        ],
        getAllTopics: [
            "GET /repos/{owner}/{repo}/topics"
        ],
        getAppsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"
        ],
        getAutolink: [
            "GET /repos/{owner}/{repo}/autolinks/{autolink_id}"
        ],
        getBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}"
        ],
        getBranchProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        getBranchRules: [
            "GET /repos/{owner}/{repo}/rules/branches/{branch}"
        ],
        getClones: [
            "GET /repos/{owner}/{repo}/traffic/clones"
        ],
        getCodeFrequencyStats: [
            "GET /repos/{owner}/{repo}/stats/code_frequency"
        ],
        getCollaboratorPermissionLevel: [
            "GET /repos/{owner}/{repo}/collaborators/{username}/permission"
        ],
        getCombinedStatusForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/status"
        ],
        getCommit: [
            "GET /repos/{owner}/{repo}/commits/{ref}"
        ],
        getCommitActivityStats: [
            "GET /repos/{owner}/{repo}/stats/commit_activity"
        ],
        getCommitComment: [
            "GET /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        getCommitSignatureProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"
        ],
        getCommunityProfileMetrics: [
            "GET /repos/{owner}/{repo}/community/profile"
        ],
        getContent: [
            "GET /repos/{owner}/{repo}/contents/{path}"
        ],
        getContributorsStats: [
            "GET /repos/{owner}/{repo}/stats/contributors"
        ],
        getCustomDeploymentProtectionRule: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"
        ],
        getCustomPropertiesValues: [
            "GET /repos/{owner}/{repo}/properties/values"
        ],
        getDeployKey: [
            "GET /repos/{owner}/{repo}/keys/{key_id}"
        ],
        getDeployment: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}"
        ],
        getDeploymentBranchPolicy: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        getDeploymentStatus: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"
        ],
        getEnvironment: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}"
        ],
        getLatestPagesBuild: [
            "GET /repos/{owner}/{repo}/pages/builds/latest"
        ],
        getLatestRelease: [
            "GET /repos/{owner}/{repo}/releases/latest"
        ],
        getOrgRuleSuite: [
            "GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getOrgRuleSuites: [
            "GET /orgs/{org}/rulesets/rule-suites"
        ],
        getOrgRuleset: [
            "GET /orgs/{org}/rulesets/{ruleset_id}"
        ],
        getOrgRulesets: [
            "GET /orgs/{org}/rulesets"
        ],
        getPages: [
            "GET /repos/{owner}/{repo}/pages"
        ],
        getPagesBuild: [
            "GET /repos/{owner}/{repo}/pages/builds/{build_id}"
        ],
        getPagesDeployment: [
            "GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"
        ],
        getPagesHealthCheck: [
            "GET /repos/{owner}/{repo}/pages/health"
        ],
        getParticipationStats: [
            "GET /repos/{owner}/{repo}/stats/participation"
        ],
        getPullRequestReviewProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        getPunchCardStats: [
            "GET /repos/{owner}/{repo}/stats/punch_card"
        ],
        getReadme: [
            "GET /repos/{owner}/{repo}/readme"
        ],
        getReadmeInDirectory: [
            "GET /repos/{owner}/{repo}/readme/{dir}"
        ],
        getRelease: [
            "GET /repos/{owner}/{repo}/releases/{release_id}"
        ],
        getReleaseAsset: [
            "GET /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        getReleaseByTag: [
            "GET /repos/{owner}/{repo}/releases/tags/{tag}"
        ],
        getRepoRuleSuite: [
            "GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"
        ],
        getRepoRuleSuites: [
            "GET /repos/{owner}/{repo}/rulesets/rule-suites"
        ],
        getRepoRuleset: [
            "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        getRepoRulesetHistory: [
            "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history"
        ],
        getRepoRulesetVersion: [
            "GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}"
        ],
        getRepoRulesets: [
            "GET /repos/{owner}/{repo}/rulesets"
        ],
        getStatusChecksProtection: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        getTeamsWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"
        ],
        getTopPaths: [
            "GET /repos/{owner}/{repo}/traffic/popular/paths"
        ],
        getTopReferrers: [
            "GET /repos/{owner}/{repo}/traffic/popular/referrers"
        ],
        getUsersWithAccessToProtectedBranch: [
            "GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"
        ],
        getViews: [
            "GET /repos/{owner}/{repo}/traffic/views"
        ],
        getWebhook: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        getWebhookConfigForRepo: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        getWebhookDelivery: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"
        ],
        listActivities: [
            "GET /repos/{owner}/{repo}/activity"
        ],
        listAttestations: [
            "GET /repos/{owner}/{repo}/attestations/{subject_digest}"
        ],
        listAutolinks: [
            "GET /repos/{owner}/{repo}/autolinks"
        ],
        listBranches: [
            "GET /repos/{owner}/{repo}/branches"
        ],
        listBranchesForHeadCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"
        ],
        listCollaborators: [
            "GET /repos/{owner}/{repo}/collaborators"
        ],
        listCommentsForCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"
        ],
        listCommitCommentsForRepo: [
            "GET /repos/{owner}/{repo}/comments"
        ],
        listCommitStatusesForRef: [
            "GET /repos/{owner}/{repo}/commits/{ref}/statuses"
        ],
        listCommits: [
            "GET /repos/{owner}/{repo}/commits"
        ],
        listContributors: [
            "GET /repos/{owner}/{repo}/contributors"
        ],
        listCustomDeploymentRuleIntegrations: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"
        ],
        listDeployKeys: [
            "GET /repos/{owner}/{repo}/keys"
        ],
        listDeploymentBranchPolicies: [
            "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"
        ],
        listDeploymentStatuses: [
            "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"
        ],
        listDeployments: [
            "GET /repos/{owner}/{repo}/deployments"
        ],
        listForAuthenticatedUser: [
            "GET /user/repos"
        ],
        listForOrg: [
            "GET /orgs/{org}/repos"
        ],
        listForUser: [
            "GET /users/{username}/repos"
        ],
        listForks: [
            "GET /repos/{owner}/{repo}/forks"
        ],
        listInvitations: [
            "GET /repos/{owner}/{repo}/invitations"
        ],
        listInvitationsForAuthenticatedUser: [
            "GET /user/repository_invitations"
        ],
        listLanguages: [
            "GET /repos/{owner}/{repo}/languages"
        ],
        listPagesBuilds: [
            "GET /repos/{owner}/{repo}/pages/builds"
        ],
        listPublic: [
            "GET /repositories"
        ],
        listPullRequestsAssociatedWithCommit: [
            "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"
        ],
        listReleaseAssets: [
            "GET /repos/{owner}/{repo}/releases/{release_id}/assets"
        ],
        listReleases: [
            "GET /repos/{owner}/{repo}/releases"
        ],
        listTags: [
            "GET /repos/{owner}/{repo}/tags"
        ],
        listTeams: [
            "GET /repos/{owner}/{repo}/teams"
        ],
        listWebhookDeliveries: [
            "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"
        ],
        listWebhooks: [
            "GET /repos/{owner}/{repo}/hooks"
        ],
        merge: [
            "POST /repos/{owner}/{repo}/merges"
        ],
        mergeUpstream: [
            "POST /repos/{owner}/{repo}/merge-upstream"
        ],
        pingWebhook: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"
        ],
        redeliverWebhookDelivery: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"
        ],
        removeAppAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            {
                mapToData: "apps"
            }
        ],
        removeCollaborator: [
            "DELETE /repos/{owner}/{repo}/collaborators/{username}"
        ],
        removeStatusCheckContexts: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            {
                mapToData: "contexts"
            }
        ],
        removeStatusCheckProtection: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        removeTeamAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            {
                mapToData: "teams"
            }
        ],
        removeUserAccessRestrictions: [
            "DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            {
                mapToData: "users"
            }
        ],
        renameBranch: [
            "POST /repos/{owner}/{repo}/branches/{branch}/rename"
        ],
        replaceAllTopics: [
            "PUT /repos/{owner}/{repo}/topics"
        ],
        requestPagesBuild: [
            "POST /repos/{owner}/{repo}/pages/builds"
        ],
        setAdminBranchProtection: [
            "POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"
        ],
        setAppAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",
            {},
            {
                mapToData: "apps"
            }
        ],
        setStatusCheckContexts: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",
            {},
            {
                mapToData: "contexts"
            }
        ],
        setTeamAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",
            {},
            {
                mapToData: "teams"
            }
        ],
        setUserAccessRestrictions: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",
            {},
            {
                mapToData: "users"
            }
        ],
        testPushWebhook: [
            "POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"
        ],
        transfer: [
            "POST /repos/{owner}/{repo}/transfer"
        ],
        update: [
            "PATCH /repos/{owner}/{repo}"
        ],
        updateBranchProtection: [
            "PUT /repos/{owner}/{repo}/branches/{branch}/protection"
        ],
        updateCommitComment: [
            "PATCH /repos/{owner}/{repo}/comments/{comment_id}"
        ],
        updateDeploymentBranchPolicy: [
            "PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"
        ],
        updateInformationAboutPagesSite: [
            "PUT /repos/{owner}/{repo}/pages"
        ],
        updateInvitation: [
            "PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"
        ],
        updateOrgRuleset: [
            "PUT /orgs/{org}/rulesets/{ruleset_id}"
        ],
        updatePullRequestReviewProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"
        ],
        updateRelease: [
            "PATCH /repos/{owner}/{repo}/releases/{release_id}"
        ],
        updateReleaseAsset: [
            "PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"
        ],
        updateRepoRuleset: [
            "PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"
        ],
        updateStatusCheckPotection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
            {},
            {
                renamed: [
                    "repos",
                    "updateStatusCheckProtection"
                ]
            }
        ],
        updateStatusCheckProtection: [
            "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"
        ],
        updateWebhook: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}"
        ],
        updateWebhookConfigForRepo: [
            "PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"
        ],
        uploadReleaseAsset: [
            "POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",
            {
                baseUrl: "https://uploads.github.com"
            }
        ]
    },
    search: {
        code: [
            "GET /search/code"
        ],
        commits: [
            "GET /search/commits"
        ],
        issuesAndPullRequests: [
            "GET /search/issues",
            {},
            {
                deprecated: "octokit.rest.search.issuesAndPullRequests() is deprecated, see https://docs.github.com/rest/search/search#search-issues-and-pull-requests"
            }
        ],
        labels: [
            "GET /search/labels"
        ],
        repos: [
            "GET /search/repositories"
        ],
        topics: [
            "GET /search/topics"
        ],
        users: [
            "GET /search/users"
        ]
    },
    secretScanning: {
        createPushProtectionBypass: [
            "POST /repos/{owner}/{repo}/secret-scanning/push-protection-bypasses"
        ],
        getAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ],
        getScanHistory: [
            "GET /repos/{owner}/{repo}/secret-scanning/scan-history"
        ],
        listAlertsForEnterprise: [
            "GET /enterprises/{enterprise}/secret-scanning/alerts"
        ],
        listAlertsForOrg: [
            "GET /orgs/{org}/secret-scanning/alerts"
        ],
        listAlertsForRepo: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts"
        ],
        listLocationsForAlert: [
            "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"
        ],
        updateAlert: [
            "PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"
        ]
    },
    securityAdvisories: {
        createFork: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"
        ],
        createPrivateVulnerabilityReport: [
            "POST /repos/{owner}/{repo}/security-advisories/reports"
        ],
        createRepositoryAdvisory: [
            "POST /repos/{owner}/{repo}/security-advisories"
        ],
        createRepositoryAdvisoryCveRequest: [
            "POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"
        ],
        getGlobalAdvisory: [
            "GET /advisories/{ghsa_id}"
        ],
        getRepositoryAdvisory: [
            "GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ],
        listGlobalAdvisories: [
            "GET /advisories"
        ],
        listOrgRepositoryAdvisories: [
            "GET /orgs/{org}/security-advisories"
        ],
        listRepositoryAdvisories: [
            "GET /repos/{owner}/{repo}/security-advisories"
        ],
        updateRepositoryAdvisory: [
            "PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"
        ]
    },
    teams: {
        addOrUpdateMembershipForUserInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        addOrUpdateRepoPermissionsInOrg: [
            "PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        checkPermissionsForRepoInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        create: [
            "POST /orgs/{org}/teams"
        ],
        createDiscussionCommentInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        createDiscussionInOrg: [
            "POST /orgs/{org}/teams/{team_slug}/discussions"
        ],
        deleteDiscussionCommentInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        deleteDiscussionInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        deleteInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}"
        ],
        getByName: [
            "GET /orgs/{org}/teams/{team_slug}"
        ],
        getDiscussionCommentInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        getDiscussionInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        getMembershipForUserInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        list: [
            "GET /orgs/{org}/teams"
        ],
        listChildInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/teams"
        ],
        listDiscussionCommentsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"
        ],
        listDiscussionsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/discussions"
        ],
        listForAuthenticatedUser: [
            "GET /user/teams"
        ],
        listMembersInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/members"
        ],
        listPendingInvitationsInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/invitations"
        ],
        listReposInOrg: [
            "GET /orgs/{org}/teams/{team_slug}/repos"
        ],
        removeMembershipForUserInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"
        ],
        removeRepoInOrg: [
            "DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"
        ],
        updateDiscussionCommentInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"
        ],
        updateDiscussionInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"
        ],
        updateInOrg: [
            "PATCH /orgs/{org}/teams/{team_slug}"
        ]
    },
    users: {
        addEmailForAuthenticated: [
            "POST /user/emails",
            {},
            {
                renamed: [
                    "users",
                    "addEmailForAuthenticatedUser"
                ]
            }
        ],
        addEmailForAuthenticatedUser: [
            "POST /user/emails"
        ],
        addSocialAccountForAuthenticatedUser: [
            "POST /user/social_accounts"
        ],
        block: [
            "PUT /user/blocks/{username}"
        ],
        checkBlocked: [
            "GET /user/blocks/{username}"
        ],
        checkFollowingForUser: [
            "GET /users/{username}/following/{target_user}"
        ],
        checkPersonIsFollowedByAuthenticated: [
            "GET /user/following/{username}"
        ],
        createGpgKeyForAuthenticated: [
            "POST /user/gpg_keys",
            {},
            {
                renamed: [
                    "users",
                    "createGpgKeyForAuthenticatedUser"
                ]
            }
        ],
        createGpgKeyForAuthenticatedUser: [
            "POST /user/gpg_keys"
        ],
        createPublicSshKeyForAuthenticated: [
            "POST /user/keys",
            {},
            {
                renamed: [
                    "users",
                    "createPublicSshKeyForAuthenticatedUser"
                ]
            }
        ],
        createPublicSshKeyForAuthenticatedUser: [
            "POST /user/keys"
        ],
        createSshSigningKeyForAuthenticatedUser: [
            "POST /user/ssh_signing_keys"
        ],
        deleteEmailForAuthenticated: [
            "DELETE /user/emails",
            {},
            {
                renamed: [
                    "users",
                    "deleteEmailForAuthenticatedUser"
                ]
            }
        ],
        deleteEmailForAuthenticatedUser: [
            "DELETE /user/emails"
        ],
        deleteGpgKeyForAuthenticated: [
            "DELETE /user/gpg_keys/{gpg_key_id}",
            {},
            {
                renamed: [
                    "users",
                    "deleteGpgKeyForAuthenticatedUser"
                ]
            }
        ],
        deleteGpgKeyForAuthenticatedUser: [
            "DELETE /user/gpg_keys/{gpg_key_id}"
        ],
        deletePublicSshKeyForAuthenticated: [
            "DELETE /user/keys/{key_id}",
            {},
            {
                renamed: [
                    "users",
                    "deletePublicSshKeyForAuthenticatedUser"
                ]
            }
        ],
        deletePublicSshKeyForAuthenticatedUser: [
            "DELETE /user/keys/{key_id}"
        ],
        deleteSocialAccountForAuthenticatedUser: [
            "DELETE /user/social_accounts"
        ],
        deleteSshSigningKeyForAuthenticatedUser: [
            "DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        follow: [
            "PUT /user/following/{username}"
        ],
        getAuthenticated: [
            "GET /user"
        ],
        getById: [
            "GET /user/{account_id}"
        ],
        getByUsername: [
            "GET /users/{username}"
        ],
        getContextForUser: [
            "GET /users/{username}/hovercard"
        ],
        getGpgKeyForAuthenticated: [
            "GET /user/gpg_keys/{gpg_key_id}",
            {},
            {
                renamed: [
                    "users",
                    "getGpgKeyForAuthenticatedUser"
                ]
            }
        ],
        getGpgKeyForAuthenticatedUser: [
            "GET /user/gpg_keys/{gpg_key_id}"
        ],
        getPublicSshKeyForAuthenticated: [
            "GET /user/keys/{key_id}",
            {},
            {
                renamed: [
                    "users",
                    "getPublicSshKeyForAuthenticatedUser"
                ]
            }
        ],
        getPublicSshKeyForAuthenticatedUser: [
            "GET /user/keys/{key_id}"
        ],
        getSshSigningKeyForAuthenticatedUser: [
            "GET /user/ssh_signing_keys/{ssh_signing_key_id}"
        ],
        list: [
            "GET /users"
        ],
        listAttestations: [
            "GET /users/{username}/attestations/{subject_digest}"
        ],
        listBlockedByAuthenticated: [
            "GET /user/blocks",
            {},
            {
                renamed: [
                    "users",
                    "listBlockedByAuthenticatedUser"
                ]
            }
        ],
        listBlockedByAuthenticatedUser: [
            "GET /user/blocks"
        ],
        listEmailsForAuthenticated: [
            "GET /user/emails",
            {},
            {
                renamed: [
                    "users",
                    "listEmailsForAuthenticatedUser"
                ]
            }
        ],
        listEmailsForAuthenticatedUser: [
            "GET /user/emails"
        ],
        listFollowedByAuthenticated: [
            "GET /user/following",
            {},
            {
                renamed: [
                    "users",
                    "listFollowedByAuthenticatedUser"
                ]
            }
        ],
        listFollowedByAuthenticatedUser: [
            "GET /user/following"
        ],
        listFollowersForAuthenticatedUser: [
            "GET /user/followers"
        ],
        listFollowersForUser: [
            "GET /users/{username}/followers"
        ],
        listFollowingForUser: [
            "GET /users/{username}/following"
        ],
        listGpgKeysForAuthenticated: [
            "GET /user/gpg_keys",
            {},
            {
                renamed: [
                    "users",
                    "listGpgKeysForAuthenticatedUser"
                ]
            }
        ],
        listGpgKeysForAuthenticatedUser: [
            "GET /user/gpg_keys"
        ],
        listGpgKeysForUser: [
            "GET /users/{username}/gpg_keys"
        ],
        listPublicEmailsForAuthenticated: [
            "GET /user/public_emails",
            {},
            {
                renamed: [
                    "users",
                    "listPublicEmailsForAuthenticatedUser"
                ]
            }
        ],
        listPublicEmailsForAuthenticatedUser: [
            "GET /user/public_emails"
        ],
        listPublicKeysForUser: [
            "GET /users/{username}/keys"
        ],
        listPublicSshKeysForAuthenticated: [
            "GET /user/keys",
            {},
            {
                renamed: [
                    "users",
                    "listPublicSshKeysForAuthenticatedUser"
                ]
            }
        ],
        listPublicSshKeysForAuthenticatedUser: [
            "GET /user/keys"
        ],
        listSocialAccountsForAuthenticatedUser: [
            "GET /user/social_accounts"
        ],
        listSocialAccountsForUser: [
            "GET /users/{username}/social_accounts"
        ],
        listSshSigningKeysForAuthenticatedUser: [
            "GET /user/ssh_signing_keys"
        ],
        listSshSigningKeysForUser: [
            "GET /users/{username}/ssh_signing_keys"
        ],
        setPrimaryEmailVisibilityForAuthenticated: [
            "PATCH /user/email/visibility",
            {},
            {
                renamed: [
                    "users",
                    "setPrimaryEmailVisibilityForAuthenticatedUser"
                ]
            }
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: [
            "PATCH /user/email/visibility"
        ],
        unblock: [
            "DELETE /user/blocks/{username}"
        ],
        unfollow: [
            "DELETE /user/following/{username}"
        ],
        updateAuthenticated: [
            "PATCH /user"
        ]
    }
};
var endpoints_default = Endpoints;
;
 //# sourceMappingURL=endpoints.js.map
}}),
"[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "endpointsToMethods": (()=>endpointsToMethods)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$generated$2f$endpoints$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/generated/endpoints.js [app-client] (ecmascript)");
;
const endpointMethodsMap = /* @__PURE__ */ new Map();
for (const [scope, endpoints] of Object.entries(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$generated$2f$endpoints$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])){
    for (const [methodName, endpoint] of Object.entries(endpoints)){
        const [route, defaults, decorations] = endpoint;
        const [method, url] = route.split(/ /);
        const endpointDefaults = Object.assign({
            method,
            url
        }, defaults);
        if (!endpointMethodsMap.has(scope)) {
            endpointMethodsMap.set(scope, /* @__PURE__ */ new Map());
        }
        endpointMethodsMap.get(scope).set(methodName, {
            scope,
            methodName,
            endpointDefaults,
            decorations
        });
    }
}
const handler = {
    has ({ scope }, methodName) {
        return endpointMethodsMap.get(scope).has(methodName);
    },
    getOwnPropertyDescriptor (target, methodName) {
        return {
            value: this.get(target, methodName),
            // ensures method is in the cache
            configurable: true,
            writable: true,
            enumerable: true
        };
    },
    defineProperty (target, methodName, descriptor) {
        Object.defineProperty(target.cache, methodName, descriptor);
        return true;
    },
    deleteProperty (target, methodName) {
        delete target.cache[methodName];
        return true;
    },
    ownKeys ({ scope }) {
        return [
            ...endpointMethodsMap.get(scope).keys()
        ];
    },
    set (target, methodName, value) {
        return target.cache[methodName] = value;
    },
    get ({ octokit, scope, cache }, methodName) {
        if (cache[methodName]) {
            return cache[methodName];
        }
        const method = endpointMethodsMap.get(scope).get(methodName);
        if (!method) {
            return void 0;
        }
        const { endpointDefaults, decorations } = method;
        if (decorations) {
            cache[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        } else {
            cache[methodName] = octokit.request.defaults(endpointDefaults);
        }
        return cache[methodName];
    }
};
function endpointsToMethods(octokit) {
    const newMethods = {};
    for (const scope of endpointMethodsMap.keys()){
        newMethods[scope] = new Proxy({
            octokit,
            scope,
            cache: {}
        }, handler);
    }
    return newMethods;
}
function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    function withDecorations(...args) {
        let options = requestWithDefaults.endpoint.merge(...args);
        if (decorations.mapToData) {
            options = Object.assign({}, options, {
                data: options[decorations.mapToData],
                [decorations.mapToData]: void 0
            });
            return requestWithDefaults(options);
        }
        if (decorations.renamed) {
            const [newScope, newMethodName] = decorations.renamed;
            octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
        }
        if (decorations.deprecated) {
            octokit.log.warn(decorations.deprecated);
        }
        if (decorations.renamedParameters) {
            const options2 = requestWithDefaults.endpoint.merge(...args);
            for (const [name, alias] of Object.entries(decorations.renamedParameters)){
                if (name in options2) {
                    octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
                    if (!(alias in options2)) {
                        options2[alias] = options2[name];
                    }
                    delete options2[name];
                }
            }
            return requestWithDefaults(options2);
        }
        return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
}
;
 //# sourceMappingURL=endpoints-to-methods.js.map
}}),
"[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "legacyRestEndpointMethods": (()=>legacyRestEndpointMethods),
    "restEndpointMethods": (()=>restEndpointMethods)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/version.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$endpoints$2d$to$2d$methods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/endpoints-to-methods.js [app-client] (ecmascript)");
;
;
function restEndpointMethods(octokit) {
    const api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$endpoints$2d$to$2d$methods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endpointsToMethods"])(octokit);
    return {
        rest: api
    };
}
restEndpointMethods.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"];
function legacyRestEndpointMethods(octokit) {
    const api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$endpoints$2d$to$2d$methods$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["endpointsToMethods"])(octokit);
    return {
        ...api,
        rest: api
    };
}
legacyRestEndpointMethods.VERSION = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$version$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["VERSION"];
;
 //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/bottleneck/light.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
  * This file contains the Bottleneck library (MIT), compiled to ES2017, and without Clustering support.
  * https://github.com/SGrondin/bottleneck
  */ (function(global1, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : ("TURBOPACK unreachable", undefined);
})(this, function() {
    'use strict';
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function getCjsExportFromNamespace(n) {
        return n && n['default'] || n;
    }
    var load = function(received, defaults, onto = {}) {
        var k, ref, v;
        for(k in defaults){
            v = defaults[k];
            onto[k] = (ref = received[k]) != null ? ref : v;
        }
        return onto;
    };
    var overwrite = function(received, defaults, onto = {}) {
        var k, v;
        for(k in received){
            v = received[k];
            if (defaults[k] !== void 0) {
                onto[k] = v;
            }
        }
        return onto;
    };
    var parser = {
        load: load,
        overwrite: overwrite
    };
    var DLList;
    DLList = class DLList {
        constructor(incr, decr){
            this.incr = incr;
            this.decr = decr;
            this._first = null;
            this._last = null;
            this.length = 0;
        }
        push(value) {
            var node;
            this.length++;
            if (typeof this.incr === "function") {
                this.incr();
            }
            node = {
                value,
                prev: this._last,
                next: null
            };
            if (this._last != null) {
                this._last.next = node;
                this._last = node;
            } else {
                this._first = this._last = node;
            }
            return void 0;
        }
        shift() {
            var value;
            if (this._first == null) {
                return;
            } else {
                this.length--;
                if (typeof this.decr === "function") {
                    this.decr();
                }
            }
            value = this._first.value;
            if ((this._first = this._first.next) != null) {
                this._first.prev = null;
            } else {
                this._last = null;
            }
            return value;
        }
        first() {
            if (this._first != null) {
                return this._first.value;
            }
        }
        getArray() {
            var node, ref, results;
            node = this._first;
            results = [];
            while(node != null){
                results.push((ref = node, node = node.next, ref.value));
            }
            return results;
        }
        forEachShift(cb) {
            var node;
            node = this.shift();
            while(node != null){
                cb(node), node = this.shift();
            }
            return void 0;
        }
        debug() {
            var node, ref, ref1, ref2, results;
            node = this._first;
            results = [];
            while(node != null){
                results.push((ref = node, node = node.next, {
                    value: ref.value,
                    prev: (ref1 = ref.prev) != null ? ref1.value : void 0,
                    next: (ref2 = ref.next) != null ? ref2.value : void 0
                }));
            }
            return results;
        }
    };
    var DLList_1 = DLList;
    var Events;
    Events = class Events {
        constructor(instance){
            this.instance = instance;
            this._events = {};
            if (this.instance.on != null || this.instance.once != null || this.instance.removeAllListeners != null) {
                throw new Error("An Emitter already exists for this object");
            }
            this.instance.on = (name, cb)=>{
                return this._addListener(name, "many", cb);
            };
            this.instance.once = (name, cb)=>{
                return this._addListener(name, "once", cb);
            };
            this.instance.removeAllListeners = (name = null)=>{
                if (name != null) {
                    return delete this._events[name];
                } else {
                    return this._events = {};
                }
            };
        }
        _addListener(name, status, cb) {
            var base;
            if ((base = this._events)[name] == null) {
                base[name] = [];
            }
            this._events[name].push({
                cb,
                status
            });
            return this.instance;
        }
        listenerCount(name) {
            if (this._events[name] != null) {
                return this._events[name].length;
            } else {
                return 0;
            }
        }
        async trigger(name, ...args) {
            var e, promises;
            try {
                if (name !== "debug") {
                    this.trigger("debug", `Event triggered: ${name}`, args);
                }
                if (this._events[name] == null) {
                    return;
                }
                this._events[name] = this._events[name].filter(function(listener) {
                    return listener.status !== "none";
                });
                promises = this._events[name].map(async (listener)=>{
                    var e, returned;
                    if (listener.status === "none") {
                        return;
                    }
                    if (listener.status === "once") {
                        listener.status = "none";
                    }
                    try {
                        returned = typeof listener.cb === "function" ? listener.cb(...args) : void 0;
                        if (typeof (returned != null ? returned.then : void 0) === "function") {
                            return await returned;
                        } else {
                            return returned;
                        }
                    } catch (error) {
                        e = error;
                        {
                            this.trigger("error", e);
                        }
                        return null;
                    }
                });
                return (await Promise.all(promises)).find(function(x) {
                    return x != null;
                });
            } catch (error) {
                e = error;
                {
                    this.trigger("error", e);
                }
                return null;
            }
        }
    };
    var Events_1 = Events;
    var DLList$1, Events$1, Queues;
    DLList$1 = DLList_1;
    Events$1 = Events_1;
    Queues = class Queues {
        constructor(num_priorities){
            var i;
            this.Events = new Events$1(this);
            this._length = 0;
            this._lists = (function() {
                var j, ref, results;
                results = [];
                for(i = j = 1, ref = num_priorities; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j){
                    results.push(new DLList$1(()=>{
                        return this.incr();
                    }, ()=>{
                        return this.decr();
                    }));
                }
                return results;
            }).call(this);
        }
        incr() {
            if (this._length++ === 0) {
                return this.Events.trigger("leftzero");
            }
        }
        decr() {
            if (--this._length === 0) {
                return this.Events.trigger("zero");
            }
        }
        push(job) {
            return this._lists[job.options.priority].push(job);
        }
        queued(priority) {
            if (priority != null) {
                return this._lists[priority].length;
            } else {
                return this._length;
            }
        }
        shiftAll(fn) {
            return this._lists.forEach(function(list) {
                return list.forEachShift(fn);
            });
        }
        getFirst(arr = this._lists) {
            var j, len, list;
            for(j = 0, len = arr.length; j < len; j++){
                list = arr[j];
                if (list.length > 0) {
                    return list;
                }
            }
            return [];
        }
        shiftLastFrom(priority) {
            return this.getFirst(this._lists.slice(priority).reverse()).shift();
        }
    };
    var Queues_1 = Queues;
    var BottleneckError;
    BottleneckError = class BottleneckError extends Error {
    };
    var BottleneckError_1 = BottleneckError;
    var BottleneckError$1, DEFAULT_PRIORITY, Job, NUM_PRIORITIES, parser$1;
    NUM_PRIORITIES = 10;
    DEFAULT_PRIORITY = 5;
    parser$1 = parser;
    BottleneckError$1 = BottleneckError_1;
    Job = class Job {
        constructor(task, args, options, jobDefaults, rejectOnDrop, Events, _states, Promise1){
            this.task = task;
            this.args = args;
            this.rejectOnDrop = rejectOnDrop;
            this.Events = Events;
            this._states = _states;
            this.Promise = Promise1;
            this.options = parser$1.load(options, jobDefaults);
            this.options.priority = this._sanitizePriority(this.options.priority);
            if (this.options.id === jobDefaults.id) {
                this.options.id = `${this.options.id}-${this._randomIndex()}`;
            }
            this.promise = new this.Promise((_resolve, _reject)=>{
                this._resolve = _resolve;
                this._reject = _reject;
            });
            this.retryCount = 0;
        }
        _sanitizePriority(priority) {
            var sProperty;
            sProperty = ~~priority !== priority ? DEFAULT_PRIORITY : priority;
            if (sProperty < 0) {
                return 0;
            } else if (sProperty > NUM_PRIORITIES - 1) {
                return NUM_PRIORITIES - 1;
            } else {
                return sProperty;
            }
        }
        _randomIndex() {
            return Math.random().toString(36).slice(2);
        }
        doDrop({ error, message = "This job has been dropped by Bottleneck" } = {}) {
            if (this._states.remove(this.options.id)) {
                if (this.rejectOnDrop) {
                    this._reject(error != null ? error : new BottleneckError$1(message));
                }
                this.Events.trigger("dropped", {
                    args: this.args,
                    options: this.options,
                    task: this.task,
                    promise: this.promise
                });
                return true;
            } else {
                return false;
            }
        }
        _assertStatus(expected) {
            var status;
            status = this._states.jobStatus(this.options.id);
            if (!(status === expected || expected === "DONE" && status === null)) {
                throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`);
            }
        }
        doReceive() {
            this._states.start(this.options.id);
            return this.Events.trigger("received", {
                args: this.args,
                options: this.options
            });
        }
        doQueue(reachedHWM, blocked) {
            this._assertStatus("RECEIVED");
            this._states.next(this.options.id);
            return this.Events.trigger("queued", {
                args: this.args,
                options: this.options,
                reachedHWM,
                blocked
            });
        }
        doRun() {
            if (this.retryCount === 0) {
                this._assertStatus("QUEUED");
                this._states.next(this.options.id);
            } else {
                this._assertStatus("EXECUTING");
            }
            return this.Events.trigger("scheduled", {
                args: this.args,
                options: this.options
            });
        }
        async doExecute(chained, clearGlobalState, run, free) {
            var error, eventInfo, passed;
            if (this.retryCount === 0) {
                this._assertStatus("RUNNING");
                this._states.next(this.options.id);
            } else {
                this._assertStatus("EXECUTING");
            }
            eventInfo = {
                args: this.args,
                options: this.options,
                retryCount: this.retryCount
            };
            this.Events.trigger("executing", eventInfo);
            try {
                passed = await (chained != null ? chained.schedule(this.options, this.task, ...this.args) : this.task(...this.args));
                if (clearGlobalState()) {
                    this.doDone(eventInfo);
                    await free(this.options, eventInfo);
                    this._assertStatus("DONE");
                    return this._resolve(passed);
                }
            } catch (error1) {
                error = error1;
                return this._onFailure(error, eventInfo, clearGlobalState, run, free);
            }
        }
        doExpire(clearGlobalState, run, free) {
            var error, eventInfo;
            if (this._states.jobStatus(this.options.id === "RUNNING")) {
                this._states.next(this.options.id);
            }
            this._assertStatus("EXECUTING");
            eventInfo = {
                args: this.args,
                options: this.options,
                retryCount: this.retryCount
            };
            error = new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`);
            return this._onFailure(error, eventInfo, clearGlobalState, run, free);
        }
        async _onFailure(error, eventInfo, clearGlobalState, run, free) {
            var retry, retryAfter;
            if (clearGlobalState()) {
                retry = await this.Events.trigger("failed", error, eventInfo);
                if (retry != null) {
                    retryAfter = ~~retry;
                    this.Events.trigger("retry", `Retrying ${this.options.id} after ${retryAfter} ms`, eventInfo);
                    this.retryCount++;
                    return run(retryAfter);
                } else {
                    this.doDone(eventInfo);
                    await free(this.options, eventInfo);
                    this._assertStatus("DONE");
                    return this._reject(error);
                }
            }
        }
        doDone(eventInfo) {
            this._assertStatus("EXECUTING");
            this._states.next(this.options.id);
            return this.Events.trigger("done", eventInfo);
        }
    };
    var Job_1 = Job;
    var BottleneckError$2, LocalDatastore, parser$2;
    parser$2 = parser;
    BottleneckError$2 = BottleneckError_1;
    LocalDatastore = class LocalDatastore {
        constructor(instance, storeOptions, storeInstanceOptions){
            this.instance = instance;
            this.storeOptions = storeOptions;
            this.clientId = this.instance._randomIndex();
            parser$2.load(storeInstanceOptions, storeInstanceOptions, this);
            this._nextRequest = this._lastReservoirRefresh = this._lastReservoirIncrease = Date.now();
            this._running = 0;
            this._done = 0;
            this._unblockTime = 0;
            this.ready = this.Promise.resolve();
            this.clients = {};
            this._startHeartbeat();
        }
        _startHeartbeat() {
            var base;
            if (this.heartbeat == null && (this.storeOptions.reservoirRefreshInterval != null && this.storeOptions.reservoirRefreshAmount != null || this.storeOptions.reservoirIncreaseInterval != null && this.storeOptions.reservoirIncreaseAmount != null)) {
                return typeof (base = this.heartbeat = setInterval(()=>{
                    var amount, incr, maximum, now, reservoir;
                    now = Date.now();
                    if (this.storeOptions.reservoirRefreshInterval != null && now >= this._lastReservoirRefresh + this.storeOptions.reservoirRefreshInterval) {
                        this._lastReservoirRefresh = now;
                        this.storeOptions.reservoir = this.storeOptions.reservoirRefreshAmount;
                        this.instance._drainAll(this.computeCapacity());
                    }
                    if (this.storeOptions.reservoirIncreaseInterval != null && now >= this._lastReservoirIncrease + this.storeOptions.reservoirIncreaseInterval) {
                        ({ reservoirIncreaseAmount: amount, reservoirIncreaseMaximum: maximum, reservoir } = this.storeOptions);
                        this._lastReservoirIncrease = now;
                        incr = maximum != null ? Math.min(amount, maximum - reservoir) : amount;
                        if (incr > 0) {
                            this.storeOptions.reservoir += incr;
                            return this.instance._drainAll(this.computeCapacity());
                        }
                    }
                }, this.heartbeatInterval)).unref === "function" ? base.unref() : void 0;
            } else {
                return clearInterval(this.heartbeat);
            }
        }
        async __publish__(message) {
            await this.yieldLoop();
            return this.instance.Events.trigger("message", message.toString());
        }
        async __disconnect__(flush) {
            await this.yieldLoop();
            clearInterval(this.heartbeat);
            return this.Promise.resolve();
        }
        yieldLoop(t = 0) {
            return new this.Promise(function(resolve, reject) {
                return setTimeout(resolve, t);
            });
        }
        computePenalty() {
            var ref;
            return (ref = this.storeOptions.penalty) != null ? ref : 15 * this.storeOptions.minTime || 5000;
        }
        async __updateSettings__(options) {
            await this.yieldLoop();
            parser$2.overwrite(options, options, this.storeOptions);
            this._startHeartbeat();
            this.instance._drainAll(this.computeCapacity());
            return true;
        }
        async __running__() {
            await this.yieldLoop();
            return this._running;
        }
        async __queued__() {
            await this.yieldLoop();
            return this.instance.queued();
        }
        async __done__() {
            await this.yieldLoop();
            return this._done;
        }
        async __groupCheck__(time) {
            await this.yieldLoop();
            return this._nextRequest + this.timeout < time;
        }
        computeCapacity() {
            var maxConcurrent, reservoir;
            ({ maxConcurrent, reservoir } = this.storeOptions);
            if (maxConcurrent != null && reservoir != null) {
                return Math.min(maxConcurrent - this._running, reservoir);
            } else if (maxConcurrent != null) {
                return maxConcurrent - this._running;
            } else if (reservoir != null) {
                return reservoir;
            } else {
                return null;
            }
        }
        conditionsCheck(weight) {
            var capacity;
            capacity = this.computeCapacity();
            return capacity == null || weight <= capacity;
        }
        async __incrementReservoir__(incr) {
            var reservoir;
            await this.yieldLoop();
            reservoir = this.storeOptions.reservoir += incr;
            this.instance._drainAll(this.computeCapacity());
            return reservoir;
        }
        async __currentReservoir__() {
            await this.yieldLoop();
            return this.storeOptions.reservoir;
        }
        isBlocked(now) {
            return this._unblockTime >= now;
        }
        check(weight, now) {
            return this.conditionsCheck(weight) && this._nextRequest - now <= 0;
        }
        async __check__(weight) {
            var now;
            await this.yieldLoop();
            now = Date.now();
            return this.check(weight, now);
        }
        async __register__(index, weight, expiration) {
            var now, wait;
            await this.yieldLoop();
            now = Date.now();
            if (this.conditionsCheck(weight)) {
                this._running += weight;
                if (this.storeOptions.reservoir != null) {
                    this.storeOptions.reservoir -= weight;
                }
                wait = Math.max(this._nextRequest - now, 0);
                this._nextRequest = now + wait + this.storeOptions.minTime;
                return {
                    success: true,
                    wait,
                    reservoir: this.storeOptions.reservoir
                };
            } else {
                return {
                    success: false
                };
            }
        }
        strategyIsBlock() {
            return this.storeOptions.strategy === 3;
        }
        async __submit__(queueLength, weight) {
            var blocked, now, reachedHWM;
            await this.yieldLoop();
            if (this.storeOptions.maxConcurrent != null && weight > this.storeOptions.maxConcurrent) {
                throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);
            }
            now = Date.now();
            reachedHWM = this.storeOptions.highWater != null && queueLength === this.storeOptions.highWater && !this.check(weight, now);
            blocked = this.strategyIsBlock() && (reachedHWM || this.isBlocked(now));
            if (blocked) {
                this._unblockTime = now + this.computePenalty();
                this._nextRequest = this._unblockTime + this.storeOptions.minTime;
                this.instance._dropAllQueued();
            }
            return {
                reachedHWM,
                blocked,
                strategy: this.storeOptions.strategy
            };
        }
        async __free__(index, weight) {
            await this.yieldLoop();
            this._running -= weight;
            this._done += weight;
            this.instance._drainAll(this.computeCapacity());
            return {
                running: this._running
            };
        }
    };
    var LocalDatastore_1 = LocalDatastore;
    var BottleneckError$3, States;
    BottleneckError$3 = BottleneckError_1;
    States = class States {
        constructor(status1){
            this.status = status1;
            this._jobs = {};
            this.counts = this.status.map(function() {
                return 0;
            });
        }
        next(id) {
            var current, next;
            current = this._jobs[id];
            next = current + 1;
            if (current != null && next < this.status.length) {
                this.counts[current]--;
                this.counts[next]++;
                return this._jobs[id]++;
            } else if (current != null) {
                this.counts[current]--;
                return delete this._jobs[id];
            }
        }
        start(id) {
            var initial;
            initial = 0;
            this._jobs[id] = initial;
            return this.counts[initial]++;
        }
        remove(id) {
            var current;
            current = this._jobs[id];
            if (current != null) {
                this.counts[current]--;
                delete this._jobs[id];
            }
            return current != null;
        }
        jobStatus(id) {
            var ref;
            return (ref = this.status[this._jobs[id]]) != null ? ref : null;
        }
        statusJobs(status) {
            var k, pos, ref, results, v;
            if (status != null) {
                pos = this.status.indexOf(status);
                if (pos < 0) {
                    throw new BottleneckError$3(`status must be one of ${this.status.join(', ')}`);
                }
                ref = this._jobs;
                results = [];
                for(k in ref){
                    v = ref[k];
                    if (v === pos) {
                        results.push(k);
                    }
                }
                return results;
            } else {
                return Object.keys(this._jobs);
            }
        }
        statusCounts() {
            return this.counts.reduce((acc, v, i)=>{
                acc[this.status[i]] = v;
                return acc;
            }, {});
        }
    };
    var States_1 = States;
    var DLList$2, Sync;
    DLList$2 = DLList_1;
    Sync = class Sync {
        constructor(name, Promise1){
            this.schedule = this.schedule.bind(this);
            this.name = name;
            this.Promise = Promise1;
            this._running = 0;
            this._queue = new DLList$2();
        }
        isEmpty() {
            return this._queue.length === 0;
        }
        async _tryToRun() {
            var args, cb, error, reject, resolve, returned, task;
            if (this._running < 1 && this._queue.length > 0) {
                this._running++;
                ({ task, args, resolve, reject } = this._queue.shift());
                cb = await async function() {
                    try {
                        returned = await task(...args);
                        return function() {
                            return resolve(returned);
                        };
                    } catch (error1) {
                        error = error1;
                        return function() {
                            return reject(error);
                        };
                    }
                }();
                this._running--;
                this._tryToRun();
                return cb();
            }
        }
        schedule(task, ...args) {
            var promise, reject, resolve;
            resolve = reject = null;
            promise = new this.Promise(function(_resolve, _reject) {
                resolve = _resolve;
                return reject = _reject;
            });
            this._queue.push({
                task,
                args,
                resolve,
                reject
            });
            this._tryToRun();
            return promise;
        }
    };
    var Sync_1 = Sync;
    var version = "2.19.5";
    var version$1 = {
        version: version
    };
    var version$2 = /*#__PURE__*/ Object.freeze({
        version: version,
        default: version$1
    });
    var require$$2 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$3 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$4 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var Events$2, Group, IORedisConnection$1, RedisConnection$1, Scripts$1, parser$3;
    parser$3 = parser;
    Events$2 = Events_1;
    RedisConnection$1 = require$$2;
    IORedisConnection$1 = require$$3;
    Scripts$1 = require$$4;
    Group = (function() {
        class Group {
            constructor(limiterOptions = {}){
                this.deleteKey = this.deleteKey.bind(this);
                this.limiterOptions = limiterOptions;
                parser$3.load(this.limiterOptions, this.defaults, this);
                this.Events = new Events$2(this);
                this.instances = {};
                this.Bottleneck = Bottleneck_1;
                this._startAutoCleanup();
                this.sharedConnection = this.connection != null;
                if (this.connection == null) {
                    if (this.limiterOptions.datastore === "redis") {
                        this.connection = new RedisConnection$1(Object.assign({}, this.limiterOptions, {
                            Events: this.Events
                        }));
                    } else if (this.limiterOptions.datastore === "ioredis") {
                        this.connection = new IORedisConnection$1(Object.assign({}, this.limiterOptions, {
                            Events: this.Events
                        }));
                    }
                }
            }
            key(key = "") {
                var ref;
                return (ref = this.instances[key]) != null ? ref : (()=>{
                    var limiter;
                    limiter = this.instances[key] = new this.Bottleneck(Object.assign(this.limiterOptions, {
                        id: `${this.id}-${key}`,
                        timeout: this.timeout,
                        connection: this.connection
                    }));
                    this.Events.trigger("created", limiter, key);
                    return limiter;
                })();
            }
            async deleteKey(key = "") {
                var deleted, instance;
                instance = this.instances[key];
                if (this.connection) {
                    deleted = await this.connection.__runCommand__([
                        'del',
                        ...Scripts$1.allKeys(`${this.id}-${key}`)
                    ]);
                }
                if (instance != null) {
                    delete this.instances[key];
                    await instance.disconnect();
                }
                return instance != null || deleted > 0;
            }
            limiters() {
                var k, ref, results, v;
                ref = this.instances;
                results = [];
                for(k in ref){
                    v = ref[k];
                    results.push({
                        key: k,
                        limiter: v
                    });
                }
                return results;
            }
            keys() {
                return Object.keys(this.instances);
            }
            async clusterKeys() {
                var cursor, end, found, i, k, keys, len, next, start;
                if (this.connection == null) {
                    return this.Promise.resolve(this.keys());
                }
                keys = [];
                cursor = null;
                start = `b_${this.id}-`.length;
                end = "_settings".length;
                while(cursor !== 0){
                    [next, found] = await this.connection.__runCommand__([
                        "scan",
                        cursor != null ? cursor : 0,
                        "match",
                        `b_${this.id}-*_settings`,
                        "count",
                        10000
                    ]);
                    cursor = ~~next;
                    for(i = 0, len = found.length; i < len; i++){
                        k = found[i];
                        keys.push(k.slice(start, -end));
                    }
                }
                return keys;
            }
            _startAutoCleanup() {
                var base;
                clearInterval(this.interval);
                return typeof (base = this.interval = setInterval(async ()=>{
                    var e, k, ref, results, time, v;
                    time = Date.now();
                    ref = this.instances;
                    results = [];
                    for(k in ref){
                        v = ref[k];
                        try {
                            if (await v._store.__groupCheck__(time)) {
                                results.push(this.deleteKey(k));
                            } else {
                                results.push(void 0);
                            }
                        } catch (error) {
                            e = error;
                            results.push(v.Events.trigger("error", e));
                        }
                    }
                    return results;
                }, this.timeout / 2)).unref === "function" ? base.unref() : void 0;
            }
            updateSettings(options = {}) {
                parser$3.overwrite(options, this.defaults, this);
                parser$3.overwrite(options, options, this.limiterOptions);
                if (options.timeout != null) {
                    return this._startAutoCleanup();
                }
            }
            disconnect(flush = true) {
                var ref;
                if (!this.sharedConnection) {
                    return (ref = this.connection) != null ? ref.disconnect(flush) : void 0;
                }
            }
        }
        Group.prototype.defaults = {
            timeout: 1000 * 60 * 5,
            connection: null,
            Promise: Promise,
            id: "group-key"
        };
        return Group;
    }).call(commonjsGlobal);
    var Group_1 = Group;
    var Batcher, Events$3, parser$4;
    parser$4 = parser;
    Events$3 = Events_1;
    Batcher = (function() {
        class Batcher {
            constructor(options = {}){
                this.options = options;
                parser$4.load(this.options, this.defaults, this);
                this.Events = new Events$3(this);
                this._arr = [];
                this._resetPromise();
                this._lastFlush = Date.now();
            }
            _resetPromise() {
                return this._promise = new this.Promise((res, rej)=>{
                    return this._resolve = res;
                });
            }
            _flush() {
                clearTimeout(this._timeout);
                this._lastFlush = Date.now();
                this._resolve();
                this.Events.trigger("batch", this._arr);
                this._arr = [];
                return this._resetPromise();
            }
            add(data) {
                var ret;
                this._arr.push(data);
                ret = this._promise;
                if (this._arr.length === this.maxSize) {
                    this._flush();
                } else if (this.maxTime != null && this._arr.length === 1) {
                    this._timeout = setTimeout(()=>{
                        return this._flush();
                    }, this.maxTime);
                }
                return ret;
            }
        }
        Batcher.prototype.defaults = {
            maxTime: null,
            maxSize: null,
            Promise: Promise
        };
        return Batcher;
    }).call(commonjsGlobal);
    var Batcher_1 = Batcher;
    var require$$4$1 = ()=>console.log('You must import the full version of Bottleneck in order to use this feature.');
    var require$$8 = getCjsExportFromNamespace(version$2);
    var Bottleneck, DEFAULT_PRIORITY$1, Events$4, Job$1, LocalDatastore$1, NUM_PRIORITIES$1, Queues$1, RedisDatastore$1, States$1, Sync$1, parser$5, splice = [].splice;
    NUM_PRIORITIES$1 = 10;
    DEFAULT_PRIORITY$1 = 5;
    parser$5 = parser;
    Queues$1 = Queues_1;
    Job$1 = Job_1;
    LocalDatastore$1 = LocalDatastore_1;
    RedisDatastore$1 = require$$4$1;
    Events$4 = Events_1;
    States$1 = States_1;
    Sync$1 = Sync_1;
    Bottleneck = (function() {
        class Bottleneck {
            constructor(options = {}, ...invalid){
                var storeInstanceOptions, storeOptions;
                this._addToQueue = this._addToQueue.bind(this);
                this._validateOptions(options, invalid);
                parser$5.load(options, this.instanceDefaults, this);
                this._queues = new Queues$1(NUM_PRIORITIES$1);
                this._scheduled = {};
                this._states = new States$1([
                    "RECEIVED",
                    "QUEUED",
                    "RUNNING",
                    "EXECUTING"
                ].concat(this.trackDoneStatus ? [
                    "DONE"
                ] : []));
                this._limiter = null;
                this.Events = new Events$4(this);
                this._submitLock = new Sync$1("submit", this.Promise);
                this._registerLock = new Sync$1("register", this.Promise);
                storeOptions = parser$5.load(options, this.storeDefaults, {});
                this._store = (function() {
                    if (this.datastore === "redis" || this.datastore === "ioredis" || this.connection != null) {
                        storeInstanceOptions = parser$5.load(options, this.redisStoreDefaults, {});
                        return new RedisDatastore$1(this, storeOptions, storeInstanceOptions);
                    } else if (this.datastore === "local") {
                        storeInstanceOptions = parser$5.load(options, this.localStoreDefaults, {});
                        return new LocalDatastore$1(this, storeOptions, storeInstanceOptions);
                    } else {
                        throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`);
                    }
                }).call(this);
                this._queues.on("leftzero", ()=>{
                    var ref;
                    return (ref = this._store.heartbeat) != null ? typeof ref.ref === "function" ? ref.ref() : void 0 : void 0;
                });
                this._queues.on("zero", ()=>{
                    var ref;
                    return (ref = this._store.heartbeat) != null ? typeof ref.unref === "function" ? ref.unref() : void 0 : void 0;
                });
            }
            _validateOptions(options, invalid) {
                if (!(options != null && typeof options === "object" && invalid.length === 0)) {
                    throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.");
                }
            }
            ready() {
                return this._store.ready;
            }
            clients() {
                return this._store.clients;
            }
            channel() {
                return `b_${this.id}`;
            }
            channel_client() {
                return `b_${this.id}_${this._store.clientId}`;
            }
            publish(message) {
                return this._store.__publish__(message);
            }
            disconnect(flush = true) {
                return this._store.__disconnect__(flush);
            }
            chain(_limiter) {
                this._limiter = _limiter;
                return this;
            }
            queued(priority) {
                return this._queues.queued(priority);
            }
            clusterQueued() {
                return this._store.__queued__();
            }
            empty() {
                return this.queued() === 0 && this._submitLock.isEmpty();
            }
            running() {
                return this._store.__running__();
            }
            done() {
                return this._store.__done__();
            }
            jobStatus(id) {
                return this._states.jobStatus(id);
            }
            jobs(status) {
                return this._states.statusJobs(status);
            }
            counts() {
                return this._states.statusCounts();
            }
            _randomIndex() {
                return Math.random().toString(36).slice(2);
            }
            check(weight = 1) {
                return this._store.__check__(weight);
            }
            _clearGlobalState(index) {
                if (this._scheduled[index] != null) {
                    clearTimeout(this._scheduled[index].expiration);
                    delete this._scheduled[index];
                    return true;
                } else {
                    return false;
                }
            }
            async _free(index, job, options, eventInfo) {
                var e, running;
                try {
                    ({ running } = await this._store.__free__(index, options.weight));
                    this.Events.trigger("debug", `Freed ${options.id}`, eventInfo);
                    if (running === 0 && this.empty()) {
                        return this.Events.trigger("idle");
                    }
                } catch (error1) {
                    e = error1;
                    return this.Events.trigger("error", e);
                }
            }
            _run(index, job, wait) {
                var clearGlobalState, free, run;
                job.doRun();
                clearGlobalState = this._clearGlobalState.bind(this, index);
                run = this._run.bind(this, index, job);
                free = this._free.bind(this, index, job);
                return this._scheduled[index] = {
                    timeout: setTimeout(()=>{
                        return job.doExecute(this._limiter, clearGlobalState, run, free);
                    }, wait),
                    expiration: job.options.expiration != null ? setTimeout(function() {
                        return job.doExpire(clearGlobalState, run, free);
                    }, wait + job.options.expiration) : void 0,
                    job: job
                };
            }
            _drainOne(capacity) {
                return this._registerLock.schedule(()=>{
                    var args, index, next, options, queue;
                    if (this.queued() === 0) {
                        return this.Promise.resolve(null);
                    }
                    queue = this._queues.getFirst();
                    ({ options, args } = next = queue.first());
                    if (capacity != null && options.weight > capacity) {
                        return this.Promise.resolve(null);
                    }
                    this.Events.trigger("debug", `Draining ${options.id}`, {
                        args,
                        options
                    });
                    index = this._randomIndex();
                    return this._store.__register__(index, options.weight, options.expiration).then(({ success, wait, reservoir })=>{
                        var empty;
                        this.Events.trigger("debug", `Drained ${options.id}`, {
                            success,
                            args,
                            options
                        });
                        if (success) {
                            queue.shift();
                            empty = this.empty();
                            if (empty) {
                                this.Events.trigger("empty");
                            }
                            if (reservoir === 0) {
                                this.Events.trigger("depleted", empty);
                            }
                            this._run(index, next, wait);
                            return this.Promise.resolve(options.weight);
                        } else {
                            return this.Promise.resolve(null);
                        }
                    });
                });
            }
            _drainAll(capacity, total = 0) {
                return this._drainOne(capacity).then((drained)=>{
                    var newCapacity;
                    if (drained != null) {
                        newCapacity = capacity != null ? capacity - drained : capacity;
                        return this._drainAll(newCapacity, total + drained);
                    } else {
                        return this.Promise.resolve(total);
                    }
                }).catch((e)=>{
                    return this.Events.trigger("error", e);
                });
            }
            _dropAllQueued(message) {
                return this._queues.shiftAll(function(job) {
                    return job.doDrop({
                        message
                    });
                });
            }
            stop(options = {}) {
                var done, waitForExecuting;
                options = parser$5.load(options, this.stopDefaults);
                waitForExecuting = (at)=>{
                    var finished;
                    finished = ()=>{
                        var counts;
                        counts = this._states.counts;
                        return counts[0] + counts[1] + counts[2] + counts[3] === at;
                    };
                    return new this.Promise((resolve, reject)=>{
                        if (finished()) {
                            return resolve();
                        } else {
                            return this.on("done", ()=>{
                                if (finished()) {
                                    this.removeAllListeners("done");
                                    return resolve();
                                }
                            });
                        }
                    });
                };
                done = options.dropWaitingJobs ? (this._run = function(index, next) {
                    return next.doDrop({
                        message: options.dropErrorMessage
                    });
                }, this._drainOne = ()=>{
                    return this.Promise.resolve(null);
                }, this._registerLock.schedule(()=>{
                    return this._submitLock.schedule(()=>{
                        var k, ref, v;
                        ref = this._scheduled;
                        for(k in ref){
                            v = ref[k];
                            if (this.jobStatus(v.job.options.id) === "RUNNING") {
                                clearTimeout(v.timeout);
                                clearTimeout(v.expiration);
                                v.job.doDrop({
                                    message: options.dropErrorMessage
                                });
                            }
                        }
                        this._dropAllQueued(options.dropErrorMessage);
                        return waitForExecuting(0);
                    });
                })) : this.schedule({
                    priority: NUM_PRIORITIES$1 - 1,
                    weight: 0
                }, ()=>{
                    return waitForExecuting(1);
                });
                this._receive = function(job) {
                    return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage));
                };
                this.stop = ()=>{
                    return this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called"));
                };
                return done;
            }
            async _addToQueue(job) {
                var args, blocked, error, options, reachedHWM, shifted, strategy;
                ({ args, options } = job);
                try {
                    ({ reachedHWM, blocked, strategy } = await this._store.__submit__(this.queued(), options.weight));
                } catch (error1) {
                    error = error1;
                    this.Events.trigger("debug", `Could not queue ${options.id}`, {
                        args,
                        options,
                        error
                    });
                    job.doDrop({
                        error
                    });
                    return false;
                }
                if (blocked) {
                    job.doDrop();
                    return true;
                } else if (reachedHWM) {
                    shifted = strategy === Bottleneck.prototype.strategy.LEAK ? this._queues.shiftLastFrom(options.priority) : strategy === Bottleneck.prototype.strategy.OVERFLOW_PRIORITY ? this._queues.shiftLastFrom(options.priority + 1) : strategy === Bottleneck.prototype.strategy.OVERFLOW ? job : void 0;
                    if (shifted != null) {
                        shifted.doDrop();
                    }
                    if (shifted == null || strategy === Bottleneck.prototype.strategy.OVERFLOW) {
                        if (shifted == null) {
                            job.doDrop();
                        }
                        return reachedHWM;
                    }
                }
                job.doQueue(reachedHWM, blocked);
                this._queues.push(job);
                await this._drainAll();
                return reachedHWM;
            }
            _receive(job) {
                if (this._states.jobStatus(job.options.id) != null) {
                    job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`));
                    return false;
                } else {
                    job.doReceive();
                    return this._submitLock.schedule(this._addToQueue, job);
                }
            }
            submit(...args) {
                var cb, fn, job, options, ref, ref1, task;
                if (typeof args[0] === "function") {
                    ref = args, [fn, ...args] = ref, [cb] = splice.call(args, -1);
                    options = parser$5.load({}, this.jobDefaults);
                } else {
                    ref1 = args, [options, fn, ...args] = ref1, [cb] = splice.call(args, -1);
                    options = parser$5.load(options, this.jobDefaults);
                }
                task = (...args)=>{
                    return new this.Promise(function(resolve, reject) {
                        return fn(...args, function(...args) {
                            return (args[0] != null ? reject : resolve)(args);
                        });
                    });
                };
                job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
                job.promise.then(function(args) {
                    return typeof cb === "function" ? cb(...args) : void 0;
                }).catch(function(args) {
                    if (Array.isArray(args)) {
                        return typeof cb === "function" ? cb(...args) : void 0;
                    } else {
                        return typeof cb === "function" ? cb(args) : void 0;
                    }
                });
                return this._receive(job);
            }
            schedule(...args) {
                var job, options, task;
                if (typeof args[0] === "function") {
                    [task, ...args] = args;
                    options = {};
                } else {
                    [options, task, ...args] = args;
                }
                job = new Job$1(task, args, options, this.jobDefaults, this.rejectOnDrop, this.Events, this._states, this.Promise);
                this._receive(job);
                return job.promise;
            }
            wrap(fn) {
                var schedule, wrapped;
                schedule = this.schedule.bind(this);
                wrapped = function(...args) {
                    return schedule(fn.bind(this), ...args);
                };
                wrapped.withOptions = function(options, ...args) {
                    return schedule(options, fn, ...args);
                };
                return wrapped;
            }
            async updateSettings(options = {}) {
                await this._store.__updateSettings__(parser$5.overwrite(options, this.storeDefaults));
                parser$5.overwrite(options, this.instanceDefaults, this);
                return this;
            }
            currentReservoir() {
                return this._store.__currentReservoir__();
            }
            incrementReservoir(incr = 0) {
                return this._store.__incrementReservoir__(incr);
            }
        }
        Bottleneck.default = Bottleneck;
        Bottleneck.Events = Events$4;
        Bottleneck.version = Bottleneck.prototype.version = require$$8.version;
        Bottleneck.strategy = Bottleneck.prototype.strategy = {
            LEAK: 1,
            OVERFLOW: 2,
            OVERFLOW_PRIORITY: 4,
            BLOCK: 3
        };
        Bottleneck.BottleneckError = Bottleneck.prototype.BottleneckError = BottleneckError_1;
        Bottleneck.Group = Bottleneck.prototype.Group = Group_1;
        Bottleneck.RedisConnection = Bottleneck.prototype.RedisConnection = require$$2;
        Bottleneck.IORedisConnection = Bottleneck.prototype.IORedisConnection = require$$3;
        Bottleneck.Batcher = Bottleneck.prototype.Batcher = Batcher_1;
        Bottleneck.prototype.jobDefaults = {
            priority: DEFAULT_PRIORITY$1,
            weight: 1,
            expiration: null,
            id: "<no-id>"
        };
        Bottleneck.prototype.storeDefaults = {
            maxConcurrent: null,
            minTime: 0,
            highWater: null,
            strategy: Bottleneck.prototype.strategy.LEAK,
            penalty: null,
            reservoir: null,
            reservoirRefreshInterval: null,
            reservoirRefreshAmount: null,
            reservoirIncreaseInterval: null,
            reservoirIncreaseAmount: null,
            reservoirIncreaseMaximum: null
        };
        Bottleneck.prototype.localStoreDefaults = {
            Promise: Promise,
            timeout: null,
            heartbeatInterval: 250
        };
        Bottleneck.prototype.redisStoreDefaults = {
            Promise: Promise,
            timeout: null,
            heartbeatInterval: 5000,
            clientTimeout: 10000,
            Redis: null,
            clientOptions: {},
            clusterNodes: null,
            clearDatastore: false,
            connection: null
        };
        Bottleneck.prototype.instanceDefaults = {
            datastore: "local",
            connection: null,
            id: "<no-id>",
            rejectOnDrop: true,
            trackDoneStatus: false,
            Promise: Promise
        };
        Bottleneck.prototype.stopDefaults = {
            enqueueErrorMessage: "This limiter has been stopped and cannot accept new jobs.",
            dropWaitingJobs: true,
            dropErrorMessage: "This limiter has been stopped."
        };
        return Bottleneck;
    }).call(commonjsGlobal);
    var Bottleneck_1 = Bottleneck;
    var lib = Bottleneck_1;
    return lib;
});
}}),
"[project]/node_modules/@octokit/plugin-retry/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/version.js
__turbopack_context__.s({
    "VERSION": (()=>VERSION),
    "retry": (()=>retry)
});
// pkg/dist-src/wrap-request.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bottleneck/light.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request-error/dist-src/index.js [app-client] (ecmascript)");
var VERSION = "0.0.0-development";
// pkg/dist-src/error-request.js
async function errorRequest(state, octokit, error, options) {
    if (!error.request || !error.request.request) {
        throw error;
    }
    if (error.status >= 400 && !state.doNotRetry.includes(error.status)) {
        const retries = options.request.retries != null ? options.request.retries : state.retries;
        const retryAfter = Math.pow((options.request.retryCount || 0) + 1, 2);
        throw octokit.retry.retryRequest(error, retries, retryAfter);
    }
    throw error;
}
;
;
async function wrapRequest(state, octokit, request, options) {
    const limiter = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]();
    limiter.on("failed", function(error, info) {
        const maxRetries = ~~error.request.request.retries;
        const after = ~~error.request.request.retryAfter;
        options.request.retryCount = info.retryCount + 1;
        if (maxRetries > info.retryCount) {
            return after * state.retryAfterBaseValue;
        }
    });
    return limiter.schedule(requestWithGraphqlErrorHandling.bind(null, state, octokit, request), options);
}
async function requestWithGraphqlErrorHandling(state, octokit, request, options) {
    const response = await request(request, options);
    if (response.data && response.data.errors && response.data.errors.length > 0 && /Something went wrong while executing your query/.test(response.data.errors[0].message)) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"](response.data.errors[0].message, 500, {
            request: options,
            response
        });
        return errorRequest(state, octokit, error, options);
    }
    return response;
}
// pkg/dist-src/index.js
function retry(octokit, octokitOptions) {
    const state = Object.assign({
        enabled: true,
        retryAfterBaseValue: 1e3,
        doNotRetry: [
            400,
            401,
            403,
            404,
            410,
            422,
            451
        ],
        retries: 3
    }, octokitOptions.retry);
    if (state.enabled) {
        octokit.hook.error("request", errorRequest.bind(null, state, octokit));
        octokit.hook.wrap("request", wrapRequest.bind(null, state, octokit));
    }
    return {
        retry: {
            retryRequest: (error, retries, retryAfter)=>{
                error.request.request = Object.assign({}, error.request.request, {
                    retries,
                    retryAfter
                });
                return error;
            }
        }
    };
}
retry.VERSION = VERSION;
;
}}),
"[project]/node_modules/@octokit/plugin-throttling/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "throttling": (()=>throttling)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/bottleneck/light.js [app-client] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/wrap-request.js
var noop = ()=>Promise.resolve();
function wrapRequest(state, request, options) {
    return state.retryLimiter.schedule(doRequest, state, request, options);
}
async function doRequest(state, request, options) {
    const { pathname } = new URL(options.url, "http://github.test");
    const isAuth = isAuthRequest(options.method, pathname);
    const isWrite = !isAuth && options.method !== "GET" && options.method !== "HEAD";
    const isSearch = options.method === "GET" && pathname.startsWith("/search/");
    const isGraphQL = pathname.startsWith("/graphql");
    const retryCount = ~~request.retryCount;
    const jobOptions = retryCount > 0 ? {
        priority: 0,
        weight: 0
    } : {};
    if (state.clustering) {
        jobOptions.expiration = 1e3 * 60;
    }
    if (isWrite || isGraphQL) {
        await state.write.key(state.id).schedule(jobOptions, noop);
    }
    if (isWrite && state.triggersNotification(pathname)) {
        await state.notifications.key(state.id).schedule(jobOptions, noop);
    }
    if (isSearch) {
        await state.search.key(state.id).schedule(jobOptions, noop);
    }
    const req = (isAuth ? state.auth : state.global).key(state.id).schedule(jobOptions, request, options);
    if (isGraphQL) {
        const res = await req;
        if (res.data.errors != null && res.data.errors.some((error)=>error.type === "RATE_LIMITED")) {
            const error = Object.assign(new Error("GraphQL Rate Limit Exceeded"), {
                response: res,
                data: res.data
            });
            throw error;
        }
    }
    return req;
}
function isAuthRequest(method, pathname) {
    return method === "PATCH" && // https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-a-scoped-access-token
    /^\/applications\/[^/]+\/token\/scoped$/.test(pathname) || method === "POST" && // https://docs.github.com/en/rest/apps/oauth-applications?apiVersion=2022-11-28#reset-a-token
    (/^\/applications\/[^/]+\/token$/.test(pathname) || // https://docs.github.com/en/rest/apps/apps?apiVersion=2022-11-28#create-an-installation-access-token-for-an-app
    /^\/app\/installations\/[^/]+\/access_tokens$/.test(pathname) || // https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps
    pathname === "/login/oauth/access_token");
}
// pkg/dist-src/generated/triggers-notification-paths.js
var triggers_notification_paths_default = [
    "/orgs/{org}/invitations",
    "/orgs/{org}/invitations/{invitation_id}",
    "/orgs/{org}/teams/{team_slug}/discussions",
    "/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
    "/repos/{owner}/{repo}/collaborators/{username}",
    "/repos/{owner}/{repo}/commits/{commit_sha}/comments",
    "/repos/{owner}/{repo}/issues",
    "/repos/{owner}/{repo}/issues/{issue_number}/comments",
    "/repos/{owner}/{repo}/issues/{issue_number}/sub_issue",
    "/repos/{owner}/{repo}/issues/{issue_number}/sub_issues/priority",
    "/repos/{owner}/{repo}/pulls",
    "/repos/{owner}/{repo}/pulls/{pull_number}/comments",
    "/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies",
    "/repos/{owner}/{repo}/pulls/{pull_number}/merge",
    "/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers",
    "/repos/{owner}/{repo}/pulls/{pull_number}/reviews",
    "/repos/{owner}/{repo}/releases",
    "/teams/{team_id}/discussions",
    "/teams/{team_id}/discussions/{discussion_number}/comments"
];
// pkg/dist-src/route-matcher.js
function routeMatcher(paths) {
    const regexes = paths.map((path)=>path.split("/").map((c)=>c.startsWith("{") ? "(?:.+?)" : c).join("/"));
    const regex2 = `^(?:${regexes.map((r)=>`(?:${r})`).join("|")})[^/]*$`;
    return new RegExp(regex2, "i");
}
// pkg/dist-src/index.js
var regex = routeMatcher(triggers_notification_paths_default);
var triggersNotification = regex.test.bind(regex);
var groups = {};
var createGroups = function(Bottleneck, common) {
    groups.global = new Bottleneck.Group({
        id: "octokit-global",
        maxConcurrent: 10,
        ...common
    });
    groups.auth = new Bottleneck.Group({
        id: "octokit-auth",
        maxConcurrent: 1,
        ...common
    });
    groups.search = new Bottleneck.Group({
        id: "octokit-search",
        maxConcurrent: 1,
        minTime: 2e3,
        ...common
    });
    groups.write = new Bottleneck.Group({
        id: "octokit-write",
        maxConcurrent: 1,
        minTime: 1e3,
        ...common
    });
    groups.notifications = new Bottleneck.Group({
        id: "octokit-notifications",
        maxConcurrent: 1,
        minTime: 3e3,
        ...common
    });
};
function throttling(octokit, octokitOptions) {
    const { enabled = true, Bottleneck = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$bottleneck$2f$light$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"], id = "no-id", timeout = 1e3 * 60 * 2, // Redis TTL: 2 minutes
    connection } = octokitOptions.throttle || {};
    if (!enabled) {
        return {};
    }
    const common = {
        timeout
    };
    if (typeof connection !== "undefined") {
        common.connection = connection;
    }
    if (groups.global == null) {
        createGroups(Bottleneck, common);
    }
    const state = Object.assign({
        clustering: connection != null,
        triggersNotification,
        fallbackSecondaryRateRetryAfter: 60,
        retryAfterBaseValue: 1e3,
        retryLimiter: new Bottleneck(),
        id,
        ...groups
    }, octokitOptions.throttle);
    if (typeof state.onSecondaryRateLimit !== "function" || typeof state.onRateLimit !== "function") {
        throw new Error(`octokit/plugin-throttling error:
        You must pass the onSecondaryRateLimit and onRateLimit error handlers.
        See https://octokit.github.io/rest.js/#throttling

        const octokit = new Octokit({
          throttle: {
            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},
            onRateLimit: (retryAfter, options) => {/* ... */}
          }
        })
    `);
    }
    const events = {};
    const emitter = new Bottleneck.Events(events);
    events.on("secondary-limit", state.onSecondaryRateLimit);
    events.on("rate-limit", state.onRateLimit);
    events.on("error", (e)=>octokit.log.warn("Error in throttling-plugin limit handler", e));
    state.retryLimiter.on("failed", async function(error, info) {
        const [state2, request, options] = info.args;
        const { pathname } = new URL(options.url, "http://github.test");
        const shouldRetryGraphQL = pathname.startsWith("/graphql") && error.status !== 401;
        if (!(shouldRetryGraphQL || error.status === 403 || error.status === 429)) {
            return;
        }
        const retryCount = ~~request.retryCount;
        request.retryCount = retryCount;
        options.request.retryCount = retryCount;
        const { wantRetry, retryAfter = 0 } = await async function() {
            if (/\bsecondary rate\b/i.test(error.message)) {
                const retryAfter2 = Number(error.response.headers["retry-after"]) || state2.fallbackSecondaryRateRetryAfter;
                const wantRetry2 = await emitter.trigger("secondary-limit", retryAfter2, options, octokit, retryCount);
                return {
                    wantRetry: wantRetry2,
                    retryAfter: retryAfter2
                };
            }
            if (error.response.headers != null && error.response.headers["x-ratelimit-remaining"] === "0" || (error.response.data?.errors ?? []).some((error2)=>error2.type === "RATE_LIMITED")) {
                const rateLimitReset = new Date(~~error.response.headers["x-ratelimit-reset"] * 1e3).getTime();
                const retryAfter2 = Math.max(// Add one second so we retry _after_ the reset time
                // https://docs.github.com/en/rest/overview/resources-in-the-rest-api?apiVersion=2022-11-28#exceeding-the-rate-limit
                Math.ceil((rateLimitReset - Date.now()) / 1e3) + 1, 0);
                const wantRetry2 = await emitter.trigger("rate-limit", retryAfter2, options, octokit, retryCount);
                return {
                    wantRetry: wantRetry2,
                    retryAfter: retryAfter2
                };
            }
            return {};
        }();
        if (wantRetry) {
            request.retryCount++;
            return retryAfter * state2.retryAfterBaseValue;
        }
    });
    octokit.hook.wrap("request", wrapRequest.bind(null, state));
    return {};
}
throttling.VERSION = VERSION;
throttling.triggersNotification = triggersNotification;
;
}}),
"[project]/node_modules/@octokit/oauth-authorization-url/dist-src/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "oauthAuthorizationUrl": (()=>oauthAuthorizationUrl)
});
function oauthAuthorizationUrl(options) {
    const clientType = options.clientType || "oauth-app";
    const baseUrl = options.baseUrl || "https://github.com";
    const result = {
        clientType,
        allowSignup: options.allowSignup === false ? false : true,
        clientId: options.clientId,
        login: options.login || null,
        redirectUrl: options.redirectUrl || null,
        state: options.state || Math.random().toString(36).substr(2),
        url: ""
    };
    if (clientType === "oauth-app") {
        const scopes = "scopes" in options ? options.scopes : [];
        result.scopes = typeof scopes === "string" ? scopes.split(/[,\s]+/).filter(Boolean) : scopes;
    }
    result.url = urlBuilderAuthorize(`${baseUrl}/login/oauth/authorize`, result);
    return result;
}
function urlBuilderAuthorize(base, options) {
    const map = {
        allowSignup: "allow_signup",
        clientId: "client_id",
        login: "login",
        redirectUrl: "redirect_uri",
        scopes: "scope",
        state: "state"
    };
    let url = base;
    Object.keys(map).filter((k)=>options[k] !== null).filter((k)=>{
        if (k !== "scopes") return true;
        if (options.clientType === "github-app") return false;
        return !Array.isArray(options[k]) || options[k].length > 0;
    }).map((key)=>[
            map[key],
            `${options[key]}`
        ]).forEach(([key, value], index)=>{
        url += index === 0 ? `?` : "&";
        url += `${key}=${encodeURIComponent(value)}`;
    });
    return url;
}
;
}}),
"[project]/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/version.js
__turbopack_context__.s({
    "VERSION": (()=>VERSION),
    "checkToken": (()=>checkToken),
    "createDeviceCode": (()=>createDeviceCode),
    "deleteAuthorization": (()=>deleteAuthorization),
    "deleteToken": (()=>deleteToken),
    "exchangeDeviceCode": (()=>exchangeDeviceCode),
    "exchangeWebFlowCode": (()=>exchangeWebFlowCode),
    "getWebFlowAuthorizationUrl": (()=>getWebFlowAuthorizationUrl),
    "refreshToken": (()=>refreshToken),
    "resetToken": (()=>resetToken),
    "scopeToken": (()=>scopeToken)
});
// pkg/dist-src/get-web-flow-authorization-url.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$authorization$2d$url$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-authorization-url/dist-src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/utils.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request-error/dist-src/index.js [app-client] (ecmascript)");
var VERSION = "0.0.0-development";
;
;
;
function requestToOAuthBaseUrl(request) {
    const endpointDefaults = request.endpoint.DEFAULTS;
    return /^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl) ? "https://github.com" : endpointDefaults.baseUrl.replace("/api/v3", "");
}
async function oauthRequest(request, route, parameters) {
    const withOAuthParameters = {
        baseUrl: requestToOAuthBaseUrl(request),
        headers: {
            accept: "application/json"
        },
        ...parameters
    };
    const response = await request(route, withOAuthParameters);
    if ("error" in response.data) {
        const error = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2d$error$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RequestError"](`${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`, 400, {
            request: request.endpoint.merge(route, withOAuthParameters)
        });
        error.response = response;
        throw error;
    }
    return response;
}
// pkg/dist-src/get-web-flow-authorization-url.js
function getWebFlowAuthorizationUrl({ request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"], ...options }) {
    const baseUrl = requestToOAuthBaseUrl(request);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$authorization$2d$url$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["oauthAuthorizationUrl"])({
        ...options,
        baseUrl
    });
}
;
async function exchangeWebFlowCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        client_secret: options.clientSecret,
        code: options.code,
        redirect_uri: options.redirectUrl
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
    };
    if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
            const apiTimeInMs = new Date(response.headers.date).getTime();
            authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp(apiTimeInMs, response.data.refresh_token_expires_in);
        }
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
function toTimestamp(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function createDeviceCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const parameters = {
        client_id: options.clientId
    };
    if ("scopes" in options && Array.isArray(options.scopes)) {
        parameters.scope = options.scopes.join(" ");
    }
    return oauthRequest(request, "POST /login/device/code", parameters);
}
;
async function exchangeDeviceCode(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        device_code: options.code,
        grant_type: "urn:ietf:params:oauth:grant-type:device_code"
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        token: response.data.access_token,
        scopes: response.data.scope.split(/\s+/).filter(Boolean)
    };
    if ("clientSecret" in options) {
        authentication.clientSecret = options.clientSecret;
    }
    if (options.clientType === "github-app") {
        if ("refresh_token" in response.data) {
            const apiTimeInMs = new Date(response.headers.date).getTime();
            authentication.refreshToken = response.data.refresh_token, authentication.expiresAt = toTimestamp2(apiTimeInMs, response.data.expires_in), authentication.refreshTokenExpiresAt = toTimestamp2(apiTimeInMs, response.data.refresh_token_expires_in);
        }
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
function toTimestamp2(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function checkToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const response = await request("POST /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${btoa(`${options.clientId}:${options.clientSecret}`)}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: options.token,
        scopes: response.data.scopes
    };
    if (response.data.expires_at) authentication.expiresAt = response.data.expires_at;
    if (options.clientType === "github-app") {
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
;
async function refreshToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const response = await oauthRequest(request, "POST /login/oauth/access_token", {
        client_id: options.clientId,
        client_secret: options.clientSecret,
        grant_type: "refresh_token",
        refresh_token: options.refreshToken
    });
    const apiTimeInMs = new Date(response.headers.date).getTime();
    const authentication = {
        clientType: "github-app",
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.access_token,
        refreshToken: response.data.refresh_token,
        expiresAt: toTimestamp3(apiTimeInMs, response.data.expires_in),
        refreshTokenExpiresAt: toTimestamp3(apiTimeInMs, response.data.refresh_token_expires_in)
    };
    return {
        ...response,
        authentication
    };
}
function toTimestamp3(apiTimeInMs, expirationInSeconds) {
    return new Date(apiTimeInMs + expirationInSeconds * 1e3).toISOString();
}
;
async function scopeToken(options) {
    const { request: optionsRequest, clientType, clientId, clientSecret, token, ...requestOptions } = options;
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const response = await request("POST /applications/{client_id}/token/scoped", {
        headers: {
            authorization: `basic ${btoa(`${clientId}:${clientSecret}`)}`
        },
        client_id: clientId,
        access_token: token,
        ...requestOptions
    });
    const authentication = Object.assign({
        clientType,
        clientId,
        clientSecret,
        token: response.data.token
    }, response.data.expires_at ? {
        expiresAt: response.data.expires_at
    } : {});
    return {
        ...response,
        authentication
    };
}
;
async function resetToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    const response = await request("PATCH /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
    const authentication = {
        clientType: options.clientType,
        clientId: options.clientId,
        clientSecret: options.clientSecret,
        token: response.data.token,
        scopes: response.data.scopes
    };
    if (response.data.expires_at) authentication.expiresAt = response.data.expires_at;
    if (options.clientType === "github-app") {
        delete authentication.scopes;
    }
    return {
        ...response,
        authentication
    };
}
;
async function deleteToken(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    return request("DELETE /applications/{client_id}/token", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
}
;
async function deleteAuthorization(options) {
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"];
    const auth = btoa(`${options.clientId}:${options.clientSecret}`);
    return request("DELETE /applications/{client_id}/grant", {
        headers: {
            authorization: `basic ${auth}`
        },
        client_id: options.clientId,
        access_token: options.token
    });
}
;
}}),
"[project]/node_modules/@octokit/auth-oauth-device/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "createOAuthDeviceAuth": (()=>createOAuthDeviceAuth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/get-oauth-access-token.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-client] (ecmascript)");
;
;
;
async function getOAuthAccessToken(state, options) {
    const cachedAuthentication = getCachedAuthentication(state, options.auth);
    if (cachedAuthentication) return cachedAuthentication;
    const { data: verification } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDeviceCode"])({
        clientType: state.clientType,
        clientId: state.clientId,
        request: options.request || state.request,
        // @ts-expect-error the extra code to make TS happy is not worth it
        scopes: options.auth.scopes || state.scopes
    });
    await state.onVerification(verification);
    const authentication = await waitForAccessToken(options.request || state.request, state.clientId, state.clientType, verification);
    state.authentication = authentication;
    return authentication;
}
function getCachedAuthentication(state, auth2) {
    if (auth2.refresh === true) return false;
    if (!state.authentication) return false;
    if (state.clientType === "github-app") {
        return state.authentication;
    }
    const authentication = state.authentication;
    const newScope = ("scopes" in auth2 && auth2.scopes || state.scopes).join(" ");
    const currentScope = authentication.scopes.join(" ");
    return newScope === currentScope ? authentication : false;
}
async function wait(seconds) {
    await new Promise((resolve)=>setTimeout(resolve, seconds * 1e3));
}
async function waitForAccessToken(request, clientId, clientType, verification) {
    try {
        const options = {
            clientId,
            request,
            code: verification.device_code
        };
        const { authentication } = clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exchangeDeviceCode"])({
            ...options,
            clientType: "oauth-app"
        }) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exchangeDeviceCode"])({
            ...options,
            clientType: "github-app"
        });
        return {
            type: "token",
            tokenType: "oauth",
            ...authentication
        };
    } catch (error) {
        if (!error.response) throw error;
        const errorType = error.response.data.error;
        if (errorType === "authorization_pending") {
            await wait(verification.interval);
            return waitForAccessToken(request, clientId, clientType, verification);
        }
        if (errorType === "slow_down") {
            await wait(verification.interval + 7);
            return waitForAccessToken(request, clientId, clientType, verification);
        }
        throw error;
    }
}
// pkg/dist-src/auth.js
async function auth(state, authOptions) {
    return getOAuthAccessToken(state, {
        auth: authOptions
    });
}
// pkg/dist-src/hook.js
async function hook(state, request, route, parameters) {
    let endpoint = request.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request(endpoint);
    }
    const { token } = await getOAuthAccessToken(state, {
        request,
        auth: {
            type: "oauth"
        }
    });
    endpoint.headers.authorization = `token ${token}`;
    return request(endpoint);
}
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
// pkg/dist-src/index.js
function createOAuthDeviceAuth(options) {
    const requestWithDefaults = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].defaults({
        headers: {
            "user-agent": `octokit-auth-oauth-device.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
        }
    });
    const { request = requestWithDefaults, ...otherOptions } = options;
    const state = options.clientType === "github-app" ? {
        ...otherOptions,
        clientType: "github-app",
        request
    } : {
        ...otherOptions,
        clientType: "oauth-app",
        request,
        scopes: options.scopes || []
    };
    if (!options.clientId) {
        throw new Error('[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)');
    }
    if (!options.onVerification) {
        throw new Error('[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)');
    }
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}}),
"[project]/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "createOAuthUserAuth": (()=>createOAuthUserAuth),
    "requiresBasicAuth": (()=>requiresBasicAuth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/get-authentication.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$device$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-device/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-client] (ecmascript)");
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
;
async function getAuthentication(state) {
    if ("code" in state.strategyOptions) {
        const { authentication } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["exchangeWebFlowCode"])({
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions,
            request: state.request
        });
        return {
            type: "token",
            tokenType: "oauth",
            ...authentication
        };
    }
    if ("onVerification" in state.strategyOptions) {
        const deviceAuth = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$device$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthDeviceAuth"])({
            clientType: state.clientType,
            clientId: state.clientId,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions,
            request: state.request
        });
        const authentication = await deviceAuth({
            type: "oauth"
        });
        return {
            clientSecret: state.clientSecret,
            ...authentication
        };
    }
    if ("token" in state.strategyOptions) {
        return {
            type: "token",
            tokenType: "oauth",
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            onTokenCreated: state.onTokenCreated,
            ...state.strategyOptions
        };
    }
    throw new Error("[@octokit/auth-oauth-user] Invalid strategy options");
}
;
async function auth(state, options = {}) {
    if (!state.authentication) {
        state.authentication = state.clientType === "oauth-app" ? await getAuthentication(state) : await getAuthentication(state);
    }
    if (state.authentication.invalid) {
        throw new Error("[@octokit/auth-oauth-user] Token is invalid");
    }
    const currentAuthentication = state.authentication;
    if ("expiresAt" in currentAuthentication) {
        if (options.type === "refresh" || new Date(currentAuthentication.expiresAt) < /* @__PURE__ */ new Date()) {
            const { authentication } = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["refreshToken"])({
                clientType: "github-app",
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                refreshToken: currentAuthentication.refreshToken,
                request: state.request
            });
            state.authentication = {
                tokenType: "oauth",
                type: "token",
                ...authentication
            };
        }
    }
    if (options.type === "refresh") {
        if (state.clientType === "oauth-app") {
            throw new Error("[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens");
        }
        if (!currentAuthentication.hasOwnProperty("expiresAt")) {
            throw new Error("[@octokit/auth-oauth-user] Refresh token missing");
        }
        await state.onTokenCreated?.(state.authentication, {
            type: options.type
        });
    }
    if (options.type === "check" || options.type === "reset") {
        const method = options.type === "check" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkToken"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resetToken"];
        try {
            const { authentication } = await method({
                // @ts-expect-error making TS happy would require unnecessary code so no
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: state.authentication.token,
                request: state.request
            });
            state.authentication = {
                tokenType: "oauth",
                type: "token",
                // @ts-expect-error TBD
                ...authentication
            };
            if (options.type === "reset") {
                await state.onTokenCreated?.(state.authentication, {
                    type: options.type
                });
            }
            return state.authentication;
        } catch (error) {
            if (error.status === 404) {
                error.message = "[@octokit/auth-oauth-user] Token is invalid";
                state.authentication.invalid = true;
            }
            throw error;
        }
    }
    if (options.type === "delete" || options.type === "deleteAuthorization") {
        const method = options.type === "delete" ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteToken"] : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteAuthorization"];
        try {
            await method({
                // @ts-expect-error making TS happy would require unnecessary code so no
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: state.authentication.token,
                request: state.request
            });
        } catch (error) {
            if (error.status !== 404) throw error;
        }
        state.authentication.invalid = true;
        return state.authentication;
    }
    return state.authentication;
}
// pkg/dist-src/requires-basic-auth.js
var ROUTES_REQUIRING_BASIC_AUTH = /\/applications\/[^/]+\/(token|grant)s?/;
function requiresBasicAuth(url) {
    return url && ROUTES_REQUIRING_BASIC_AUTH.test(url);
}
// pkg/dist-src/hook.js
async function hook(state, request, route, parameters = {}) {
    const endpoint = request.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request(endpoint);
    }
    if (requiresBasicAuth(endpoint.url)) {
        const credentials = btoa(`${state.clientId}:${state.clientSecret}`);
        endpoint.headers.authorization = `basic ${credentials}`;
        return request(endpoint);
    }
    const { token } = state.clientType === "oauth-app" ? await auth({
        ...state,
        request
    }) : await auth({
        ...state,
        request
    });
    endpoint.headers.authorization = "token " + token;
    return request(endpoint);
}
// pkg/dist-src/index.js
function createOAuthUserAuth({ clientId, clientSecret, clientType = "oauth-app", request = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].defaults({
    headers: {
        "user-agent": `octokit-auth-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
    }
}), onTokenCreated, ...strategyOptions }) {
    const state = Object.assign({
        clientType,
        clientId,
        clientSecret,
        onTokenCreated,
        strategyOptions,
        request
    });
    return Object.assign(auth.bind(null, state), {
        // @ts-expect-error not worth the extra code needed to appease TS
        hook: hook.bind(null, state)
    });
}
createOAuthUserAuth.VERSION = VERSION;
;
}}),
"[project]/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "createOAuthAppAuth": (()=>createOAuthAppAuth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/auth.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-client] (ecmascript)");
;
;
;
async function auth(state, authOptions) {
    if (authOptions.type === "oauth-app") {
        return {
            type: "oauth-app",
            clientId: state.clientId,
            clientSecret: state.clientSecret,
            clientType: state.clientType,
            headers: {
                authorization: `basic ${btoa(`${state.clientId}:${state.clientSecret}`)}`
            }
        };
    }
    if ("factory" in authOptions) {
        const { type, ...options } = {
            ...authOptions,
            ...state
        };
        return authOptions.factory(options);
    }
    const common = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.request,
        ...authOptions
    };
    const userAuth = state.clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"])({
        ...common,
        clientType: state.clientType
    }) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"])({
        ...common,
        clientType: state.clientType
    });
    return userAuth();
}
;
async function hook(state, request2, route, parameters) {
    let endpoint = request2.endpoint.merge(route, parameters);
    if (/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url)) {
        return request2(endpoint);
    }
    if (state.clientType === "github-app" && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["requiresBasicAuth"])(endpoint.url)) {
        throw new Error(`[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint.method} ${endpoint.url}" is not supported.`);
    }
    const credentials = btoa(`${state.clientId}:${state.clientSecret}`);
    endpoint.headers.authorization = `basic ${credentials}`;
    try {
        return await request2(endpoint);
    } catch (error) {
        if (error.status !== 401) throw error;
        error.message = `[@octokit/auth-oauth-app] "${endpoint.method} ${endpoint.url}" does not support clientId/clientSecret basic authentication.`;
        throw error;
    }
}
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
function createOAuthAppAuth(options) {
    const state = Object.assign({
        request: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].defaults({
            headers: {
                "user-agent": `octokit-auth-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
            }
        }),
        clientType: "oauth-app"
    }, options);
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}}),
"[project]/node_modules/universal-github-app-jwt/lib/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// we don't @ts-check here because it chokes on atob and btoa which are available in all modern JS runtime environments
/**
 * @param {string} privateKey
 * @returns {boolean}
 */ __turbopack_context__.s({
    "base64encode": (()=>base64encode),
    "getDERfromPEM": (()=>getDERfromPEM),
    "getEncodedMessage": (()=>getEncodedMessage),
    "isOpenSsh": (()=>isOpenSsh),
    "isPkcs1": (()=>isPkcs1),
    "string2ArrayBuffer": (()=>string2ArrayBuffer)
});
function isPkcs1(privateKey) {
    return privateKey.includes("-----BEGIN RSA PRIVATE KEY-----");
}
function isOpenSsh(privateKey) {
    return privateKey.includes("-----BEGIN OPENSSH PRIVATE KEY-----");
}
function string2ArrayBuffer(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for(let i = 0, strLen = str.length; i < strLen; i++){
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function getDERfromPEM(pem) {
    const pemB64 = pem.trim().split("\n").slice(1, -1) // Remove the --- BEGIN / END PRIVATE KEY ---
    .join("");
    const decoded = atob(pemB64);
    return string2ArrayBuffer(decoded);
}
function getEncodedMessage(header, payload) {
    return `${base64encodeJSON(header)}.${base64encodeJSON(payload)}`;
}
function base64encode(buffer) {
    var binary = "";
    var bytes = new Uint8Array(buffer);
    var len = bytes.byteLength;
    for(var i = 0; i < len; i++){
        binary += String.fromCharCode(bytes[i]);
    }
    return fromBase64(btoa(binary));
}
/**
 * @param {string} base64
 * @returns {string}
 */ function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @param {Record<string,unknown>} obj
 * @returns {string}
 */ function base64encodeJSON(obj) {
    return fromBase64(btoa(JSON.stringify(obj)));
}
}}),
"[project]/node_modules/universal-github-app-jwt/lib/crypto-native.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "convertPrivateKey": (()=>convertPrivateKey),
    "subtle": (()=>subtle)
});
const { subtle } = globalThis.crypto;
// no-op, unfortunately there is no way to transform from PKCS8 or OpenSSH to PKCS1 with WebCrypto
function convertPrivateKey(privateKey) {
    return privateKey;
}
;
}}),
"[project]/node_modules/universal-github-app-jwt/lib/get-token.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// we don't @ts-check here because it chokes crypto which is a global API in modern JS runtime environments
__turbopack_context__.s({
    "getToken": (()=>getToken)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-github-app-jwt/lib/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-github-app-jwt/lib/crypto-native.js [app-client] (ecmascript)");
;
;
async function getToken({ privateKey, payload }) {
    const convertedPrivateKey = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["convertPrivateKey"])(privateKey);
    // WebCrypto only supports PKCS#8, unfortunately
    /* c8 ignore start */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isPkcs1"])(convertedPrivateKey)) {
        throw new Error("[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
    }
    /* c8 ignore stop */ // WebCrypto does not support OpenSSH, unfortunately
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isOpenSsh"])(convertedPrivateKey)) {
        throw new Error("[universal-github-app-jwt] Private Key is in OpenSSH format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#private-key-formats");
    }
    const algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
            name: "SHA-256"
        }
    };
    /** @type {import('../internals').Header} */ const header = {
        alg: "RS256",
        typ: "JWT"
    };
    const privateKeyDER = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getDERfromPEM"])(convertedPrivateKey);
    const importedKey = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subtle"].importKey("pkcs8", privateKeyDER, algorithm, false, [
        "sign"
    ]);
    const encodedMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getEncodedMessage"])(header, payload);
    const encodedMessageArrBuf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["string2ArrayBuffer"])(encodedMessage);
    const signatureArrBuf = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$crypto$2d$native$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["subtle"].sign(algorithm.name, importedKey, encodedMessageArrBuf);
    const encodedSignature = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64encode"])(signatureArrBuf);
    return `${encodedMessage}.${encodedSignature}`;
}
}}),
"[project]/node_modules/universal-github-app-jwt/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// @ts-check
// @ts-ignore - #get-token is defined in "imports" in package.json
__turbopack_context__.s({
    "default": (()=>githubAppJwt)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$get$2d$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-github-app-jwt/lib/get-token.js [app-client] (ecmascript)");
;
async function githubAppJwt({ id, privateKey, now = Math.floor(Date.now() / 1000) }) {
    // Private keys are often times configured as environment variables, in which case line breaks are escaped using `\\n`.
    // Replace these here for convenience.
    const privateKeyWithNewlines = privateKey.replace(/\\n/g, '\n');
    // When creating a JSON Web Token, it sets the "issued at time" (iat) to 30s
    // in the past as we have seen people running situations where the GitHub API
    // claimed the iat would be in future. It turned out the clocks on the
    // different machine were not in sync.
    const nowWithSafetyMargin = now - 30;
    const expiration = nowWithSafetyMargin + 60 * 10; // JWT expiration time (10 minute maximum)
    const payload = {
        iat: nowWithSafetyMargin,
        exp: expiration,
        iss: id
    };
    const token = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$lib$2f$get$2d$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getToken"])({
        privateKey: privateKeyWithNewlines,
        payload
    });
    return {
        appId: id,
        expiration,
        token
    };
}
}}),
"[project]/node_modules/toad-cache/dist/toad-cache.mjs [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * toad-cache
 *
 * @copyright 2024 Igor Savin <kibertoad@gmail.com>
 * @license MIT
 * @version 3.7.0
 */ __turbopack_context__.s({
    "Fifo": (()=>FifoObject),
    "FifoMap": (()=>FifoMap),
    "FifoObject": (()=>FifoObject),
    "HitStatisticsRecord": (()=>HitStatisticsRecord),
    "Lru": (()=>LruObject),
    "LruHitStatistics": (()=>LruObjectHitStatistics),
    "LruMap": (()=>LruMap),
    "LruObject": (()=>LruObject),
    "LruObjectHitStatistics": (()=>LruObjectHitStatistics)
});
class FifoMap {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    get size() {
        return this.items.size;
    }
    clear() {
        this.items = new Map();
        this.first = null;
        this.last = null;
    }
    delete(key) {
        if (this.items.has(key)) {
            const deletedItem = this.items.get(key);
            this.items.delete(key);
            if (deletedItem.prev !== null) {
                deletedItem.prev.next = deletedItem.next;
            }
            if (deletedItem.next !== null) {
                deletedItem.next.prev = deletedItem.prev;
            }
            if (this.first === deletedItem) {
                this.first = deletedItem.next;
            }
            if (this.last === deletedItem) {
                this.last = deletedItem.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            this.items.delete(item.key);
            if (this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (this.items.has(key)) {
            return this.items.get(key).expiry;
        }
    }
    get(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return this.items.keys();
    }
    set(key, value) {
        // Replace existing item
        if (this.items.has(key)) {
            const item = this.items.get(key);
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items.set(key, item);
        if (this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class LruMap {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = new Map();
        this.last = null;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    get size() {
        return this.items.size;
    }
    bumpLru(item) {
        if (this.last === item) {
            return; // Item is already the last one, no need to bump
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
            this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
        this.last = item;
    }
    clear() {
        this.items = new Map();
        this.first = null;
        this.last = null;
    }
    delete(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            this.items.delete(key);
            if (item.prev !== null) {
                item.prev.next = item.next;
            }
            if (item.next !== null) {
                item.next.prev = item.prev;
            }
            if (this.first === item) {
                this.first = item.next;
            }
            if (this.last === item) {
                this.last = item.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            this.items.delete(item.key);
            if (this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (this.items.has(key)) {
            return this.items.get(key).expiry;
        }
    }
    get(key) {
        if (this.items.has(key)) {
            const item = this.items.get(key);
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return this.items.keys();
    }
    set(key, value) {
        // Replace existing item
        if (this.items.has(key)) {
            const item = this.items.get(key);
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            if (this.last !== item) {
                this.bumpLru(item);
            }
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items.set(key, item);
        if (this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class LruObject {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    bumpLru(item) {
        if (this.last === item) {
            return; // Item is already the last one, no need to bump
        }
        const last = this.last;
        const next = item.next;
        const prev = item.prev;
        if (this.first === item) {
            this.first = next;
        }
        item.next = null;
        item.prev = last;
        last.next = item;
        if (prev !== null) {
            prev.next = next;
        }
        if (next !== null) {
            next.prev = prev;
        }
        this.last = item;
    }
    clear() {
        this.items = Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
    }
    delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            delete this.items[key];
            this.size--;
            if (item.prev !== null) {
                item.prev.next = item.next;
            }
            if (item.next !== null) {
                item.next.prev = item.prev;
            }
            if (this.first === item) {
                this.first = item.next;
            }
            if (this.last === item) {
                this.last = item.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            delete this.items[item.key];
            if (--this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            return this.items[key].expiry;
        }
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return Object.keys(this.items);
    }
    set(key, value) {
        // Replace existing item
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            if (this.last !== item) {
                this.bumpLru(item);
            }
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items[key] = item;
        if (++this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
class HitStatisticsRecord {
    constructor(){
        this.records = {};
    }
    initForCache(cacheId, currentTimeStamp) {
        this.records[cacheId] = {
            [currentTimeStamp]: {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                invalidateOne: 0,
                invalidateAll: 0,
                sets: 0
            }
        };
    }
    resetForCache(cacheId) {
        for (let key of Object.keys(this.records[cacheId])){
            this.records[cacheId][key] = {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                invalidateOne: 0,
                invalidateAll: 0,
                sets: 0
            };
        }
    }
    getStatistics() {
        return this.records;
    }
} /**
 *
 * @param {Date} date
 * @returns {string}
 */ 
function getTimestamp(date) {
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
}
class HitStatistics {
    constructor(cacheId, statisticTtlInHours, globalStatisticsRecord){
        this.cacheId = cacheId;
        this.statisticTtlInHours = statisticTtlInHours;
        this.collectionStart = new Date();
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records = globalStatisticsRecord || new HitStatisticsRecord();
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
    get currentRecord() {
        // safety net
        /* c8 ignore next 14 */ if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
            this.records.records[this.cacheId][this.currentTimeStamp] = {
                cacheSize: 0,
                hits: 0,
                falsyHits: 0,
                emptyHits: 0,
                misses: 0,
                expirations: 0,
                evictions: 0,
                sets: 0,
                invalidateOne: 0,
                invalidateAll: 0
            };
        }
        return this.records.records[this.cacheId][this.currentTimeStamp];
    }
    hoursPassed() {
        return (Date.now() - this.collectionStart) / 1000 / 60 / 60;
    }
    addHit() {
        this.archiveIfNeeded();
        this.currentRecord.hits++;
    }
    addFalsyHit() {
        this.archiveIfNeeded();
        this.currentRecord.falsyHits++;
    }
    addEmptyHit() {
        this.archiveIfNeeded();
        this.currentRecord.emptyHits++;
    }
    addMiss() {
        this.archiveIfNeeded();
        this.currentRecord.misses++;
    }
    addEviction() {
        this.archiveIfNeeded();
        this.currentRecord.evictions++;
    }
    setCacheSize(currentSize) {
        this.archiveIfNeeded();
        this.currentRecord.cacheSize = currentSize;
    }
    addExpiration() {
        this.archiveIfNeeded();
        this.currentRecord.expirations++;
    }
    addSet() {
        this.archiveIfNeeded();
        this.currentRecord.sets++;
    }
    addInvalidateOne() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateOne++;
    }
    addInvalidateAll() {
        this.archiveIfNeeded();
        this.currentRecord.invalidateAll++;
    }
    getStatistics() {
        return this.records.getStatistics();
    }
    archiveIfNeeded() {
        if (this.hoursPassed() >= this.statisticTtlInHours) {
            this.collectionStart = new Date();
            this.currentTimeStamp = getTimestamp(this.collectionStart);
            this.records.initForCache(this.cacheId, this.currentTimeStamp);
        }
    }
}
class LruObjectHitStatistics extends LruObject {
    constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours){
        super(max || 1000, ttlInMsecs || 0);
        if (!cacheId) {
            throw new Error('Cache id is mandatory');
        }
        this.hitStatistics = new HitStatistics(cacheId, statisticTtlInHours !== undefined ? statisticTtlInHours : 24, globalStatisticsRecord);
    }
    getStatistics() {
        return this.hitStatistics.getStatistics();
    }
    set(key, value) {
        super.set(key, value);
        this.hitStatistics.addSet();
        this.hitStatistics.setCacheSize(this.size);
    }
    evict() {
        super.evict();
        this.hitStatistics.addEviction();
        this.hitStatistics.setCacheSize(this.size);
    }
    delete(key, isExpiration = false) {
        super.delete(key);
        if (!isExpiration) {
            this.hitStatistics.addInvalidateOne();
        }
        this.hitStatistics.setCacheSize(this.size);
    }
    clear() {
        super.clear();
        this.hitStatistics.addInvalidateAll();
        this.hitStatistics.setCacheSize(this.size);
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            // Item has already expired
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key, true);
                this.hitStatistics.addExpiration();
                return;
            }
            // Item is still fresh
            this.bumpLru(item);
            if (!item.value) {
                this.hitStatistics.addFalsyHit();
            }
            if (item.value === undefined || item.value === null || item.value === '') {
                this.hitStatistics.addEmptyHit();
            }
            this.hitStatistics.addHit();
            return item.value;
        }
        this.hitStatistics.addMiss();
    }
}
class FifoObject {
    constructor(max = 1000, ttlInMsecs = 0){
        if (isNaN(max) || max < 0) {
            throw new Error('Invalid max value');
        }
        if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
            throw new Error('Invalid ttl value');
        }
        this.first = null;
        this.items = Object.create(null);
        this.last = null;
        this.size = 0;
        this.max = max;
        this.ttl = ttlInMsecs;
    }
    clear() {
        this.items = Object.create(null);
        this.first = null;
        this.last = null;
        this.size = 0;
    }
    delete(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const deletedItem = this.items[key];
            delete this.items[key];
            this.size--;
            if (deletedItem.prev !== null) {
                deletedItem.prev.next = deletedItem.next;
            }
            if (deletedItem.next !== null) {
                deletedItem.next.prev = deletedItem.prev;
            }
            if (this.first === deletedItem) {
                this.first = deletedItem.next;
            }
            if (this.last === deletedItem) {
                this.last = deletedItem.prev;
            }
        }
    }
    deleteMany(keys) {
        for(var i = 0; i < keys.length; i++){
            this.delete(keys[i]);
        }
    }
    evict() {
        if (this.size > 0) {
            const item = this.first;
            delete this.items[item.key];
            if (--this.size === 0) {
                this.first = null;
                this.last = null;
            } else {
                this.first = item.next;
                this.first.prev = null;
            }
        }
    }
    expiresAt(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            return this.items[key].expiry;
        }
    }
    get(key) {
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            if (this.ttl > 0 && item.expiry <= Date.now()) {
                this.delete(key);
                return;
            }
            return item.value;
        }
    }
    getMany(keys) {
        const result = [];
        for(var i = 0; i < keys.length; i++){
            result.push(this.get(keys[i]));
        }
        return result;
    }
    keys() {
        return Object.keys(this.items);
    }
    set(key, value) {
        // Replace existing item
        if (Object.prototype.hasOwnProperty.call(this.items, key)) {
            const item = this.items[key];
            item.value = value;
            item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
            return;
        }
        // Add new item
        if (this.max > 0 && this.size === this.max) {
            this.evict();
        }
        const item = {
            expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
            key: key,
            prev: this.last,
            next: null,
            value
        };
        this.items[key] = item;
        if (++this.size === 1) {
            this.first = item;
        } else {
            this.last.next = item;
        }
        this.last = item;
    }
}
;
}}),
"[project]/node_modules/@octokit/auth-app/dist-node/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "createAppAuth": (()=>createAppAuth)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/request/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-client] (ecmascript) <locals>");
// pkg/dist-src/get-app-authentication.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-github-app-jwt/index.js [app-client] (ecmascript)");
// pkg/dist-src/cache.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$toad$2d$cache$2f$dist$2f$toad$2d$cache$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/toad-cache/dist/toad-cache.mjs [app-client] (ecmascript)");
// pkg/dist-src/hook.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-client] (ecmascript)");
;
;
;
;
async function getAppAuthentication({ appId, privateKey, timeDifference }) {
    try {
        const authOptions = {
            id: appId,
            privateKey
        };
        if (timeDifference) {
            Object.assign(authOptions, {
                now: Math.floor(Date.now() / 1e3) + timeDifference
            });
        }
        const appAuthentication = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$github$2d$app$2d$jwt$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(authOptions);
        return {
            type: "app",
            token: appAuthentication.token,
            appId: appAuthentication.appId,
            expiresAt: new Date(appAuthentication.expiration * 1e3).toISOString()
        };
    } catch (error) {
        if (privateKey === "-----BEGIN RSA PRIVATE KEY-----") {
            throw new Error("The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\n'");
        } else {
            throw error;
        }
    }
}
;
function getCache() {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$toad$2d$cache$2f$dist$2f$toad$2d$cache$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Lru"](// cache max. 15000 tokens, that will use less than 10mb memory
    15e3, // Cache for 1 minute less than GitHub expiry
    1e3 * 60 * 59);
}
async function get(cache, options) {
    const cacheKey = optionsToCacheKey(options);
    const result = await cache.get(cacheKey);
    if (!result) {
        return;
    }
    const [token, createdAt, expiresAt, repositorySelection, permissionsString, singleFileName] = result.split("|");
    const permissions = options.permissions || permissionsString.split(/,/).reduce((permissions2, string)=>{
        if (/!$/.test(string)) {
            permissions2[string.slice(0, -1)] = "write";
        } else {
            permissions2[string] = "read";
        }
        return permissions2;
    }, {});
    return {
        token,
        createdAt,
        expiresAt,
        permissions,
        repositoryIds: options.repositoryIds,
        repositoryNames: options.repositoryNames,
        singleFileName,
        repositorySelection
    };
}
async function set(cache, options, data) {
    const key = optionsToCacheKey(options);
    const permissionsString = options.permissions ? "" : Object.keys(data.permissions).map((name)=>`${name}${data.permissions[name] === "write" ? "!" : ""}`).join(",");
    const value = [
        data.token,
        data.createdAt,
        data.expiresAt,
        data.repositorySelection,
        permissionsString,
        data.singleFileName
    ].join("|");
    await cache.set(key, value);
}
function optionsToCacheKey({ installationId, permissions = {}, repositoryIds = [], repositoryNames = [] }) {
    const permissionsString = Object.keys(permissions).sort().map((name)=>permissions[name] === "read" ? name : `${name}!`).join(",");
    const repositoryIdsString = repositoryIds.sort().join(",");
    const repositoryNamesString = repositoryNames.join(",");
    return [
        installationId,
        repositoryIdsString,
        repositoryNamesString,
        permissionsString
    ].filter(Boolean).join("|");
}
// pkg/dist-src/to-token-authentication.js
function toTokenAuthentication({ installationId, token, createdAt, expiresAt, repositorySelection, permissions, repositoryIds, repositoryNames, singleFileName }) {
    return Object.assign({
        type: "token",
        tokenType: "installation",
        token,
        installationId,
        permissions,
        createdAt,
        expiresAt,
        repositorySelection
    }, repositoryIds ? {
        repositoryIds
    } : null, repositoryNames ? {
        repositoryNames
    } : null, singleFileName ? {
        singleFileName
    } : null);
}
// pkg/dist-src/get-installation-authentication.js
async function getInstallationAuthentication(state, options, customRequest) {
    const installationId = Number(options.installationId || state.installationId);
    if (!installationId) {
        throw new Error("[@octokit/auth-app] installationId option is required for installation authentication.");
    }
    if (options.factory) {
        const { type, factory, oauthApp, ...factoryAuthOptions } = {
            ...state,
            ...options
        };
        return factory(factoryAuthOptions);
    }
    const request = customRequest || state.request;
    return getInstallationAuthenticationConcurrently(state, {
        ...options,
        installationId
    }, request);
}
var pendingPromises = /* @__PURE__ */ new Map();
function getInstallationAuthenticationConcurrently(state, options, request) {
    const cacheKey = optionsToCacheKey(options);
    if (pendingPromises.has(cacheKey)) {
        return pendingPromises.get(cacheKey);
    }
    const promise = getInstallationAuthenticationImpl(state, options, request).finally(()=>pendingPromises.delete(cacheKey));
    pendingPromises.set(cacheKey, promise);
    return promise;
}
async function getInstallationAuthenticationImpl(state, options, request) {
    if (!options.refresh) {
        const result = await get(state.cache, options);
        if (result) {
            const { token: token2, createdAt: createdAt2, expiresAt: expiresAt2, permissions: permissions2, repositoryIds: repositoryIds2, repositoryNames: repositoryNames2, singleFileName: singleFileName2, repositorySelection: repositorySelection2 } = result;
            return toTokenAuthentication({
                installationId: options.installationId,
                token: token2,
                createdAt: createdAt2,
                expiresAt: expiresAt2,
                permissions: permissions2,
                repositorySelection: repositorySelection2,
                repositoryIds: repositoryIds2,
                repositoryNames: repositoryNames2,
                singleFileName: singleFileName2
            });
        }
    }
    const appAuthentication = await getAppAuthentication(state);
    const payload = {
        installation_id: options.installationId,
        mediaType: {
            previews: [
                "machine-man"
            ]
        },
        headers: {
            authorization: `bearer ${appAuthentication.token}`
        }
    };
    if (options.repositoryIds) {
        Object.assign(payload, {
            repository_ids: options.repositoryIds
        });
    }
    if (options.repositoryNames) {
        Object.assign(payload, {
            repositories: options.repositoryNames
        });
    }
    if (options.permissions) {
        Object.assign(payload, {
            permissions: options.permissions
        });
    }
    const { data: { token, expires_at: expiresAt, repositories, permissions: permissionsOptional, repository_selection: repositorySelectionOptional, single_file: singleFileName } } = await request("POST /app/installations/{installation_id}/access_tokens", payload);
    const permissions = permissionsOptional || {};
    const repositorySelection = repositorySelectionOptional || "all";
    const repositoryIds = repositories ? repositories.map((r)=>r.id) : void 0;
    const repositoryNames = repositories ? repositories.map((repo)=>repo.name) : void 0;
    const createdAt = /* @__PURE__ */ new Date().toISOString();
    const cacheOptions = {
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames
    };
    if (singleFileName) {
        Object.assign(payload, {
            singleFileName
        });
    }
    await set(state.cache, options, cacheOptions);
    const cacheData = {
        installationId: options.installationId,
        token,
        createdAt,
        expiresAt,
        repositorySelection,
        permissions,
        repositoryIds,
        repositoryNames
    };
    if (singleFileName) {
        Object.assign(cacheData, {
            singleFileName
        });
    }
    return toTokenAuthentication(cacheData);
}
// pkg/dist-src/auth.js
async function auth(state, authOptions) {
    switch(authOptions.type){
        case "app":
            return getAppAuthentication(state);
        case "oauth-app":
            return state.oauthApp({
                type: "oauth-app"
            });
        case "installation":
            authOptions;
            return getInstallationAuthentication(state, {
                ...authOptions,
                type: "installation"
            });
        case "oauth-user":
            return state.oauthApp(authOptions);
        default:
            throw new Error(`Invalid auth type: ${authOptions.type}`);
    }
}
;
;
// pkg/dist-src/requires-app-auth.js
var PATHS = [
    "/app",
    "/app/hook/config",
    "/app/hook/deliveries",
    "/app/hook/deliveries/{delivery_id}",
    "/app/hook/deliveries/{delivery_id}/attempts",
    "/app/installations",
    "/app/installations/{installation_id}",
    "/app/installations/{installation_id}/access_tokens",
    "/app/installations/{installation_id}/suspended",
    "/app/installation-requests",
    "/marketplace_listing/accounts/{account_id}",
    "/marketplace_listing/plan",
    "/marketplace_listing/plans",
    "/marketplace_listing/plans/{plan_id}/accounts",
    "/marketplace_listing/stubbed/accounts/{account_id}",
    "/marketplace_listing/stubbed/plan",
    "/marketplace_listing/stubbed/plans",
    "/marketplace_listing/stubbed/plans/{plan_id}/accounts",
    "/orgs/{org}/installation",
    "/repos/{owner}/{repo}/installation",
    "/users/{username}/installation"
];
function routeMatcher(paths) {
    const regexes = paths.map((p)=>p.split("/").map((c)=>c.startsWith("{") ? "(?:.+?)" : c).join("/"));
    const regex = `^(?:${regexes.map((r)=>`(?:${r})`).join("|")})$`;
    return new RegExp(regex, "i");
}
var REGEX = routeMatcher(PATHS);
function requiresAppAuth(url) {
    return !!url && REGEX.test(url.split("?")[0]);
}
// pkg/dist-src/hook.js
var FIVE_SECONDS_IN_MS = 5 * 1e3;
function isNotTimeSkewError(error) {
    return !(error.message.match(/'Expiration time' claim \('exp'\) must be a numeric value representing the future time at which the assertion expires/) || error.message.match(/'Issued at' claim \('iat'\) must be an Integer representing the time that the assertion was issued/));
}
async function hook(state, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    const url = endpoint.url;
    if (/\/login\/oauth\/access_token$/.test(url)) {
        return request(endpoint);
    }
    if (requiresAppAuth(url.replace(request.endpoint.DEFAULTS.baseUrl, ""))) {
        const { token: token2 } = await getAppAuthentication(state);
        endpoint.headers.authorization = `bearer ${token2}`;
        let response;
        try {
            response = await request(endpoint);
        } catch (error) {
            if (isNotTimeSkewError(error)) {
                throw error;
            }
            if (typeof error.response.headers.date === "undefined") {
                throw error;
            }
            const diff = Math.floor((Date.parse(error.response.headers.date) - Date.parse(/* @__PURE__ */ new Date().toString())) / 1e3);
            state.log.warn(error.message);
            state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);
            const { token: token3 } = await getAppAuthentication({
                ...state,
                timeDifference: diff
            });
            endpoint.headers.authorization = `bearer ${token3}`;
            return request(endpoint);
        }
        return response;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["requiresBasicAuth"])(url)) {
        const authentication = await state.oauthApp({
            type: "oauth-app"
        });
        endpoint.headers.authorization = authentication.headers.authorization;
        return request(endpoint);
    }
    const { token, createdAt } = await getInstallationAuthentication(state, // @ts-expect-error TBD
    {}, request.defaults({
        baseUrl: endpoint.baseUrl
    }));
    endpoint.headers.authorization = `token ${token}`;
    return sendRequestWithRetries(state, request, endpoint, createdAt);
}
async function sendRequestWithRetries(state, request, options, createdAt, retries = 0) {
    const timeSinceTokenCreationInMs = +/* @__PURE__ */ new Date() - +new Date(createdAt);
    try {
        return await request(options);
    } catch (error) {
        if (error.status !== 401) {
            throw error;
        }
        if (timeSinceTokenCreationInMs >= FIVE_SECONDS_IN_MS) {
            if (retries > 0) {
                error.message = `After ${retries} retries within ${timeSinceTokenCreationInMs / 1e3}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`;
            }
            throw error;
        }
        ++retries;
        const awaitTime = retries * 1e3;
        state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime / 1e3}s)`);
        await new Promise((resolve)=>setTimeout(resolve, awaitTime));
        return sendRequestWithRetries(state, request, options, createdAt, retries);
    }
}
// pkg/dist-src/version.js
var VERSION = "7.2.1";
;
function createAppAuth(options) {
    if (!options.appId) {
        throw new Error("[@octokit/auth-app] appId option is required");
    }
    if (!options.privateKey) {
        throw new Error("[@octokit/auth-app] privateKey option is required");
    }
    if ("installationId" in options && !options.installationId) {
        throw new Error("[@octokit/auth-app] installationId is set to a falsy value");
    }
    const log = Object.assign({
        warn: console.warn.bind(console)
    }, options.log);
    const request = options.request || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$request$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["request"].defaults({
        headers: {
            "user-agent": `octokit-auth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
        }
    });
    const state = Object.assign({
        request,
        cache: getCache()
    }, options, options.installationId ? {
        installationId: Number(options.installationId)
    } : {}, {
        log,
        oauthApp: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createOAuthAppAuth"])({
            clientType: "github-app",
            clientId: options.clientId || "",
            clientSecret: options.clientSecret || "",
            request
        })
    });
    return Object.assign(auth.bind(null, state), {
        hook: hook.bind(null, state)
    });
}
;
}}),
"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/@octokit/auth-unauthenticated/dist-web/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/auth.js
__turbopack_context__.s({
    "createUnauthenticatedAuth": (()=>createUnauthenticatedAuth)
});
async function auth(reason) {
    return {
        type: "unauthenticated",
        reason
    };
}
// pkg/dist-src/is-rate-limit-error.js
function isRateLimitError(error) {
    if (error.status !== 403) {
        return false;
    }
    if (!error.response) {
        return false;
    }
    return error.response.headers["x-ratelimit-remaining"] === "0";
}
// pkg/dist-src/is-abuse-limit-error.js
var REGEX_ABUSE_LIMIT_MESSAGE = /\babuse\b/i;
function isAbuseLimitError(error) {
    if (error.status !== 403) {
        return false;
    }
    return REGEX_ABUSE_LIMIT_MESSAGE.test(error.message);
}
// pkg/dist-src/hook.js
async function hook(reason, request, route, parameters) {
    const endpoint = request.endpoint.merge(route, parameters);
    return request(endpoint).catch((error)=>{
        if (error.status === 404) {
            error.message = `Not found. May be due to lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (isRateLimitError(error)) {
            error.message = `API rate limit exceeded. This maybe caused by the lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (isAbuseLimitError(error)) {
            error.message = `You have triggered an abuse detection mechanism. This maybe caused by the lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (error.status === 401) {
            error.message = `Unauthorized. "${endpoint.method} ${endpoint.url}" failed most likely due to lack of authentication. Reason: ${reason}`;
            throw error;
        }
        if (error.status >= 400 && error.status < 500) {
            error.message = error.message.replace(/\.?$/, `. May be caused by lack of authentication (${reason}).`);
        }
        throw error;
    });
}
// pkg/dist-src/index.js
var createUnauthenticatedAuth = function createUnauthenticatedAuth2(options) {
    if (!options || !options.reason) {
        throw new Error("[@octokit/auth-unauthenticated] No reason passed to createUnauthenticatedAuth");
    }
    return Object.assign(auth.bind(null, options.reason), {
        hook: hook.bind(null, options.reason)
    });
};
;
}}),
"[project]/node_modules/@octokit/oauth-app/dist-node/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "OAuthApp": (()=>OAuthApp),
    "createAWSLambdaAPIGatewayV2Handler": (()=>createAWSLambdaAPIGatewayV2Handler),
    "createNodeMiddleware": (()=>createNodeMiddleware),
    "createWebWorkerHandler": (()=>createWebWorkerHandler),
    "handleRequest": (()=>handleRequest),
    "sendNodeResponse": (()=>sendResponse),
    "unknownRouteResponse": (()=>unknownRouteResponse)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-app/dist-bundle/index.js [app-client] (ecmascript) <locals>");
// pkg/dist-src/oauth-app-octokit.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/core/dist-src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/universal-user-agent/index.js [app-client] (ecmascript)");
// pkg/dist-src/methods/get-user-octokit.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-oauth-user/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/methods/get-web-flow-authorization-url.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-methods/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-unauthenticated/dist-web/index.js [app-client] (ecmascript)");
;
// pkg/dist-src/version.js
var VERSION = "7.1.6";
// pkg/dist-src/add-event-handler.js
function addEventHandler(state, eventName, eventHandler) {
    if (Array.isArray(eventName)) {
        for (const singleEventName of eventName){
            addEventHandler(state, singleEventName, eventHandler);
        }
        return;
    }
    if (!state.eventHandlers[eventName]) {
        state.eventHandlers[eventName] = [];
    }
    state.eventHandlers[eventName].push(eventHandler);
}
;
;
var OAuthAppOctokit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Octokit"].defaults({
    userAgent: `octokit-oauth-app.js/${VERSION} ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$universal$2d$user$2d$agent$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getUserAgent"])()}`
});
;
// pkg/dist-src/emit-event.js
async function emitEvent(state, context) {
    const { name, action } = context;
    if (state.eventHandlers[`${name}.${action}`]) {
        for (const eventHandler of state.eventHandlers[`${name}.${action}`]){
            await eventHandler(context);
        }
    }
    if (state.eventHandlers[name]) {
        for (const eventHandler of state.eventHandlers[name]){
            await eventHandler(context);
        }
    }
}
// pkg/dist-src/methods/get-user-octokit.js
async function getUserOctokitWithState(state, options) {
    return state.octokit.auth({
        type: "oauth-user",
        ...options,
        async factory (options2) {
            const octokit = new state.Octokit({
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
                auth: options2
            });
            const authentication = await octokit.auth({
                type: "get"
            });
            await emitEvent(state, {
                name: "token",
                action: "created",
                token: authentication.token,
                scopes: authentication.scopes,
                authentication,
                octokit
            });
            return octokit;
        }
    });
}
;
function getWebFlowAuthorizationUrlWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        request: state.octokit.request,
        ...options,
        allowSignup: state.allowSignup ?? options.allowSignup,
        redirectUrl: options.redirectUrl ?? state.redirectUrl,
        scopes: options.scopes ?? state.defaultScopes
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebFlowAuthorizationUrl"])({
        clientType: state.clientType,
        ...optionsWithDefaults
    });
}
;
async function createTokenWithState(state, options) {
    const authentication = await state.octokit.auth({
        type: "oauth-user",
        ...options
    });
    await emitEvent(state, {
        name: "token",
        action: "created",
        token: authentication.token,
        scopes: authentication.scopes,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: authentication.token,
                scopes: authentication.scopes,
                refreshToken: authentication.refreshToken,
                expiresAt: authentication.expiresAt,
                refreshTokenExpiresAt: authentication.refreshTokenExpiresAt
            }
        })
    });
    return {
        authentication
    };
}
;
async function checkTokenWithState(state, options) {
    const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkToken"])({
        // @ts-expect-error not worth the extra code to appease TS
        clientType: state.clientType,
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    });
    Object.assign(result.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    return result;
}
;
;
async function resetTokenWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    if (state.clientType === "oauth-app") {
        const response2 = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resetToken"])({
            clientType: "oauth-app",
            ...optionsWithDefaults
        });
        const authentication2 = Object.assign(response2.authentication, {
            type: "token",
            tokenType: "oauth"
        });
        await emitEvent(state, {
            name: "token",
            action: "reset",
            token: response2.authentication.token,
            scopes: response2.authentication.scopes || void 0,
            authentication: authentication2,
            octokit: new state.Octokit({
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
                auth: {
                    clientType: state.clientType,
                    clientId: state.clientId,
                    clientSecret: state.clientSecret,
                    token: response2.authentication.token,
                    scopes: response2.authentication.scopes
                }
            })
        });
        return {
            ...response2,
            authentication: authentication2
        };
    }
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resetToken"])({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "reset",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function refreshTokenWithState(state, options) {
    if (state.clientType === "oauth-app") {
        throw new Error("[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps");
    }
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["refreshToken"])({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        refreshToken: options.refreshToken
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "refreshed",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function scopeTokenWithState(state, options) {
    if (state.clientType === "oauth-app") {
        throw new Error("[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps");
    }
    const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scopeToken"])({
        clientType: "github-app",
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    });
    const authentication = Object.assign(response.authentication, {
        type: "token",
        tokenType: "oauth"
    });
    await emitEvent(state, {
        name: "token",
        action: "scoped",
        token: response.authentication.token,
        authentication,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$user$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createOAuthUserAuth"],
            auth: {
                clientType: state.clientType,
                clientId: state.clientId,
                clientSecret: state.clientSecret,
                token: response.authentication.token
            }
        })
    });
    return {
        ...response,
        authentication
    };
}
;
;
async function deleteTokenWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    const response = state.clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteToken"])({
        clientType: "oauth-app",
        ...optionsWithDefaults
    }) : /* v8 ignore next 4 */ await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteToken"])({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "token.deleted" event. The access for the token has been revoked.`
            }
        })
    });
    return response;
}
;
;
async function deleteAuthorizationWithState(state, options) {
    const optionsWithDefaults = {
        clientId: state.clientId,
        clientSecret: state.clientSecret,
        request: state.octokit.request,
        ...options
    };
    const response = state.clientType === "oauth-app" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteAuthorization"])({
        clientType: "oauth-app",
        ...optionsWithDefaults
    }) : /* v8 ignore next 4 */ await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$methods$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["deleteAuthorization"])({
        clientType: "github-app",
        ...optionsWithDefaults
    });
    await emitEvent(state, {
        name: "token",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "token.deleted" event. The access for the token has been revoked.`
            }
        })
    });
    await emitEvent(state, {
        name: "authorization",
        action: "deleted",
        token: options.token,
        octokit: new state.Octokit({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
            auth: {
                reason: `Handling "authorization.deleted" event. The access for the app has been revoked.`
            }
        })
    });
    return response;
}
// pkg/dist-src/middleware/unknown-route-response.js
function unknownRouteResponse(request) {
    return {
        status: 404,
        headers: {
            "content-type": "application/json"
        },
        text: JSON.stringify({
            error: `Unknown route: ${request.method} ${request.url}`
        })
    };
}
// pkg/dist-src/middleware/handle-request.js
async function handleRequest(app, { pathPrefix = "/api/github/oauth" }, request) {
    let { pathname } = new URL(request.url, "http://localhost");
    if (!pathname.startsWith(`${pathPrefix}/`)) {
        return void 0;
    }
    if (request.method === "OPTIONS") {
        return {
            status: 200,
            headers: {
                "access-control-allow-origin": "*",
                "access-control-allow-methods": "*",
                "access-control-allow-headers": "Content-Type, User-Agent, Authorization"
            }
        };
    }
    pathname = pathname.slice(pathPrefix.length + 1);
    const route = [
        request.method,
        pathname
    ].join(" ");
    const routes = {
        getLogin: `GET login`,
        getCallback: `GET callback`,
        createToken: `POST token`,
        getToken: `GET token`,
        patchToken: `PATCH token`,
        patchRefreshToken: `PATCH refresh-token`,
        scopeToken: `POST token/scoped`,
        deleteToken: `DELETE token`,
        deleteGrant: `DELETE grant`
    };
    if (!Object.values(routes).includes(route)) {
        return unknownRouteResponse(request);
    }
    let json;
    try {
        const text = await request.text();
        json = text ? JSON.parse(text) : {};
    } catch (error) {
        return {
            status: 400,
            headers: {
                "content-type": "application/json",
                "access-control-allow-origin": "*"
            },
            text: JSON.stringify({
                error: "[@octokit/oauth-app] request error"
            })
        };
    }
    const { searchParams } = new URL(request.url, "http://localhost");
    const query = Object.fromEntries(searchParams);
    const headers = request.headers;
    try {
        if (route === routes.getLogin) {
            const authOptions = {};
            if (query.state) {
                Object.assign(authOptions, {
                    state: query.state
                });
            }
            if (query.scopes) {
                Object.assign(authOptions, {
                    scopes: query.scopes.split(",")
                });
            }
            if (query.allowSignup) {
                Object.assign(authOptions, {
                    allowSignup: query.allowSignup === "true"
                });
            }
            if (query.redirectUrl) {
                Object.assign(authOptions, {
                    redirectUrl: query.redirectUrl
                });
            }
            const { url } = app.getWebFlowAuthorizationUrl(authOptions);
            return {
                status: 302,
                headers: {
                    location: url
                }
            };
        }
        if (route === routes.getCallback) {
            if (query.error) {
                throw new Error(`[@octokit/oauth-app] ${query.error} ${query.error_description}`);
            }
            if (!query.code) {
                throw new Error('[@octokit/oauth-app] "code" parameter is required');
            }
            const { authentication: { token: token2 } } = await app.createToken({
                code: query.code
            });
            return {
                status: 200,
                headers: {
                    "content-type": "text/html"
                },
                text: `<h1>Token created successfully</h1>

<p>Your token is: <strong>${token2}</strong>. Copy it now as it cannot be shown again.</p>`
            };
        }
        if (route === routes.createToken) {
            const { code, redirectUrl } = json;
            if (!code) {
                throw new Error('[@octokit/oauth-app] "code" parameter is required');
            }
            const result = await app.createToken({
                code,
                redirectUrl
            });
            delete result.authentication.clientSecret;
            return {
                status: 201,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.getToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.checkToken({
                token: token2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.patchToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.resetToken({
                token: token2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.patchRefreshToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const { refreshToken: refreshToken2 } = json;
            if (!refreshToken2) {
                throw new Error("[@octokit/oauth-app] refreshToken must be sent in request body");
            }
            const result = await app.refreshToken({
                refreshToken: refreshToken2
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.scopeToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            const result = await app.scopeToken({
                token: token2,
                ...json
            });
            delete result.authentication.clientSecret;
            return {
                status: 200,
                headers: {
                    "content-type": "application/json",
                    "access-control-allow-origin": "*"
                },
                text: JSON.stringify(result)
            };
        }
        if (route === routes.deleteToken) {
            const token2 = headers.authorization?.substr("token ".length);
            if (!token2) {
                throw new Error('[@octokit/oauth-app] "Authorization" header is required');
            }
            await app.deleteToken({
                token: token2
            });
            return {
                status: 204,
                headers: {
                    "access-control-allow-origin": "*"
                }
            };
        }
        const token = headers.authorization?.substr("token ".length);
        if (!token) {
            throw new Error('[@octokit/oauth-app] "Authorization" header is required');
        }
        await app.deleteAuthorization({
            token
        });
        return {
            status: 204,
            headers: {
                "access-control-allow-origin": "*"
            }
        };
    } catch (error) {
        return {
            status: 400,
            headers: {
                "content-type": "application/json",
                "access-control-allow-origin": "*"
            },
            text: JSON.stringify({
                error: error.message
            })
        };
    }
}
// pkg/dist-src/middleware/node/parse-request.js
function parseRequest(request) {
    const { method, url, headers } = request;
    async function text() {
        const text2 = await new Promise((resolve, reject)=>{
            let bodyChunks = [];
            request.on("error", reject).on("data", (chunk)=>bodyChunks.push(chunk)).on("end", ()=>resolve(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(bodyChunks).toString()));
        });
        return text2;
    }
    return {
        method,
        url,
        headers,
        text
    };
}
// pkg/dist-src/middleware/node/send-response.js
function sendResponse(octokitResponse, response) {
    response.writeHead(octokitResponse.status, octokitResponse.headers);
    response.end(octokitResponse.text);
}
// pkg/dist-src/middleware/node/index.js
function createNodeMiddleware(app, options = {}) {
    return async function(request, response, next) {
        const octokitRequest = await parseRequest(request);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        if (octokitResponse) {
            sendResponse(octokitResponse, response);
            return true;
        } else {
            next?.();
            return false;
        }
    };
}
// pkg/dist-src/middleware/web-worker/parse-request.js
function parseRequest2(request) {
    const headers = Object.fromEntries(request.headers.entries());
    return {
        method: request.method,
        url: request.url,
        headers,
        text: ()=>request.text()
    };
}
// pkg/dist-src/middleware/web-worker/send-response.js
function sendResponse2(octokitResponse) {
    const responseOptions = {
        status: octokitResponse.status
    };
    if (octokitResponse.headers) {
        Object.assign(responseOptions, {
            headers: octokitResponse.headers
        });
    }
    return new Response(octokitResponse.text, responseOptions);
}
// pkg/dist-src/middleware/web-worker/index.js
function createWebWorkerHandler(app, options = {}) {
    return async function(request) {
        const octokitRequest = await parseRequest2(request);
        const octokitResponse = await handleRequest(app, options, octokitRequest);
        return octokitResponse ? sendResponse2(octokitResponse) : void 0;
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2-parse-request.js
function parseRequest3(request) {
    const { method } = request.requestContext.http;
    let url = request.rawPath;
    const { stage } = request.requestContext;
    if (url.startsWith("/" + stage)) url = url.substring(stage.length + 1);
    if (request.rawQueryString) url += "?" + request.rawQueryString;
    const headers = request.headers;
    const text = async ()=>request.body || "";
    return {
        method,
        url,
        headers,
        text
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2-send-response.js
function sendResponse3(octokitResponse) {
    return {
        statusCode: octokitResponse.status,
        headers: octokitResponse.headers,
        body: octokitResponse.text
    };
}
// pkg/dist-src/middleware/aws-lambda/api-gateway-v2.js
function createAWSLambdaAPIGatewayV2Handler(app, options = {}) {
    return async function(event) {
        const request = parseRequest3(event);
        const response = await handleRequest(app, options, request);
        return response ? sendResponse3(response) : void 0;
    };
}
// pkg/dist-src/index.js
var OAuthApp = class {
    static VERSION = VERSION;
    static defaults(defaults) {
        const OAuthAppWithDefaults = class extends this {
            constructor(...args){
                super({
                    ...defaults,
                    ...args[0]
                });
            }
        };
        return OAuthAppWithDefaults;
    }
    constructor(options){
        const Octokit2 = options.Octokit || OAuthAppOctokit;
        this.type = options.clientType || "oauth-app";
        const octokit = new Octokit2({
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$oauth$2d$app$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createOAuthAppAuth"],
            auth: {
                clientType: this.type,
                clientId: options.clientId,
                clientSecret: options.clientSecret
            }
        });
        const state = {
            clientType: this.type,
            clientId: options.clientId,
            clientSecret: options.clientSecret,
            // @ts-expect-error defaultScopes not permitted for GitHub Apps
            defaultScopes: options.defaultScopes || [],
            allowSignup: options.allowSignup,
            baseUrl: options.baseUrl,
            redirectUrl: options.redirectUrl,
            log: options.log,
            Octokit: Octokit2,
            octokit,
            eventHandlers: {}
        };
        this.on = addEventHandler.bind(null, state);
        this.octokit = octokit;
        this.getUserOctokit = getUserOctokitWithState.bind(null, state);
        this.getWebFlowAuthorizationUrl = getWebFlowAuthorizationUrlWithState.bind(null, state);
        this.createToken = createTokenWithState.bind(null, state);
        this.checkToken = checkTokenWithState.bind(null, state);
        this.resetToken = resetTokenWithState.bind(null, state);
        this.refreshToken = refreshTokenWithState.bind(null, state);
        this.scopeToken = scopeTokenWithState.bind(null, state);
        this.deleteToken = deleteTokenWithState.bind(null, state);
        this.deleteAuthorization = deleteAuthorizationWithState.bind(null, state);
    }
    // assigned during constructor
    type;
    on;
    octokit;
    getUserOctokit;
    getWebFlowAuthorizationUrl;
    createToken;
    checkToken;
    resetToken;
    refreshToken;
    scopeToken;
    deleteToken;
    deleteAuthorization;
};
;
}}),
"[project]/node_modules/@octokit/webhooks-methods/dist-web/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/web.js
__turbopack_context__.s({
    "sign": (()=>sign),
    "verify": (()=>verify),
    "verifyWithFallback": (()=>verifyWithFallback)
});
var enc = new TextEncoder();
function hexToUInt8Array(string) {
    const pairs = string.match(/[\dA-F]{2}/gi);
    const integers = pairs.map(function(s) {
        return parseInt(s, 16);
    });
    return new Uint8Array(integers);
}
function UInt8ArrayToHex(signature) {
    return Array.prototype.map.call(new Uint8Array(signature), (x)=>x.toString(16).padStart(2, "0")).join("");
}
async function importKey(secret) {
    return crypto.subtle.importKey("raw", // raw format of the key - should be Uint8Array
    enc.encode(secret), {
        // algorithm details
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, false, // export = false
    [
        "sign",
        "verify"
    ]);
}
async function sign(secret, payload) {
    if (!secret || !payload) {
        throw new TypeError("[@octokit/webhooks-methods] secret & payload required for sign()");
    }
    if (typeof payload !== "string") {
        throw new TypeError("[@octokit/webhooks-methods] payload must be a string");
    }
    const algorithm = "sha256";
    const signature = await crypto.subtle.sign("HMAC", await importKey(secret), enc.encode(payload));
    return `${algorithm}=${UInt8ArrayToHex(signature)}`;
}
async function verify(secret, eventPayload, signature) {
    if (!secret || !eventPayload || !signature) {
        throw new TypeError("[@octokit/webhooks-methods] secret, eventPayload & signature required");
    }
    if (typeof eventPayload !== "string") {
        throw new TypeError("[@octokit/webhooks-methods] eventPayload must be a string");
    }
    const algorithm = "sha256";
    return await crypto.subtle.verify("HMAC", await importKey(secret), hexToUInt8Array(signature.replace(`${algorithm}=`, "")), enc.encode(eventPayload));
}
async function verifyWithFallback(secret, payload, signature, additionalSecrets) {
    const firstPass = await verify(secret, payload, signature);
    if (firstPass) {
        return true;
    }
    if (additionalSecrets !== void 0) {
        for (const s of additionalSecrets){
            const v = await verify(s, payload, signature);
            if (v) {
                return v;
            }
        }
    }
    return false;
}
;
}}),
"[project]/node_modules/@octokit/webhooks/dist-bundle/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/createLogger.js
__turbopack_context__.s({
    "Webhooks": (()=>Webhooks),
    "createEventHandler": (()=>createEventHandler),
    "createNodeMiddleware": (()=>createNodeMiddleware),
    "createWebMiddleware": (()=>createWebMiddleware),
    "emitterEventNames": (()=>emitterEventNames)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
// pkg/dist-src/index.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/webhooks-methods/dist-web/index.js [app-client] (ecmascript)");
var createLogger = (logger)=>({
        debug: ()=>{},
        info: ()=>{},
        warn: console.warn.bind(console),
        error: console.error.bind(console),
        ...logger
    });
// pkg/dist-src/generated/webhook-names.js
var emitterEventNames = [
    "branch_protection_configuration",
    "branch_protection_configuration.disabled",
    "branch_protection_configuration.enabled",
    "branch_protection_rule",
    "branch_protection_rule.created",
    "branch_protection_rule.deleted",
    "branch_protection_rule.edited",
    "check_run",
    "check_run.completed",
    "check_run.created",
    "check_run.requested_action",
    "check_run.rerequested",
    "check_suite",
    "check_suite.completed",
    "check_suite.requested",
    "check_suite.rerequested",
    "code_scanning_alert",
    "code_scanning_alert.appeared_in_branch",
    "code_scanning_alert.closed_by_user",
    "code_scanning_alert.created",
    "code_scanning_alert.fixed",
    "code_scanning_alert.reopened",
    "code_scanning_alert.reopened_by_user",
    "commit_comment",
    "commit_comment.created",
    "create",
    "custom_property",
    "custom_property.created",
    "custom_property.deleted",
    "custom_property.promote_to_enterprise",
    "custom_property.updated",
    "custom_property_values",
    "custom_property_values.updated",
    "delete",
    "dependabot_alert",
    "dependabot_alert.auto_dismissed",
    "dependabot_alert.auto_reopened",
    "dependabot_alert.created",
    "dependabot_alert.dismissed",
    "dependabot_alert.fixed",
    "dependabot_alert.reintroduced",
    "dependabot_alert.reopened",
    "deploy_key",
    "deploy_key.created",
    "deploy_key.deleted",
    "deployment",
    "deployment.created",
    "deployment_protection_rule",
    "deployment_protection_rule.requested",
    "deployment_review",
    "deployment_review.approved",
    "deployment_review.rejected",
    "deployment_review.requested",
    "deployment_status",
    "deployment_status.created",
    "discussion",
    "discussion.answered",
    "discussion.category_changed",
    "discussion.closed",
    "discussion.created",
    "discussion.deleted",
    "discussion.edited",
    "discussion.labeled",
    "discussion.locked",
    "discussion.pinned",
    "discussion.reopened",
    "discussion.transferred",
    "discussion.unanswered",
    "discussion.unlabeled",
    "discussion.unlocked",
    "discussion.unpinned",
    "discussion_comment",
    "discussion_comment.created",
    "discussion_comment.deleted",
    "discussion_comment.edited",
    "fork",
    "github_app_authorization",
    "github_app_authorization.revoked",
    "gollum",
    "installation",
    "installation.created",
    "installation.deleted",
    "installation.new_permissions_accepted",
    "installation.suspend",
    "installation.unsuspend",
    "installation_repositories",
    "installation_repositories.added",
    "installation_repositories.removed",
    "installation_target",
    "installation_target.renamed",
    "issue_comment",
    "issue_comment.created",
    "issue_comment.deleted",
    "issue_comment.edited",
    "issues",
    "issues.assigned",
    "issues.closed",
    "issues.deleted",
    "issues.demilestoned",
    "issues.edited",
    "issues.labeled",
    "issues.locked",
    "issues.milestoned",
    "issues.opened",
    "issues.pinned",
    "issues.reopened",
    "issues.transferred",
    "issues.typed",
    "issues.unassigned",
    "issues.unlabeled",
    "issues.unlocked",
    "issues.unpinned",
    "issues.untyped",
    "label",
    "label.created",
    "label.deleted",
    "label.edited",
    "marketplace_purchase",
    "marketplace_purchase.cancelled",
    "marketplace_purchase.changed",
    "marketplace_purchase.pending_change",
    "marketplace_purchase.pending_change_cancelled",
    "marketplace_purchase.purchased",
    "member",
    "member.added",
    "member.edited",
    "member.removed",
    "membership",
    "membership.added",
    "membership.removed",
    "merge_group",
    "merge_group.checks_requested",
    "merge_group.destroyed",
    "meta",
    "meta.deleted",
    "milestone",
    "milestone.closed",
    "milestone.created",
    "milestone.deleted",
    "milestone.edited",
    "milestone.opened",
    "org_block",
    "org_block.blocked",
    "org_block.unblocked",
    "organization",
    "organization.deleted",
    "organization.member_added",
    "organization.member_invited",
    "organization.member_removed",
    "organization.renamed",
    "package",
    "package.published",
    "package.updated",
    "page_build",
    "personal_access_token_request",
    "personal_access_token_request.approved",
    "personal_access_token_request.cancelled",
    "personal_access_token_request.created",
    "personal_access_token_request.denied",
    "ping",
    "project",
    "project.closed",
    "project.created",
    "project.deleted",
    "project.edited",
    "project.reopened",
    "project_card",
    "project_card.converted",
    "project_card.created",
    "project_card.deleted",
    "project_card.edited",
    "project_card.moved",
    "project_column",
    "project_column.created",
    "project_column.deleted",
    "project_column.edited",
    "project_column.moved",
    "projects_v2",
    "projects_v2.closed",
    "projects_v2.created",
    "projects_v2.deleted",
    "projects_v2.edited",
    "projects_v2.reopened",
    "projects_v2_item",
    "projects_v2_item.archived",
    "projects_v2_item.converted",
    "projects_v2_item.created",
    "projects_v2_item.deleted",
    "projects_v2_item.edited",
    "projects_v2_item.reordered",
    "projects_v2_item.restored",
    "projects_v2_status_update",
    "projects_v2_status_update.created",
    "projects_v2_status_update.deleted",
    "projects_v2_status_update.edited",
    "public",
    "pull_request",
    "pull_request.assigned",
    "pull_request.auto_merge_disabled",
    "pull_request.auto_merge_enabled",
    "pull_request.closed",
    "pull_request.converted_to_draft",
    "pull_request.demilestoned",
    "pull_request.dequeued",
    "pull_request.edited",
    "pull_request.enqueued",
    "pull_request.labeled",
    "pull_request.locked",
    "pull_request.milestoned",
    "pull_request.opened",
    "pull_request.ready_for_review",
    "pull_request.reopened",
    "pull_request.review_request_removed",
    "pull_request.review_requested",
    "pull_request.synchronize",
    "pull_request.unassigned",
    "pull_request.unlabeled",
    "pull_request.unlocked",
    "pull_request_review",
    "pull_request_review.dismissed",
    "pull_request_review.edited",
    "pull_request_review.submitted",
    "pull_request_review_comment",
    "pull_request_review_comment.created",
    "pull_request_review_comment.deleted",
    "pull_request_review_comment.edited",
    "pull_request_review_thread",
    "pull_request_review_thread.resolved",
    "pull_request_review_thread.unresolved",
    "push",
    "registry_package",
    "registry_package.published",
    "registry_package.updated",
    "release",
    "release.created",
    "release.deleted",
    "release.edited",
    "release.prereleased",
    "release.published",
    "release.released",
    "release.unpublished",
    "repository",
    "repository.archived",
    "repository.created",
    "repository.deleted",
    "repository.edited",
    "repository.privatized",
    "repository.publicized",
    "repository.renamed",
    "repository.transferred",
    "repository.unarchived",
    "repository_advisory",
    "repository_advisory.published",
    "repository_advisory.reported",
    "repository_dispatch",
    "repository_dispatch.sample.collected",
    "repository_import",
    "repository_ruleset",
    "repository_ruleset.created",
    "repository_ruleset.deleted",
    "repository_ruleset.edited",
    "repository_vulnerability_alert",
    "repository_vulnerability_alert.create",
    "repository_vulnerability_alert.dismiss",
    "repository_vulnerability_alert.reopen",
    "repository_vulnerability_alert.resolve",
    "secret_scanning_alert",
    "secret_scanning_alert.created",
    "secret_scanning_alert.publicly_leaked",
    "secret_scanning_alert.reopened",
    "secret_scanning_alert.resolved",
    "secret_scanning_alert.validated",
    "secret_scanning_alert_location",
    "secret_scanning_alert_location.created",
    "secret_scanning_scan",
    "secret_scanning_scan.completed",
    "security_advisory",
    "security_advisory.published",
    "security_advisory.updated",
    "security_advisory.withdrawn",
    "security_and_analysis",
    "sponsorship",
    "sponsorship.cancelled",
    "sponsorship.created",
    "sponsorship.edited",
    "sponsorship.pending_cancellation",
    "sponsorship.pending_tier_change",
    "sponsorship.tier_changed",
    "star",
    "star.created",
    "star.deleted",
    "status",
    "sub_issues",
    "sub_issues.parent_issue_added",
    "sub_issues.parent_issue_removed",
    "sub_issues.sub_issue_added",
    "sub_issues.sub_issue_removed",
    "team",
    "team.added_to_repository",
    "team.created",
    "team.deleted",
    "team.edited",
    "team.removed_from_repository",
    "team_add",
    "watch",
    "watch.started",
    "workflow_dispatch",
    "workflow_job",
    "workflow_job.completed",
    "workflow_job.in_progress",
    "workflow_job.queued",
    "workflow_job.waiting",
    "workflow_run",
    "workflow_run.completed",
    "workflow_run.in_progress",
    "workflow_run.requested"
];
// pkg/dist-src/event-handler/on.js
function handleEventHandlers(state, webhookName, handler) {
    if (!state.hooks[webhookName]) {
        state.hooks[webhookName] = [];
    }
    state.hooks[webhookName].push(handler);
}
function receiverOn(state, webhookNameOrNames, handler) {
    if (Array.isArray(webhookNameOrNames)) {
        webhookNameOrNames.forEach((webhookName)=>receiverOn(state, webhookName, handler));
        return;
    }
    if ([
        "*",
        "error"
    ].includes(webhookNameOrNames)) {
        const webhookName = webhookNameOrNames === "*" ? "any" : webhookNameOrNames;
        const message = `Using the "${webhookNameOrNames}" event with the regular Webhooks.on() function is not supported. Please use the Webhooks.on${webhookName.charAt(0).toUpperCase() + webhookName.slice(1)}() method instead`;
        throw new Error(message);
    }
    if (!emitterEventNames.includes(webhookNameOrNames)) {
        state.log.warn(`"${webhookNameOrNames}" is not a known webhook name (https://developer.github.com/v3/activity/events/types/)`);
    }
    handleEventHandlers(state, webhookNameOrNames, handler);
}
function receiverOnAny(state, handler) {
    handleEventHandlers(state, "*", handler);
}
function receiverOnError(state, handler) {
    handleEventHandlers(state, "error", handler);
}
// pkg/dist-src/event-handler/wrap-error-handler.js
function wrapErrorHandler(handler, error) {
    let returnValue;
    try {
        returnValue = handler(error);
    } catch (error2) {
        console.log('FATAL: Error occurred in "error" event handler');
        console.log(error2);
    }
    if (returnValue && returnValue.catch) {
        returnValue.catch((error2)=>{
            console.log('FATAL: Error occurred in "error" event handler');
            console.log(error2);
        });
    }
}
// pkg/dist-src/event-handler/receive.js
function getHooks(state, eventPayloadAction, eventName) {
    const hooks = [
        state.hooks[eventName],
        state.hooks["*"]
    ];
    if (eventPayloadAction) {
        hooks.unshift(state.hooks[`${eventName}.${eventPayloadAction}`]);
    }
    return [].concat(...hooks.filter(Boolean));
}
function receiverHandle(state, event) {
    const errorHandlers = state.hooks.error || [];
    if (event instanceof Error) {
        const error = Object.assign(new AggregateError([
            event
        ], event.message), {
            event
        });
        errorHandlers.forEach((handler)=>wrapErrorHandler(handler, error));
        return Promise.reject(error);
    }
    if (!event || !event.name) {
        const error = new Error("Event name not passed");
        throw new AggregateError([
            error
        ], error.message);
    }
    if (!event.payload) {
        const error = new Error("Event name not passed");
        throw new AggregateError([
            error
        ], error.message);
    }
    const hooks = getHooks(state, "action" in event.payload ? event.payload.action : null, event.name);
    if (hooks.length === 0) {
        return Promise.resolve();
    }
    const errors = [];
    const promises = hooks.map((handler)=>{
        let promise = Promise.resolve(event);
        if (state.transform) {
            promise = promise.then(state.transform);
        }
        return promise.then((event2)=>{
            return handler(event2);
        }).catch((error)=>errors.push(Object.assign(error, {
                event
            })));
    });
    return Promise.all(promises).then(()=>{
        if (errors.length === 0) {
            return;
        }
        const error = new AggregateError(errors, errors.map((error2)=>error2.message).join("\n"));
        Object.assign(error, {
            event
        });
        errorHandlers.forEach((handler)=>wrapErrorHandler(handler, error));
        throw error;
    });
}
// pkg/dist-src/event-handler/remove-listener.js
function removeListener(state, webhookNameOrNames, handler) {
    if (Array.isArray(webhookNameOrNames)) {
        webhookNameOrNames.forEach((webhookName)=>removeListener(state, webhookName, handler));
        return;
    }
    if (!state.hooks[webhookNameOrNames]) {
        return;
    }
    for(let i = state.hooks[webhookNameOrNames].length - 1; i >= 0; i--){
        if (state.hooks[webhookNameOrNames][i] === handler) {
            state.hooks[webhookNameOrNames].splice(i, 1);
            return;
        }
    }
}
// pkg/dist-src/event-handler/index.js
function createEventHandler(options) {
    const state = {
        hooks: {},
        log: createLogger(options && options.log)
    };
    if (options && options.transform) {
        state.transform = options.transform;
    }
    return {
        on: receiverOn.bind(null, state),
        onAny: receiverOnAny.bind(null, state),
        onError: receiverOnError.bind(null, state),
        removeListener: removeListener.bind(null, state),
        receive: receiverHandle.bind(null, state)
    };
}
;
;
async function verifyAndReceive(state, event) {
    const matchesSignature = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verifyWithFallback"])(state.secret, event.payload, event.signature, state.additionalSecrets).catch(()=>false);
    if (!matchesSignature) {
        const error = new Error("[@octokit/webhooks] signature does not match event payload and secret");
        return state.eventHandler.receive(Object.assign(error, {
            event,
            status: 400
        }));
    }
    let payload;
    try {
        payload = JSON.parse(event.payload);
    } catch (error) {
        error.message = "Invalid JSON";
        error.status = 400;
        throw new AggregateError([
            error
        ], error.message);
    }
    return state.eventHandler.receive({
        id: event.id,
        name: event.name,
        payload
    });
}
// pkg/dist-src/middleware/node/get-missing-headers.js
var WEBHOOK_HEADERS = [
    "x-github-event",
    "x-hub-signature-256",
    "x-github-delivery"
];
function getMissingHeaders(request) {
    return WEBHOOK_HEADERS.filter((header)=>!(header in request.headers));
}
// pkg/dist-src/middleware/node/get-payload.js
function getPayload(request) {
    if (typeof request.body === "object" && "rawBody" in request && request.rawBody instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) {
        return Promise.resolve(request.rawBody.toString("utf8"));
    } else if (typeof request.body === "string") {
        return Promise.resolve(request.body);
    }
    return new Promise((resolve, reject)=>{
        let data = [];
        request.on("error", (error)=>reject(new AggregateError([
                error
            ], error.message)));
        request.on("data", (chunk)=>data.push(chunk));
        request.on("end", ()=>// setImmediate improves the throughput by reducing the pressure from
            // the event loop
            setImmediate(resolve, data.length === 1 ? data[0].toString("utf8") : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat(data).toString("utf8")));
    });
}
// pkg/dist-src/middleware/node/on-unhandled-request-default.js
function onUnhandledRequestDefault(request, response) {
    response.writeHead(404, {
        "content-type": "application/json"
    });
    response.end(JSON.stringify({
        error: `Unknown route: ${request.method} ${request.url}`
    }));
}
// pkg/dist-src/middleware/node/middleware.js
async function middleware(webhooks, options, request, response, next) {
    let pathname;
    try {
        pathname = new URL(request.url, "http://localhost").pathname;
    } catch (error) {
        response.writeHead(422, {
            "content-type": "application/json"
        });
        response.end(JSON.stringify({
            error: `Request URL could not be parsed: ${request.url}`
        }));
        return true;
    }
    if (pathname !== options.path) {
        next?.();
        return false;
    } else if (request.method !== "POST") {
        onUnhandledRequestDefault(request, response);
        return true;
    }
    if (!request.headers["content-type"] || !request.headers["content-type"].startsWith("application/json")) {
        response.writeHead(415, {
            "content-type": "application/json",
            accept: "application/json"
        });
        response.end(JSON.stringify({
            error: `Unsupported "Content-Type" header value. Must be "application/json"`
        }));
        return true;
    }
    const missingHeaders = getMissingHeaders(request).join(", ");
    if (missingHeaders) {
        response.writeHead(400, {
            "content-type": "application/json"
        });
        response.end(JSON.stringify({
            error: `Required headers missing: ${missingHeaders}`
        }));
        return true;
    }
    const eventName = request.headers["x-github-event"];
    const signatureSHA256 = request.headers["x-hub-signature-256"];
    const id = request.headers["x-github-delivery"];
    options.log.debug(`${eventName} event received (id: ${id})`);
    let didTimeout = false;
    const timeout = setTimeout(()=>{
        didTimeout = true;
        response.statusCode = 202;
        response.end("still processing\n");
    }, 9e3).unref();
    try {
        const payload = await getPayload(request);
        await webhooks.verifyAndReceive({
            id,
            name: eventName,
            payload,
            signature: signatureSHA256
        });
        clearTimeout(timeout);
        if (didTimeout) return true;
        response.end("ok\n");
        return true;
    } catch (error) {
        clearTimeout(timeout);
        if (didTimeout) return true;
        const err = Array.from(error.errors)[0];
        const errorMessage = err.message ? `${err.name}: ${err.message}` : "Error: An Unspecified error occurred";
        response.statusCode = typeof err.status !== "undefined" ? err.status : 500;
        options.log.error(error);
        response.end(JSON.stringify({
            error: errorMessage
        }));
        return true;
    }
}
// pkg/dist-src/middleware/node/index.js
function createNodeMiddleware(webhooks, { path = "/api/github/webhooks", log = createLogger() } = {}) {
    return middleware.bind(null, webhooks, {
        path,
        log
    });
}
// pkg/dist-src/middleware/web/get-missing-headers.js
var WEBHOOK_HEADERS2 = [
    "x-github-event",
    "x-hub-signature-256",
    "x-github-delivery"
];
function getMissingHeaders2(request) {
    return WEBHOOK_HEADERS2.filter((header)=>!request.headers.has(header));
}
// pkg/dist-src/middleware/web/get-payload.js
function getPayload2(request) {
    return request.text();
}
// pkg/dist-src/middleware/web/on-unhandled-request-default.js
function onUnhandledRequestDefault2(request) {
    return new Response(JSON.stringify({
        error: `Unknown route: ${request.method} ${request.url}`
    }), {
        status: 404,
        headers: {
            "content-type": "application/json"
        }
    });
}
// pkg/dist-src/middleware/web/middleware.js
async function middleware2(webhooks, options, request) {
    let pathname;
    try {
        pathname = new URL(request.url, "http://localhost").pathname;
    } catch (error) {
        return new Response(JSON.stringify({
            error: `Request URL could not be parsed: ${request.url}`
        }), {
            status: 422,
            headers: {
                "content-type": "application/json"
            }
        });
    }
    if (pathname !== options.path || request.method !== "POST") {
        return onUnhandledRequestDefault2(request);
    }
    if (typeof request.headers.get("content-type") !== "string" || !request.headers.get("content-type").startsWith("application/json")) {
        return new Response(JSON.stringify({
            error: `Unsupported "Content-Type" header value. Must be "application/json"`
        }), {
            status: 415,
            headers: {
                "content-type": "application/json"
            }
        });
    }
    const missingHeaders = getMissingHeaders2(request).join(", ");
    if (missingHeaders) {
        return new Response(JSON.stringify({
            error: `Required headers missing: ${missingHeaders}`
        }), {
            status: 422,
            headers: {
                "content-type": "application/json"
            }
        });
    }
    const eventName = request.headers.get("x-github-event");
    const signatureSHA256 = request.headers.get("x-hub-signature-256");
    const id = request.headers.get("x-github-delivery");
    options.log.debug(`${eventName} event received (id: ${id})`);
    let didTimeout = false;
    let timeout;
    const timeoutPromise = new Promise((resolve)=>{
        timeout = setTimeout(()=>{
            didTimeout = true;
            resolve(new Response("still processing\n", {
                status: 202,
                headers: {
                    "Content-Type": "text/plain"
                }
            }));
        }, 9e3);
    });
    const processWebhook = async ()=>{
        try {
            const payload = await getPayload2(request);
            await webhooks.verifyAndReceive({
                id,
                name: eventName,
                payload,
                signature: signatureSHA256
            });
            clearTimeout(timeout);
            if (didTimeout) return new Response(null);
            return new Response("ok\n");
        } catch (error) {
            clearTimeout(timeout);
            if (didTimeout) return new Response(null);
            const err = Array.from(error.errors)[0];
            const errorMessage = err.message ? `${err.name}: ${err.message}` : "Error: An Unspecified error occurred";
            options.log.error(error);
            return new Response(JSON.stringify({
                error: errorMessage
            }), {
                status: typeof err.status !== "undefined" ? err.status : 500,
                headers: {
                    "content-type": "application/json"
                }
            });
        }
    };
    return await Promise.race([
        timeoutPromise,
        processWebhook()
    ]);
}
// pkg/dist-src/middleware/web/index.js
function createWebMiddleware(webhooks, { path = "/api/github/webhooks", log = createLogger() } = {}) {
    return middleware2.bind(null, webhooks, {
        path,
        log
    });
}
// pkg/dist-src/index.js
var Webhooks = class {
    sign;
    verify;
    on;
    onAny;
    onError;
    removeListener;
    receive;
    verifyAndReceive;
    constructor(options){
        if (!options || !options.secret) {
            throw new Error("[@octokit/webhooks] options.secret required");
        }
        const state = {
            eventHandler: createEventHandler(options),
            secret: options.secret,
            additionalSecrets: options.additionalSecrets,
            hooks: {},
            log: createLogger(options.log)
        };
        this.sign = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sign"].bind(null, options.secret);
        this.verify = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2d$methods$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verify"].bind(null, options.secret);
        this.on = state.eventHandler.on;
        this.onAny = state.eventHandler.onAny;
        this.onError = state.eventHandler.onError;
        this.removeListener = state.eventHandler.removeListener;
        this.receive = state.eventHandler.receive;
        this.verifyAndReceive = verifyAndReceive.bind(null, state);
    }
};
;
}}),
"[project]/node_modules/@octokit/app/dist-web/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/index.js
__turbopack_context__.s({
    "App": (()=>App),
    "createNodeMiddleware": (()=>createNodeMiddleware)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/core/dist-src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-app/dist-node/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-app/dist-node/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/auth-unauthenticated/dist-web/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/webhooks/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/each-installation.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-client] (ecmascript)");
;
;
;
// pkg/dist-src/version.js
var VERSION = "15.1.6";
;
;
;
function webhooks(appOctokit, options) {
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Webhooks"]({
        secret: options.secret,
        transform: async (event)=>{
            if (!("installation" in event.payload) || typeof event.payload.installation !== "object") {
                const octokit2 = new appOctokit.constructor({
                    authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$unauthenticated$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createUnauthenticatedAuth"],
                    auth: {
                        reason: `"installation" key missing in webhook event payload`
                    }
                });
                return {
                    ...event,
                    octokit: octokit2
                };
            }
            const installationId = event.payload.installation.id;
            const octokit = await appOctokit.auth({
                type: "installation",
                installationId,
                factory (auth) {
                    return new auth.octokit.constructor({
                        ...auth.octokitOptions,
                        authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
                        ...{
                            auth: {
                                ...auth,
                                installationId
                            }
                        }
                    });
                }
            });
            octokit.hook.before("request", (options2)=>{
                options2.headers["x-github-delivery"] = event.id;
            });
            return {
                ...event,
                octokit
            };
        }
    });
}
;
;
async function getInstallationOctokit(app, installationId) {
    return app.octokit.auth({
        type: "installation",
        installationId,
        factory (auth) {
            const options = {
                ...auth.octokitOptions,
                authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
                ...{
                    auth: {
                        ...auth,
                        installationId
                    }
                }
            };
            return new auth.octokit.constructor(options);
        }
    });
}
// pkg/dist-src/each-installation.js
function eachInstallationFactory(app) {
    return Object.assign(eachInstallation.bind(null, app), {
        iterator: eachInstallationIterator.bind(null, app)
    });
}
async function eachInstallation(app, callback) {
    const i = eachInstallationIterator(app)[Symbol.asyncIterator]();
    let result = await i.next();
    while(!result.done){
        await callback(result.value);
        result = await i.next();
    }
}
function eachInstallationIterator(app) {
    return {
        async *[Symbol.asyncIterator] () {
            const iterator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composePaginateRest"].iterator(app.octokit, "GET /app/installations");
            for await (const { data: installations } of iterator){
                for (const installation of installations){
                    const installationOctokit = await getInstallationOctokit(app, installation.id);
                    yield {
                        octokit: installationOctokit,
                        installation
                    };
                }
            }
        }
    };
}
;
function eachRepositoryFactory(app) {
    return Object.assign(eachRepository.bind(null, app), {
        iterator: eachRepositoryIterator.bind(null, app)
    });
}
async function eachRepository(app, queryOrCallback, callback) {
    const i = eachRepositoryIterator(app, callback ? queryOrCallback : void 0)[Symbol.asyncIterator]();
    let result = await i.next();
    while(!result.done){
        if (callback) {
            await callback(result.value);
        } else {
            await queryOrCallback(result.value);
        }
        result = await i.next();
    }
}
function singleInstallationIterator(app, installationId) {
    return {
        async *[Symbol.asyncIterator] () {
            yield {
                octokit: await app.getInstallationOctokit(installationId)
            };
        }
    };
}
function eachRepositoryIterator(app, query) {
    return {
        async *[Symbol.asyncIterator] () {
            const iterator = query ? singleInstallationIterator(app, query.installationId) : app.eachInstallation.iterator();
            for await (const { octokit } of iterator){
                const repositoriesIterator = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["composePaginateRest"].iterator(octokit, "GET /installation/repositories");
                for await (const { data: repositories } of repositoriesIterator){
                    for (const repository of repositories){
                        yield {
                            octokit,
                            repository
                        };
                    }
                }
            }
        }
    };
}
// pkg/dist-src/get-installation-url.js
function getInstallationUrlFactory(app) {
    let installationUrlBasePromise;
    return async function getInstallationUrl(options = {}) {
        if (!installationUrlBasePromise) {
            installationUrlBasePromise = getInstallationUrlBase(app);
        }
        const installationUrlBase = await installationUrlBasePromise;
        const installationUrl = new URL(installationUrlBase);
        if (options.target_id !== void 0) {
            installationUrl.pathname += "/permissions";
            installationUrl.searchParams.append("target_id", options.target_id.toFixed());
        }
        if (options.state !== void 0) {
            installationUrl.searchParams.append("state", options.state);
        }
        return installationUrl.href;
    };
}
async function getInstallationUrlBase(app) {
    const { data: appInfo } = await app.octokit.request("GET /app");
    if (!appInfo) {
        throw new Error("[@octokit/app] unable to fetch metadata for app");
    }
    return `${appInfo.html_url}/installations/new`;
}
;
;
function noop() {}
function createNodeMiddleware(app, options = {}) {
    const log = Object.assign({
        debug: noop,
        info: noop,
        warn: console.warn.bind(console),
        error: console.error.bind(console)
    }, options.log);
    const optionsWithDefaults = {
        pathPrefix: "/api/github",
        ...options,
        log
    };
    const webhooksMiddleware = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$webhooks$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNodeMiddleware"])(app.webhooks, {
        path: optionsWithDefaults.pathPrefix + "/webhooks",
        log
    });
    const oauthMiddleware = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNodeMiddleware"])(app.oauth, {
        pathPrefix: optionsWithDefaults.pathPrefix + "/oauth"
    });
    return middleware.bind(null, optionsWithDefaults.pathPrefix, webhooksMiddleware, oauthMiddleware);
}
async function middleware(pathPrefix, webhooksMiddleware, oauthMiddleware, request, response, next) {
    const { pathname } = new URL(request.url, "http://localhost");
    if (pathname.startsWith(`${pathPrefix}/`)) {
        if (pathname === `${pathPrefix}/webhooks`) {
            webhooksMiddleware(request, response);
        } else if (pathname.startsWith(`${pathPrefix}/oauth/`)) {
            oauthMiddleware(request, response);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sendNodeResponse"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unknownRouteResponse"])(request), response);
        }
        return true;
    } else {
        next?.();
        return false;
    }
}
// pkg/dist-src/index.js
var App = class {
    static VERSION = VERSION;
    static defaults(defaults) {
        const AppWithDefaults = class extends this {
            constructor(...args){
                super({
                    ...defaults,
                    ...args[0]
                });
            }
        };
        return AppWithDefaults;
    }
    octokit;
    // @ts-ignore calling app.webhooks will throw a helpful error when options.webhooks is not set
    webhooks;
    // @ts-ignore calling app.oauth will throw a helpful error when options.oauth is not set
    oauth;
    getInstallationOctokit;
    eachInstallation;
    eachRepository;
    getInstallationUrl;
    log;
    constructor(options){
        const Octokit = options.Octokit || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Octokit"];
        const authOptions = Object.assign({
            appId: options.appId,
            privateKey: options.privateKey
        }, options.oauth ? {
            clientId: options.oauth.clientId,
            clientSecret: options.oauth.clientSecret
        } : {});
        const octokitOptions = {
            authStrategy: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$auth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAppAuth"],
            auth: authOptions
        };
        if ("log" in options && typeof options.log !== "undefined") {
            octokitOptions.log = options.log;
        }
        this.octokit = new Octokit(octokitOptions);
        this.log = Object.assign({
            debug: ()=>{},
            info: ()=>{},
            warn: console.warn.bind(console),
            error: console.error.bind(console)
        }, options.log);
        if (options.webhooks) {
            this.webhooks = webhooks(this.octokit, options.webhooks);
        } else {
            Object.defineProperty(this, "webhooks", {
                get () {
                    throw new Error("[@octokit/app] webhooks option not set");
                }
            });
        }
        if (options.oauth) {
            this.oauth = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OAuthApp"]({
                ...options.oauth,
                clientType: "github-app",
                Octokit
            });
        } else {
            Object.defineProperty(this, "oauth", {
                get () {
                    throw new Error("[@octokit/app] oauth.clientId / oauth.clientSecret options are not set");
                }
            });
        }
        this.getInstallationOctokit = getInstallationOctokit.bind(null, this);
        this.eachInstallation = eachInstallationFactory(this);
        this.eachRepository = eachRepositoryFactory(this);
        this.getInstallationUrl = getInstallationUrlFactory(this);
    }
};
;
}}),
"[project]/node_modules/octokit/dist-bundle/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// pkg/dist-src/octokit.js
__turbopack_context__.s({
    "App": (()=>App),
    "OAuthApp": (()=>OAuthApp),
    "Octokit": (()=>Octokit)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/core/dist-src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-paginate-rest/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-paginate-graphql/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-rest-endpoint-methods/dist-src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$retry$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-retry/dist-bundle/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$throttling$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/plugin-throttling/dist-bundle/index.js [app-client] (ecmascript)");
// pkg/dist-src/app.js
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$app$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/app/dist-web/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@octokit/oauth-app/dist-node/index.js [app-client] (ecmascript)");
;
;
;
;
;
;
// pkg/dist-src/version.js
var VERSION = "0.0.0-development";
;
var Octokit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$core$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Octokit"].plugin(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$rest$2d$endpoint$2d$methods$2f$dist$2d$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["restEndpointMethods"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$rest$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paginateRest"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$paginate$2d$graphql$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["paginateGraphQL"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$retry$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["retry"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$plugin$2d$throttling$2f$dist$2d$bundle$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throttling"]).defaults({
    userAgent: `octokit.js/${VERSION}`,
    throttle: {
        onRateLimit,
        onSecondaryRateLimit
    }
});
function onRateLimit(retryAfter, options, octokit) {
    octokit.log.warn(`Request quota exhausted for request ${options.method} ${options.url}`);
    if (options.request.retryCount === 0) {
        octokit.log.info(`Retrying after ${retryAfter} seconds!`);
        return true;
    }
}
function onSecondaryRateLimit(retryAfter, options, octokit) {
    octokit.log.warn(`SecondaryRateLimit detected for request ${options.method} ${options.url}`);
    if (options.request.retryCount === 0) {
        octokit.log.info(`Retrying after ${retryAfter} seconds!`);
        return true;
    }
}
;
;
;
var App = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$app$2f$dist$2d$web$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["App"].defaults({
    Octokit
});
var OAuthApp = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$octokit$2f$oauth$2d$app$2f$dist$2d$node$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OAuthApp"].defaults({
    Octokit
});
;
}}),
"[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>_extends)
});
function _extends() {
    return _extends = ("TURBOPACK compile-time truthy", 1) ? Object.assign.bind() : ("TURBOPACK unreachable", undefined), _extends.apply(null, arguments);
}
;
}}),
"[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "difference": (()=>difference),
    "ensureQueryKeyArray": (()=>ensureQueryKeyArray),
    "functionalUpdate": (()=>functionalUpdate),
    "getAbortController": (()=>getAbortController),
    "hashQueryKey": (()=>hashQueryKey),
    "hashQueryKeyByOptions": (()=>hashQueryKeyByOptions),
    "isError": (()=>isError),
    "isPlainObject": (()=>isPlainObject),
    "isQueryKey": (()=>isQueryKey),
    "isServer": (()=>isServer),
    "isValidTimeout": (()=>isValidTimeout),
    "mapQueryStatusFilter": (()=>mapQueryStatusFilter),
    "matchMutation": (()=>matchMutation),
    "matchQuery": (()=>matchQuery),
    "noop": (()=>noop),
    "parseFilterArgs": (()=>parseFilterArgs),
    "parseMutationArgs": (()=>parseMutationArgs),
    "parseMutationFilterArgs": (()=>parseMutationFilterArgs),
    "parseQueryArgs": (()=>parseQueryArgs),
    "partialDeepEqual": (()=>partialDeepEqual),
    "partialMatchKey": (()=>partialMatchKey),
    "replaceAt": (()=>replaceAt),
    "replaceEqualDeep": (()=>replaceEqualDeep),
    "scheduleMicrotask": (()=>scheduleMicrotask),
    "shallowEqualObjects": (()=>shallowEqualObjects),
    "sleep": (()=>sleep),
    "stableValueHash": (()=>stableValueHash),
    "timeUntilStale": (()=>timeUntilStale)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
;
var isServer = typeof window === 'undefined';
function noop() {
    return undefined;
}
function functionalUpdate(updater, input) {
    return typeof updater === 'function' ? updater(input) : updater;
}
function isValidTimeout(value) {
    return typeof value === 'number' && value >= 0 && value !== Infinity;
}
function ensureQueryKeyArray(value) {
    return Array.isArray(value) ? value : [
        value
    ];
}
function difference(array1, array2) {
    return array1.filter(function(x) {
        return array2.indexOf(x) === -1;
    });
}
function replaceAt(array, index, value) {
    var copy = array.slice(0);
    copy[index] = value;
    return copy;
}
function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function parseQueryArgs(arg1, arg2, arg3) {
    if (!isQueryKey(arg1)) {
        return arg1;
    }
    if (typeof arg2 === 'function') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg3, {
            queryKey: arg1,
            queryFn: arg2
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg2, {
        queryKey: arg1
    });
}
function parseMutationArgs(arg1, arg2, arg3) {
    if (isQueryKey(arg1)) {
        if (typeof arg2 === 'function') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg3, {
                mutationKey: arg1,
                mutationFn: arg2
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg2, {
            mutationKey: arg1
        });
    }
    if (typeof arg1 === 'function') {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg2, {
            mutationFn: arg1
        });
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg1);
}
function parseFilterArgs(arg1, arg2, arg3) {
    return isQueryKey(arg1) ? [
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg2, {
            queryKey: arg1
        }),
        arg3
    ] : [
        arg1 || {},
        arg2
    ];
}
function parseMutationFilterArgs(arg1, arg2) {
    return isQueryKey(arg1) ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, arg2, {
        mutationKey: arg1
    }) : arg1;
}
function mapQueryStatusFilter(active, inactive) {
    if (active === true && inactive === true || active == null && inactive == null) {
        return 'all';
    } else if (active === false && inactive === false) {
        return 'none';
    } else {
        // At this point, active|inactive can only be true|false or false|true
        // so, when only one value is provided, the missing one has to be the negated value
        var isActive = active != null ? active : !inactive;
        return isActive ? 'active' : 'inactive';
    }
}
function matchQuery(filters, query) {
    var active = filters.active, exact = filters.exact, fetching = filters.fetching, inactive = filters.inactive, predicate = filters.predicate, queryKey = filters.queryKey, stale = filters.stale;
    if (isQueryKey(queryKey)) {
        if (exact) {
            if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
                return false;
            }
        } else if (!partialMatchKey(query.queryKey, queryKey)) {
            return false;
        }
    }
    var queryStatusFilter = mapQueryStatusFilter(active, inactive);
    if (queryStatusFilter === 'none') {
        return false;
    } else if (queryStatusFilter !== 'all') {
        var isActive = query.isActive();
        if (queryStatusFilter === 'active' && !isActive) {
            return false;
        }
        if (queryStatusFilter === 'inactive' && isActive) {
            return false;
        }
    }
    if (typeof stale === 'boolean' && query.isStale() !== stale) {
        return false;
    }
    if (typeof fetching === 'boolean' && query.isFetching() !== fetching) {
        return false;
    }
    if (predicate && !predicate(query)) {
        return false;
    }
    return true;
}
function matchMutation(filters, mutation) {
    var exact = filters.exact, fetching = filters.fetching, predicate = filters.predicate, mutationKey = filters.mutationKey;
    if (isQueryKey(mutationKey)) {
        if (!mutation.options.mutationKey) {
            return false;
        }
        if (exact) {
            if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
                return false;
            }
        } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
            return false;
        }
    }
    if (typeof fetching === 'boolean' && mutation.state.status === 'loading' !== fetching) {
        return false;
    }
    if (predicate && !predicate(mutation)) {
        return false;
    }
    return true;
}
function hashQueryKeyByOptions(queryKey, options) {
    var hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashQueryKey;
    return hashFn(queryKey);
}
function hashQueryKey(queryKey) {
    var asArray = ensureQueryKeyArray(queryKey);
    return stableValueHash(asArray);
}
function stableValueHash(value) {
    return JSON.stringify(value, function(_, val) {
        return isPlainObject(val) ? Object.keys(val).sort().reduce(function(result, key) {
            result[key] = val[key];
            return result;
        }, {}) : val;
    });
}
function partialMatchKey(a, b) {
    return partialDeepEqual(ensureQueryKeyArray(a), ensureQueryKeyArray(b));
}
function partialDeepEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (typeof a !== typeof b) {
        return false;
    }
    if (a && b && typeof a === 'object' && typeof b === 'object') {
        return !Object.keys(b).some(function(key) {
            return !partialDeepEqual(a[key], b[key]);
        });
    }
    return false;
}
function replaceEqualDeep(a, b) {
    if (a === b) {
        return a;
    }
    var array = Array.isArray(a) && Array.isArray(b);
    if (array || isPlainObject(a) && isPlainObject(b)) {
        var aSize = array ? a.length : Object.keys(a).length;
        var bItems = array ? b : Object.keys(b);
        var bSize = bItems.length;
        var copy = array ? [] : {};
        var equalItems = 0;
        for(var i = 0; i < bSize; i++){
            var key = array ? i : bItems[i];
            copy[key] = replaceEqualDeep(a[key], b[key]);
            if (copy[key] === a[key]) {
                equalItems++;
            }
        }
        return aSize === bSize && equalItems === aSize ? a : copy;
    }
    return b;
}
function shallowEqualObjects(a, b) {
    if (a && !b || b && !a) {
        return false;
    }
    for(var key in a){
        if (a[key] !== b[key]) {
            return false;
        }
    }
    return true;
} // Copied from: https://github.com/jonschlinkert/is-plain-object
function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
        return false;
    } // If has modified constructor
    var ctor = o.constructor;
    if (typeof ctor === 'undefined') {
        return true;
    } // If has modified prototype
    var prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
        return false;
    } // If constructor does not have an Object-specific method
    if (!prot.hasOwnProperty('isPrototypeOf')) {
        return false;
    } // Most likely a plain Object
    return true;
}
function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
}
function isQueryKey(value) {
    return typeof value === 'string' || Array.isArray(value);
}
function isError(value) {
    return value instanceof Error;
}
function sleep(timeout) {
    return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
    });
}
function scheduleMicrotask(callback) {
    Promise.resolve().then(callback).catch(function(error) {
        return setTimeout(function() {
            throw error;
        });
    });
}
function getAbortController() {
    if (typeof AbortController === 'function') {
        return new AbortController();
    }
}
}}),
"[project]/node_modules/react-query/es/core/notifyManager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "NotifyManager": (()=>NotifyManager),
    "notifyManager": (()=>notifyManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)"); // TYPES
;
var NotifyManager = /*#__PURE__*/ function() {
    function NotifyManager() {
        this.queue = [];
        this.transactions = 0;
        this.notifyFn = function(callback) {
            callback();
        };
        this.batchNotifyFn = function(callback) {
            callback();
        };
    }
    var _proto = NotifyManager.prototype;
    _proto.batch = function batch(callback) {
        var result;
        this.transactions++;
        try {
            result = callback();
        } finally{
            this.transactions--;
            if (!this.transactions) {
                this.flush();
            }
        }
        return result;
    };
    _proto.schedule = function schedule(callback) {
        var _this = this;
        if (this.transactions) {
            this.queue.push(callback);
        } else {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scheduleMicrotask"])(function() {
                _this.notifyFn(callback);
            });
        }
    };
    _proto.batchCalls = function batchCalls(callback) {
        var _this2 = this;
        return function() {
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            _this2.schedule(function() {
                callback.apply(void 0, args);
            });
        };
    };
    _proto.flush = function flush() {
        var _this3 = this;
        var queue = this.queue;
        this.queue = [];
        if (queue.length) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["scheduleMicrotask"])(function() {
                _this3.batchNotifyFn(function() {
                    queue.forEach(function(callback) {
                        _this3.notifyFn(callback);
                    });
                });
            });
        }
    };
    _proto.setNotifyFunction = function setNotifyFunction(fn) {
        this.notifyFn = fn;
    };
    _proto.setBatchNotifyFunction = function setBatchNotifyFunction(fn) {
        this.batchNotifyFn = fn;
    };
    return NotifyManager;
}(); // SINGLETON
var notifyManager = new NotifyManager();
}}),
"[project]/node_modules/react-query/es/react/reactBatchedUpdates.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "unstable_batchedUpdates": (()=>unstable_batchedUpdates)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react-dom/index.js [app-client] (ecmascript)");
;
var unstable_batchedUpdates = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2d$dom$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].unstable_batchedUpdates;
}}),
"[project]/node_modules/react-query/es/react/setBatchUpdatesFn.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$reactBatchedUpdates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/reactBatchedUpdates.js [app-client] (ecmascript)");
;
;
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].setBatchNotifyFunction(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$reactBatchedUpdates$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["unstable_batchedUpdates"]);
}}),
"[project]/node_modules/react-query/es/core/logger.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// TYPES
// FUNCTIONS
__turbopack_context__.s({
    "getLogger": (()=>getLogger),
    "setLogger": (()=>setLogger)
});
var logger = console;
function getLogger() {
    return logger;
}
function setLogger(newLogger) {
    logger = newLogger;
}
}}),
"[project]/node_modules/react-query/es/react/logger.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "logger": (()=>logger)
});
var logger = console;
}}),
"[project]/node_modules/react-query/es/react/setLogger.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/logger.js [app-client] (ecmascript)");
;
;
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["setLogger"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["logger"]);
}}),
"[project]/node_modules/react-query/es/react/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Side effects
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$setBatchUpdatesFn$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/setBatchUpdatesFn.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$setLogger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/setLogger.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
}}),
"[project]/node_modules/react-query/es/react/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$setBatchUpdatesFn$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/setBatchUpdatesFn.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$setLogger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/setLogger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/react-query/es/index.js [app-client] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/index.js [app-client] (ecmascript) <module evaluation>");
;
;
}}),
"[project]/node_modules/react-query/es/index.js [app-client] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/index.js [app-client] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/index.js [app-client] (ecmascript) <locals>");
}}),
"[project]/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>_setPrototypeOf)
});
function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
        return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
}
;
}}),
"[project]/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>_inheritsLoose)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$setPrototypeOf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js [app-client] (ecmascript)");
;
function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$setPrototypeOf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(t, o);
}
;
}}),
"[project]/node_modules/react-query/es/core/subscribable.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "Subscribable": (()=>Subscribable)
});
var Subscribable = /*#__PURE__*/ function() {
    function Subscribable() {
        this.listeners = [];
    }
    var _proto = Subscribable.prototype;
    _proto.subscribe = function subscribe(listener) {
        var _this = this;
        var callback = listener || function() {
            return undefined;
        };
        this.listeners.push(callback);
        this.onSubscribe();
        return function() {
            _this.listeners = _this.listeners.filter(function(x) {
                return x !== callback;
            });
            _this.onUnsubscribe();
        };
    };
    _proto.hasListeners = function hasListeners() {
        return this.listeners.length > 0;
    };
    _proto.onSubscribe = function onSubscribe() {};
    _proto.onUnsubscribe = function onUnsubscribe() {};
    return Subscribable;
}();
}}),
"[project]/node_modules/react-query/es/core/focusManager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FocusManager": (()=>FocusManager),
    "focusManager": (()=>focusManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/subscribable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)");
;
;
;
var FocusManager = /*#__PURE__*/ function(_Subscribable) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(FocusManager, _Subscribable);
    function FocusManager() {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.setup = function(onFocus) {
            var _window;
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] && ((_window = window) == null ? void 0 : _window.addEventListener)) {
                var listener = function listener() {
                    return onFocus();
                }; // Listen to visibillitychange and focus
                window.addEventListener('visibilitychange', listener, false);
                window.addEventListener('focus', listener, false);
                return function() {
                    // Be sure to unsubscribe if a new handler is set
                    window.removeEventListener('visibilitychange', listener);
                    window.removeEventListener('focus', listener);
                };
            }
        };
        return _this;
    }
    var _proto = FocusManager.prototype;
    _proto.onSubscribe = function onSubscribe() {
        if (!this.cleanup) {
            this.setEventListener(this.setup);
        }
    };
    _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.hasListeners()) {
            var _this$cleanup;
            (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
            this.cleanup = undefined;
        }
    };
    _proto.setEventListener = function setEventListener(setup) {
        var _this$cleanup2, _this2 = this;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup(function(focused) {
            if (typeof focused === 'boolean') {
                _this2.setFocused(focused);
            } else {
                _this2.onFocus();
            }
        });
    };
    _proto.setFocused = function setFocused(focused) {
        this.focused = focused;
        if (focused) {
            this.onFocus();
        }
    };
    _proto.onFocus = function onFocus() {
        this.listeners.forEach(function(listener) {
            listener();
        });
    };
    _proto.isFocused = function isFocused() {
        if (typeof this.focused === 'boolean') {
            return this.focused;
        } // document global can be unavailable in react native
        if (typeof document === 'undefined') {
            return true;
        }
        return [
            undefined,
            'visible',
            'prerender'
        ].includes(document.visibilityState);
    };
    return FocusManager;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscribable"]);
var focusManager = new FocusManager();
}}),
"[project]/node_modules/react-query/es/core/onlineManager.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "OnlineManager": (()=>OnlineManager),
    "onlineManager": (()=>onlineManager)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/subscribable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)");
;
;
;
var OnlineManager = /*#__PURE__*/ function(_Subscribable) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(OnlineManager, _Subscribable);
    function OnlineManager() {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.setup = function(onOnline) {
            var _window;
            if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] && ((_window = window) == null ? void 0 : _window.addEventListener)) {
                var listener = function listener() {
                    return onOnline();
                }; // Listen to online
                window.addEventListener('online', listener, false);
                window.addEventListener('offline', listener, false);
                return function() {
                    // Be sure to unsubscribe if a new handler is set
                    window.removeEventListener('online', listener);
                    window.removeEventListener('offline', listener);
                };
            }
        };
        return _this;
    }
    var _proto = OnlineManager.prototype;
    _proto.onSubscribe = function onSubscribe() {
        if (!this.cleanup) {
            this.setEventListener(this.setup);
        }
    };
    _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.hasListeners()) {
            var _this$cleanup;
            (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
            this.cleanup = undefined;
        }
    };
    _proto.setEventListener = function setEventListener(setup) {
        var _this$cleanup2, _this2 = this;
        this.setup = setup;
        (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
        this.cleanup = setup(function(online) {
            if (typeof online === 'boolean') {
                _this2.setOnline(online);
            } else {
                _this2.onOnline();
            }
        });
    };
    _proto.setOnline = function setOnline(online) {
        this.online = online;
        if (online) {
            this.onOnline();
        }
    };
    _proto.onOnline = function onOnline() {
        this.listeners.forEach(function(listener) {
            listener();
        });
    };
    _proto.isOnline = function isOnline() {
        if (typeof this.online === 'boolean') {
            return this.online;
        }
        if (typeof navigator === 'undefined' || typeof navigator.onLine === 'undefined') {
            return true;
        }
        return navigator.onLine;
    };
    return OnlineManager;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscribable"]);
var onlineManager = new OnlineManager();
}}),
"[project]/node_modules/react-query/es/core/retryer.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CancelledError": (()=>CancelledError),
    "Retryer": (()=>Retryer),
    "isCancelable": (()=>isCancelable),
    "isCancelledError": (()=>isCancelledError)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/focusManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/onlineManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)");
;
;
;
function defaultRetryDelay(failureCount) {
    return Math.min(1000 * Math.pow(2, failureCount), 30000);
}
function isCancelable(value) {
    return typeof (value == null ? void 0 : value.cancel) === 'function';
}
var CancelledError = function CancelledError(options) {
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
};
function isCancelledError(value) {
    return value instanceof CancelledError;
} // CLASS
var Retryer = function Retryer(config) {
    var _this = this;
    var cancelRetry = false;
    var cancelFn;
    var continueFn;
    var promiseResolve;
    var promiseReject;
    this.abort = config.abort;
    this.cancel = function(cancelOptions) {
        return cancelFn == null ? void 0 : cancelFn(cancelOptions);
    };
    this.cancelRetry = function() {
        cancelRetry = true;
    };
    this.continueRetry = function() {
        cancelRetry = false;
    };
    this.continue = function() {
        return continueFn == null ? void 0 : continueFn();
    };
    this.failureCount = 0;
    this.isPaused = false;
    this.isResolved = false;
    this.isTransportCancelable = false;
    this.promise = new Promise(function(outerResolve, outerReject) {
        promiseResolve = outerResolve;
        promiseReject = outerReject;
    });
    var resolve = function resolve(value) {
        if (!_this.isResolved) {
            _this.isResolved = true;
            config.onSuccess == null ? void 0 : config.onSuccess(value);
            continueFn == null ? void 0 : continueFn();
            promiseResolve(value);
        }
    };
    var reject = function reject(value) {
        if (!_this.isResolved) {
            _this.isResolved = true;
            config.onError == null ? void 0 : config.onError(value);
            continueFn == null ? void 0 : continueFn();
            promiseReject(value);
        }
    };
    var pause = function pause() {
        return new Promise(function(continueResolve) {
            continueFn = continueResolve;
            _this.isPaused = true;
            config.onPause == null ? void 0 : config.onPause();
        }).then(function() {
            continueFn = undefined;
            _this.isPaused = false;
            config.onContinue == null ? void 0 : config.onContinue();
        });
    }; // Create loop function
    var run = function run() {
        // Do nothing if already resolved
        if (_this.isResolved) {
            return;
        }
        var promiseOrValue; // Execute query
        try {
            promiseOrValue = config.fn();
        } catch (error) {
            promiseOrValue = Promise.reject(error);
        } // Create callback to cancel this fetch
        cancelFn = function cancelFn(cancelOptions) {
            if (!_this.isResolved) {
                reject(new CancelledError(cancelOptions));
                _this.abort == null ? void 0 : _this.abort(); // Cancel transport if supported
                if (isCancelable(promiseOrValue)) {
                    try {
                        promiseOrValue.cancel();
                    } catch (_unused) {}
                }
            }
        }; // Check if the transport layer support cancellation
        _this.isTransportCancelable = isCancelable(promiseOrValue);
        Promise.resolve(promiseOrValue).then(resolve).catch(function(error) {
            var _config$retry, _config$retryDelay;
            // Stop if the fetch is already resolved
            if (_this.isResolved) {
                return;
            } // Do we need to retry the request?
            var retry = (_config$retry = config.retry) != null ? _config$retry : 3;
            var retryDelay = (_config$retryDelay = config.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
            var delay = typeof retryDelay === 'function' ? retryDelay(_this.failureCount, error) : retryDelay;
            var shouldRetry = retry === true || typeof retry === 'number' && _this.failureCount < retry || typeof retry === 'function' && retry(_this.failureCount, error);
            if (cancelRetry || !shouldRetry) {
                // We are done if the query does not need to be retried
                reject(error);
                return;
            }
            _this.failureCount++; // Notify on fail
            config.onFail == null ? void 0 : config.onFail(_this.failureCount, error); // Delay
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sleep"])(delay) // Pause if the document is not visible or when the device is offline
            .then(function() {
                if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusManager"].isFocused() || !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$onlineManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onlineManager"].isOnline()) {
                    return pause();
                }
            }).then(function() {
                if (cancelRetry) {
                    reject(error);
                } else {
                    run();
                }
            });
        });
    }; // Start loop
    run();
};
}}),
"[project]/node_modules/react-query/es/core/queryObserver.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryObserver": (()=>QueryObserver)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/extends.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/focusManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/subscribable.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/logger.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/retryer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
var QueryObserver = /*#__PURE__*/ function(_Subscribable) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$inheritsLoose$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(QueryObserver, _Subscribable);
    function QueryObserver(client, options) {
        var _this;
        _this = _Subscribable.call(this) || this;
        _this.client = client;
        _this.options = options;
        _this.trackedProps = [];
        _this.selectError = null;
        _this.bindMethods();
        _this.setOptions(options);
        return _this;
    }
    var _proto = QueryObserver.prototype;
    _proto.bindMethods = function bindMethods() {
        this.remove = this.remove.bind(this);
        this.refetch = this.refetch.bind(this);
    };
    _proto.onSubscribe = function onSubscribe() {
        if (this.listeners.length === 1) {
            this.currentQuery.addObserver(this);
            if (shouldFetchOnMount(this.currentQuery, this.options)) {
                this.executeFetch();
            }
            this.updateTimers();
        }
    };
    _proto.onUnsubscribe = function onUnsubscribe() {
        if (!this.listeners.length) {
            this.destroy();
        }
    };
    _proto.shouldFetchOnReconnect = function shouldFetchOnReconnect() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnReconnect);
    };
    _proto.shouldFetchOnWindowFocus = function shouldFetchOnWindowFocus() {
        return shouldFetchOn(this.currentQuery, this.options, this.options.refetchOnWindowFocus);
    };
    _proto.destroy = function destroy() {
        this.listeners = [];
        this.clearTimers();
        this.currentQuery.removeObserver(this);
    };
    _proto.setOptions = function setOptions(options, notifyOptions) {
        var prevOptions = this.options;
        var prevQuery = this.currentQuery;
        this.options = this.client.defaultQueryObserverOptions(options);
        if (typeof this.options.enabled !== 'undefined' && typeof this.options.enabled !== 'boolean') {
            throw new Error('Expected enabled to be a boolean');
        } // Keep previous query key if the user does not supply one
        if (!this.options.queryKey) {
            this.options.queryKey = prevOptions.queryKey;
        }
        this.updateQuery();
        var mounted = this.hasListeners(); // Fetch if there are subscribers
        if (mounted && shouldFetchOptionally(this.currentQuery, prevQuery, this.options, prevOptions)) {
            this.executeFetch();
        } // Update result
        this.updateResult(notifyOptions); // Update stale interval if needed
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || this.options.staleTime !== prevOptions.staleTime)) {
            this.updateStaleTimeout();
        }
        var nextRefetchInterval = this.computeRefetchInterval(); // Update refetch interval if needed
        if (mounted && (this.currentQuery !== prevQuery || this.options.enabled !== prevOptions.enabled || nextRefetchInterval !== this.currentRefetchInterval)) {
            this.updateRefetchInterval(nextRefetchInterval);
        }
    };
    _proto.getOptimisticResult = function getOptimisticResult(options) {
        var defaultedOptions = this.client.defaultQueryObserverOptions(options);
        var query = this.client.getQueryCache().build(this.client, defaultedOptions);
        return this.createResult(query, defaultedOptions);
    };
    _proto.getCurrentResult = function getCurrentResult() {
        return this.currentResult;
    };
    _proto.trackResult = function trackResult(result, defaultedOptions) {
        var _this2 = this;
        var trackedResult = {};
        var trackProp = function trackProp(key) {
            if (!_this2.trackedProps.includes(key)) {
                _this2.trackedProps.push(key);
            }
        };
        Object.keys(result).forEach(function(key) {
            Object.defineProperty(trackedResult, key, {
                configurable: false,
                enumerable: true,
                get: function get() {
                    trackProp(key);
                    return result[key];
                }
            });
        });
        if (defaultedOptions.useErrorBoundary || defaultedOptions.suspense) {
            trackProp('error');
        }
        return trackedResult;
    };
    _proto.getNextResult = function getNextResult(options) {
        var _this3 = this;
        return new Promise(function(resolve, reject) {
            var unsubscribe = _this3.subscribe(function(result) {
                if (!result.isFetching) {
                    unsubscribe();
                    if (result.isError && (options == null ? void 0 : options.throwOnError)) {
                        reject(result.error);
                    } else {
                        resolve(result);
                    }
                }
            });
        });
    };
    _proto.getCurrentQuery = function getCurrentQuery() {
        return this.currentQuery;
    };
    _proto.remove = function remove() {
        this.client.getQueryCache().remove(this.currentQuery);
    };
    _proto.refetch = function refetch(options) {
        return this.fetch((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, options, {
            meta: {
                refetchPage: options == null ? void 0 : options.refetchPage
            }
        }));
    };
    _proto.fetchOptimistic = function fetchOptimistic(options) {
        var _this4 = this;
        var defaultedOptions = this.client.defaultQueryObserverOptions(options);
        var query = this.client.getQueryCache().build(this.client, defaultedOptions);
        return query.fetch().then(function() {
            return _this4.createResult(query, defaultedOptions);
        });
    };
    _proto.fetch = function fetch(fetchOptions) {
        var _this5 = this;
        return this.executeFetch(fetchOptions).then(function() {
            _this5.updateResult();
            return _this5.currentResult;
        });
    };
    _proto.executeFetch = function executeFetch(fetchOptions) {
        // Make sure we reference the latest query as the current one might have been removed
        this.updateQuery(); // Fetch
        var promise = this.currentQuery.fetch(this.options, fetchOptions);
        if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
            promise = promise.catch(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["noop"]);
        }
        return promise;
    };
    _proto.updateStaleTimeout = function updateStaleTimeout() {
        var _this6 = this;
        this.clearStaleTimeout();
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] || this.currentResult.isStale || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidTimeout"])(this.options.staleTime)) {
            return;
        }
        var time = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["timeUntilStale"])(this.currentResult.dataUpdatedAt, this.options.staleTime); // The timeout is sometimes triggered 1 ms before the stale time expiration.
        // To mitigate this issue we always add 1 ms to the timeout.
        var timeout = time + 1;
        this.staleTimeoutId = setTimeout(function() {
            if (!_this6.currentResult.isStale) {
                _this6.updateResult();
            }
        }, timeout);
    };
    _proto.computeRefetchInterval = function computeRefetchInterval() {
        var _this$options$refetch;
        return typeof this.options.refetchInterval === 'function' ? this.options.refetchInterval(this.currentResult.data, this.currentQuery) : (_this$options$refetch = this.options.refetchInterval) != null ? _this$options$refetch : false;
    };
    _proto.updateRefetchInterval = function updateRefetchInterval(nextInterval) {
        var _this7 = this;
        this.clearRefetchInterval();
        this.currentRefetchInterval = nextInterval;
        if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isServer"] || this.options.enabled === false || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isValidTimeout"])(this.currentRefetchInterval) || this.currentRefetchInterval === 0) {
            return;
        }
        this.refetchIntervalId = setInterval(function() {
            if (_this7.options.refetchIntervalInBackground || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$focusManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["focusManager"].isFocused()) {
                _this7.executeFetch();
            }
        }, this.currentRefetchInterval);
    };
    _proto.updateTimers = function updateTimers() {
        this.updateStaleTimeout();
        this.updateRefetchInterval(this.computeRefetchInterval());
    };
    _proto.clearTimers = function clearTimers() {
        this.clearStaleTimeout();
        this.clearRefetchInterval();
    };
    _proto.clearStaleTimeout = function clearStaleTimeout() {
        if (this.staleTimeoutId) {
            clearTimeout(this.staleTimeoutId);
            this.staleTimeoutId = undefined;
        }
    };
    _proto.clearRefetchInterval = function clearRefetchInterval() {
        if (this.refetchIntervalId) {
            clearInterval(this.refetchIntervalId);
            this.refetchIntervalId = undefined;
        }
    };
    _proto.createResult = function createResult(query, options) {
        var prevQuery = this.currentQuery;
        var prevOptions = this.options;
        var prevResult = this.currentResult;
        var prevResultState = this.currentResultState;
        var prevResultOptions = this.currentResultOptions;
        var queryChange = query !== prevQuery;
        var queryInitialState = queryChange ? query.state : this.currentQueryInitialState;
        var prevQueryResult = queryChange ? this.currentResult : this.previousQueryResult;
        var state = query.state;
        var dataUpdatedAt = state.dataUpdatedAt, error = state.error, errorUpdatedAt = state.errorUpdatedAt, isFetching = state.isFetching, status = state.status;
        var isPreviousData = false;
        var isPlaceholderData = false;
        var data; // Optimistically set result in fetching state if needed
        if (options.optimisticResults) {
            var mounted = this.hasListeners();
            var fetchOnMount = !mounted && shouldFetchOnMount(query, options);
            var fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
            if (fetchOnMount || fetchOptionally) {
                isFetching = true;
                if (!dataUpdatedAt) {
                    status = 'loading';
                }
            }
        } // Keep previous data if needed
        if (options.keepPreviousData && !state.dataUpdateCount && (prevQueryResult == null ? void 0 : prevQueryResult.isSuccess) && status !== 'error') {
            data = prevQueryResult.data;
            dataUpdatedAt = prevQueryResult.dataUpdatedAt;
            status = prevQueryResult.status;
            isPreviousData = true;
        } else if (options.select && typeof state.data !== 'undefined') {
            // Memoize select result
            if (prevResult && state.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === this.selectFn) {
                data = this.selectResult;
            } else {
                try {
                    this.selectFn = options.select;
                    data = options.select(state.data);
                    if (options.structuralSharing !== false) {
                        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceEqualDeep"])(prevResult == null ? void 0 : prevResult.data, data);
                    }
                    this.selectResult = data;
                    this.selectError = null;
                } catch (selectError) {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLogger"])().error(selectError);
                    this.selectError = selectError;
                }
            }
        } else {
            data = state.data;
        } // Show placeholder data if needed
        if (typeof options.placeholderData !== 'undefined' && typeof data === 'undefined' && (status === 'loading' || status === 'idle')) {
            var placeholderData; // Memoize placeholder data
            if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
                placeholderData = prevResult.data;
            } else {
                placeholderData = typeof options.placeholderData === 'function' ? options.placeholderData() : options.placeholderData;
                if (options.select && typeof placeholderData !== 'undefined') {
                    try {
                        placeholderData = options.select(placeholderData);
                        if (options.structuralSharing !== false) {
                            placeholderData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["replaceEqualDeep"])(prevResult == null ? void 0 : prevResult.data, placeholderData);
                        }
                        this.selectError = null;
                    } catch (selectError) {
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$logger$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getLogger"])().error(selectError);
                        this.selectError = selectError;
                    }
                }
            }
            if (typeof placeholderData !== 'undefined') {
                status = 'success';
                data = placeholderData;
                isPlaceholderData = true;
            }
        }
        if (this.selectError) {
            error = this.selectError;
            data = this.selectResult;
            errorUpdatedAt = Date.now();
            status = 'error';
        }
        var result = {
            status: status,
            isLoading: status === 'loading',
            isSuccess: status === 'success',
            isError: status === 'error',
            isIdle: status === 'idle',
            data: data,
            dataUpdatedAt: dataUpdatedAt,
            error: error,
            errorUpdatedAt: errorUpdatedAt,
            failureCount: state.fetchFailureCount,
            errorUpdateCount: state.errorUpdateCount,
            isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,
            isFetchedAfterMount: state.dataUpdateCount > queryInitialState.dataUpdateCount || state.errorUpdateCount > queryInitialState.errorUpdateCount,
            isFetching: isFetching,
            isRefetching: isFetching && status !== 'loading',
            isLoadingError: status === 'error' && state.dataUpdatedAt === 0,
            isPlaceholderData: isPlaceholderData,
            isPreviousData: isPreviousData,
            isRefetchError: status === 'error' && state.dataUpdatedAt !== 0,
            isStale: isStale(query, options),
            refetch: this.refetch,
            remove: this.remove
        };
        return result;
    };
    _proto.shouldNotifyListeners = function shouldNotifyListeners(result, prevResult) {
        if (!prevResult) {
            return true;
        }
        var _this$options = this.options, notifyOnChangeProps = _this$options.notifyOnChangeProps, notifyOnChangePropsExclusions = _this$options.notifyOnChangePropsExclusions;
        if (!notifyOnChangeProps && !notifyOnChangePropsExclusions) {
            return true;
        }
        if (notifyOnChangeProps === 'tracked' && !this.trackedProps.length) {
            return true;
        }
        var includedProps = notifyOnChangeProps === 'tracked' ? this.trackedProps : notifyOnChangeProps;
        return Object.keys(result).some(function(key) {
            var typedKey = key;
            var changed = result[typedKey] !== prevResult[typedKey];
            var isIncluded = includedProps == null ? void 0 : includedProps.some(function(x) {
                return x === key;
            });
            var isExcluded = notifyOnChangePropsExclusions == null ? void 0 : notifyOnChangePropsExclusions.some(function(x) {
                return x === key;
            });
            return changed && !isExcluded && (!includedProps || isIncluded);
        });
    };
    _proto.updateResult = function updateResult(notifyOptions) {
        var prevResult = this.currentResult;
        this.currentResult = this.createResult(this.currentQuery, this.options);
        this.currentResultState = this.currentQuery.state;
        this.currentResultOptions = this.options; // Only notify if something has changed
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shallowEqualObjects"])(this.currentResult, prevResult)) {
            return;
        } // Determine which callbacks to trigger
        var defaultNotifyOptions = {
            cache: true
        };
        if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && this.shouldNotifyListeners(this.currentResult, prevResult)) {
            defaultNotifyOptions.listeners = true;
        }
        this.notify((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$babel$2f$runtime$2f$helpers$2f$esm$2f$extends$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])({}, defaultNotifyOptions, notifyOptions));
    };
    _proto.updateQuery = function updateQuery() {
        var query = this.client.getQueryCache().build(this.client, this.options);
        if (query === this.currentQuery) {
            return;
        }
        var prevQuery = this.currentQuery;
        this.currentQuery = query;
        this.currentQueryInitialState = query.state;
        this.previousQueryResult = this.currentResult;
        if (this.hasListeners()) {
            prevQuery == null ? void 0 : prevQuery.removeObserver(this);
            query.addObserver(this);
        }
    };
    _proto.onQueryUpdate = function onQueryUpdate(action) {
        var notifyOptions = {};
        if (action.type === 'success') {
            notifyOptions.onSuccess = true;
        } else if (action.type === 'error' && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$retryer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isCancelledError"])(action.error)) {
            notifyOptions.onError = true;
        }
        this.updateResult(notifyOptions);
        if (this.hasListeners()) {
            this.updateTimers();
        }
    };
    _proto.notify = function notify(notifyOptions) {
        var _this8 = this;
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batch(function() {
            // First trigger the configuration callbacks
            if (notifyOptions.onSuccess) {
                _this8.options.onSuccess == null ? void 0 : _this8.options.onSuccess(_this8.currentResult.data);
                _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(_this8.currentResult.data, null);
            } else if (notifyOptions.onError) {
                _this8.options.onError == null ? void 0 : _this8.options.onError(_this8.currentResult.error);
                _this8.options.onSettled == null ? void 0 : _this8.options.onSettled(undefined, _this8.currentResult.error);
            } // Then trigger the listeners
            if (notifyOptions.listeners) {
                _this8.listeners.forEach(function(listener) {
                    listener(_this8.currentResult);
                });
            } // Then the cache listeners
            if (notifyOptions.cache) {
                _this8.client.getQueryCache().notify({
                    query: _this8.currentQuery,
                    type: 'observerResultsUpdated'
                });
            }
        });
    };
    return QueryObserver;
}(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$subscribable$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Subscribable"]);
function shouldLoadOnMount(query, options) {
    return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
    return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
    if (options.enabled !== false) {
        var value = typeof field === 'function' ? field(query) : field;
        return value === 'always' || value !== false && isStale(query, options);
    }
    return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
    return options.enabled !== false && (query !== prevQuery || prevOptions.enabled === false) && (!options.suspense || query.state.status !== 'error') && isStale(query, options);
}
function isStale(query, options) {
    return query.isStaleByTime(options.staleTime);
}
}}),
"[project]/node_modules/react-query/es/react/QueryErrorResetBoundary.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryErrorResetBoundary": (()=>QueryErrorResetBoundary),
    "useQueryErrorResetBoundary": (()=>useQueryErrorResetBoundary)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"); // CONTEXT
;
function createValue() {
    var _isReset = false;
    return {
        clearReset: function clearReset() {
            _isReset = false;
        },
        reset: function reset() {
            _isReset = true;
        },
        isReset: function isReset() {
            return _isReset;
        }
    };
}
var QueryErrorResetBoundaryContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(createValue()); // HOOK
var useQueryErrorResetBoundary = function useQueryErrorResetBoundary() {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(QueryErrorResetBoundaryContext);
}; // COMPONENT
var QueryErrorResetBoundary = function QueryErrorResetBoundary(_ref) {
    var children = _ref.children;
    var value = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "QueryErrorResetBoundary.useMemo[value]": function() {
            return createValue();
        }
    }["QueryErrorResetBoundary.useMemo[value]"], []);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(QueryErrorResetBoundaryContext.Provider, {
        value: value
    }, typeof children === 'function' ? children(value) : children);
};
}}),
"[project]/node_modules/react-query/es/react/QueryClientProvider.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QueryClientProvider": (()=>QueryClientProvider),
    "useQueryClient": (()=>useQueryClient)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
;
var defaultContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(undefined);
var QueryClientSharingContext = /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createContext(false); // if contextSharing is on, we share the first and at least one
// instance of the context across the window
// to ensure that if React Query is used across
// different bundles or microfrontends they will
// all use the same **instance** of context, regardless
// of module scoping.
function getQueryClientContext(contextSharing) {
    if (contextSharing && typeof window !== 'undefined') {
        if (!window.ReactQueryClientContext) {
            window.ReactQueryClientContext = defaultContext;
        }
        return window.ReactQueryClientContext;
    }
    return defaultContext;
}
var useQueryClient = function useQueryClient() {
    var queryClient = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(getQueryClientContext(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useContext(QueryClientSharingContext)));
    if (!queryClient) {
        throw new Error('No QueryClient set, use QueryClientProvider to set one');
    }
    return queryClient;
};
var QueryClientProvider = function QueryClientProvider(_ref) {
    var client = _ref.client, _ref$contextSharing = _ref.contextSharing, contextSharing = _ref$contextSharing === void 0 ? false : _ref$contextSharing, children = _ref.children;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "QueryClientProvider.useEffect": function() {
            client.mount();
            return ({
                "QueryClientProvider.useEffect": function() {
                    client.unmount();
                }
            })["QueryClientProvider.useEffect"];
        }
    }["QueryClientProvider.useEffect"], [
        client
    ]);
    var Context = getQueryClientContext(contextSharing);
    return /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(QueryClientSharingContext.Provider, {
        value: contextSharing
    }, /*#__PURE__*/ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(Context.Provider, {
        value: client
    }, children));
};
}}),
"[project]/node_modules/react-query/es/react/utils.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "shouldThrowError": (()=>shouldThrowError)
});
function shouldThrowError(suspense, _useErrorBoundary, params) {
    // Allow useErrorBoundary function to override throwing behavior on a per-error basis
    if (typeof _useErrorBoundary === 'function') {
        return _useErrorBoundary.apply(void 0, params);
    } // Allow useErrorBoundary to override suspense's throwing behavior
    if (typeof _useErrorBoundary === 'boolean') return _useErrorBoundary; // If suspense is enabled default to throwing errors
    return !!suspense;
}
}}),
"[project]/node_modules/react-query/es/react/useBaseQuery.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useBaseQuery": (()=>useBaseQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/notifyManager.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$QueryErrorResetBoundary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/QueryErrorResetBoundary.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/QueryClientProvider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/utils.js [app-client] (ecmascript)");
;
;
;
;
;
function useBaseQuery(options, Observer) {
    var mountedRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(false);
    var _React$useState = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(0), forceUpdate = _React$useState[1];
    var queryClient = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$QueryClientProvider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryClient"])();
    var errorResetBoundary = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$QueryErrorResetBoundary$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useQueryErrorResetBoundary"])();
    var defaultedOptions = queryClient.defaultQueryObserverOptions(options); // Make sure results are optimistically set in fetching state before subscribing or updating options
    defaultedOptions.optimisticResults = true; // Include callbacks in batch renders
    if (defaultedOptions.onError) {
        defaultedOptions.onError = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onError);
    }
    if (defaultedOptions.onSuccess) {
        defaultedOptions.onSuccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSuccess);
    }
    if (defaultedOptions.onSettled) {
        defaultedOptions.onSettled = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls(defaultedOptions.onSettled);
    }
    if (defaultedOptions.suspense) {
        // Always set stale time when using suspense to prevent
        // fetching again when directly mounting after suspending
        if (typeof defaultedOptions.staleTime !== 'number') {
            defaultedOptions.staleTime = 1000;
        } // Set cache time to 1 if the option has been set to 0
        // when using suspense to prevent infinite loop of fetches
        if (defaultedOptions.cacheTime === 0) {
            defaultedOptions.cacheTime = 1;
        }
    }
    if (defaultedOptions.suspense || defaultedOptions.useErrorBoundary) {
        // Prevent retrying failed query if the error boundary has not been reset yet
        if (!errorResetBoundary.isReset()) {
            defaultedOptions.retryOnMount = false;
        }
    }
    var _React$useState2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState({
        "useBaseQuery.useState[_React$useState2]": function() {
            return new Observer(queryClient, defaultedOptions);
        }
    }["useBaseQuery.useState[_React$useState2]"]), observer = _React$useState2[0];
    var result = observer.getOptimisticResult(defaultedOptions);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useBaseQuery.useEffect": function() {
            mountedRef.current = true;
            errorResetBoundary.clearReset();
            var unsubscribe = observer.subscribe(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$notifyManager$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["notifyManager"].batchCalls({
                "useBaseQuery.useEffect.unsubscribe": function() {
                    if (mountedRef.current) {
                        forceUpdate({
                            "useBaseQuery.useEffect.unsubscribe": function(x) {
                                return x + 1;
                            }
                        }["useBaseQuery.useEffect.unsubscribe"]);
                    }
                }
            }["useBaseQuery.useEffect.unsubscribe"])); // Update result to make sure we did not miss any query updates
            // between creating the observer and subscribing to it.
            observer.updateResult();
            return ({
                "useBaseQuery.useEffect": function() {
                    mountedRef.current = false;
                    unsubscribe();
                }
            })["useBaseQuery.useEffect"];
        }
    }["useBaseQuery.useEffect"], [
        errorResetBoundary,
        observer
    ]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "useBaseQuery.useEffect": function() {
            // Do not notify on updates because of changes in the options because
            // these changes should already be reflected in the optimistic result.
            observer.setOptions(defaultedOptions, {
                listeners: false
            });
        }
    }["useBaseQuery.useEffect"], [
        defaultedOptions,
        observer
    ]); // Handle suspense
    if (defaultedOptions.suspense && result.isLoading) {
        throw observer.fetchOptimistic(defaultedOptions).then(function(_ref) {
            var data = _ref.data;
            defaultedOptions.onSuccess == null ? void 0 : defaultedOptions.onSuccess(data);
            defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(data, null);
        }).catch(function(error) {
            errorResetBoundary.clearReset();
            defaultedOptions.onError == null ? void 0 : defaultedOptions.onError(error);
            defaultedOptions.onSettled == null ? void 0 : defaultedOptions.onSettled(undefined, error);
        });
    } // Handle error boundary
    if (result.isError && !errorResetBoundary.isReset() && !result.isFetching && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldThrowError"])(defaultedOptions.suspense, defaultedOptions.useErrorBoundary, [
        result.error,
        observer.getCurrentQuery()
    ])) {
        throw result.error;
    } // Handle result property usage tracking
    if (defaultedOptions.notifyOnChangeProps === 'tracked') {
        result = observer.trackResult(result, defaultedOptions);
    }
    return result;
}
}}),
"[project]/node_modules/react-query/es/react/useQuery.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "useQuery": (()=>useQuery)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$queryObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/queryObserver.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/core/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$useBaseQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/react-query/es/react/useBaseQuery.js [app-client] (ecmascript)"); // HOOK
;
;
;
function useQuery(arg1, arg2, arg3) {
    var parsedOptions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parseQueryArgs"])(arg1, arg2, arg3);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$react$2f$useBaseQuery$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["useBaseQuery"])(parsedOptions, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$react$2d$query$2f$es$2f$core$2f$queryObserver$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["QueryObserver"]);
}
}}),
}]);

//# sourceMappingURL=node_modules_5162fc64._.js.map